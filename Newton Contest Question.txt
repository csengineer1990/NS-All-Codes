
 Contest 07-05-23
 DNA Sequence
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.
For example, "ACGAATTCCG" is a DNA sequence.
When studying DNA, it is useful to identify repeated sequences within the DNA.
Given a string s that represents a DNA sequence, return all the 10-letter long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order. This is a functional problem you have to complete the solve function.
Input
The first line of the input contains the string s.

Constraints
1 <= s. length() <= 1e5
s[i] is either 'A', 'C', 'G', or 'T'
Output
Complete the function and return the relevant strings.
ai_logoAI CodeLens
BETA
Example
Sample Input:-
GGGGGGGGGGGGG

Sample Output:-
GGGGGGGGGG

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        List<String> repeatedSequences = findRepeatedSequences(str);
        for (String sequence : repeatedSequences) {
            System.out.println(sequence);
        }
    }
    public static List<String> findRepeatedSequences(String s) {
          List<String> result = new ArrayList<>();
        Map<String, Integer> sequenceFreq = new HashMap<>();

        for (int i = 0; i <= s.length() - 10; i++) {
            String sequence = s.substring(i, i + 10);
            sequenceFreq.put(sequence, sequenceFreq.getOrDefault(sequence, 0) + 1);
        }

        for (Map.Entry<String, Integer> entry : sequenceFreq.entrySet()) {
            if (entry.getValue() > 1) {
                result.add(entry.getKey());
            }
        }

        Collections.sort(result); // Sort the output

        return result;
    }

}


Candy Shopping
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
There are N candies, ith of them costing pi. You have M amount of money with you. Find the maximum number of candies you can buy.
Input
The first line of the input contains two integers N and M.
The second line of the input contains N space seperated integers.

Constraints:
1 <= N <= 105
1 <= M <= 1014
1 <= pi <= 109
Output
Print the maximum number of candies you can buy.
ai_logoAI CodeLens
BETA
Example
Sample Input:
4 7
3 1 4 2

Sample Output:
3

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        // Your code here
        Scanner scanner = new Scanner(System.in);
        int N = scanner.nextInt();
        long M = scanner.nextLong();

        int[] cost = new int[N];
        for (int i = 0; i < N; i++) {
            cost[i] = scanner.nextInt();
        }

        Arrays.sort(cost);
        int totalCandies = 0;
        for (int i = 0; i < N; i++) {
            if (M >= cost[i]) {
                totalCandies++;
                M -= cost[i];
            } else {
                break;
            }
        }

        System.out.println(totalCandies);
    }
}


 Contest 26-03-23


React Question
Highlight Calendar
In this question, you will create a calendar with a highlight dates feature, and a clear button using HTML, CSS, and JavaScript. This question is divided into HTML, CSS, and JavaScript.

    HTML:
        Create a div with the class "calendar".

        Within the div with class="calendar", create 38 divs with every div having class="calendar-day". The first 7 divs should contain the text Sun, Mon, Tues, Wed, Thurs, Fri, and Sat. The rest of the divs should contain numbers from 1-31.

        Below the div with class="calendar", create a div with class="input-wrapper", and add 2 label tags, 2 input fields, and 2 buttons.
        The first label should contain the text "Date: ", and the input field associated with the first label should have the id="input-date" and of type="number". Make sure the for attribute of the label matches the input field's id.

        The second label should contain the text "Color: ", and the input field associated with the second label should have the id="input-color" and of type="text". Make sure the for attribute of the label matches the input field's id.
        The 2 buttons should have the id "highlight-button" and "clear-button", and text "Highlight Date" and "Clear All" respectively.

    CSS:
        The div with class="calendar" should have a grid layout, with grid-template-columns having repeat(7, 100px) value and grid-template-rows having repeat(6, 100px) value. Give a gap of 5px, and a bottom margin of 10px.

        The divs with class="calendar-day" should display flex, with justify content, and align items properties as center. Add a border of 1px solid and color rgb(0, 0, 0).

        Give div.input-wrapper a flex display, and align items as center.

        Last, the buttons should have a left margin of 10px.

    JS:
        The two input fields, one for the date and the other for the color, are where the user will input the date and the color.

        On clicking the "Highlight Date" button, update the background color of the selected date with the input color. And make sure, the value of both the input fields should reset.

        On clicking the "Clear All" button, restore the initial background color of all dates in the calendar.
<!-- html code goes here -->
<div class="calendar">
  <div class="calendar-day">Sun</div>
  <div class="calendar-day">Mon</div>
  <div class="calendar-day">Tue</div>
  <div class="calendar-day">Wed</div>
  <div class="calendar-day">Thu</div>
  <div class="calendar-day">Fri</div>
  <div class="calendar-day">Sat</div>
  <div class="calendar-day"></div>
  <div class="calendar-day"></div>
  <div class="calendar-day"></div>
  <div class="calendar-day"></div>
  <div class="calendar-day"></div>
  <div class="calendar-day">1</div>
  <div class="calendar-day">2</div>
  <div class="calendar-day">3</div>
  <div class="calendar-day">4</div>
  <div class="calendar-day">5</div>
  <div class="calendar-day">6</div>
  <div class="calendar-day">7</div>
  <div class="calendar-day">8</div>
  <div class="calendar-day">9</div>
  <div class="calendar-day">10</div>
  <div class="calendar-day">11</div>
  <div class="calendar-day">12</div>
  <div class="calendar-day">13</div>
  <div class="calendar-day">14</div>
  <div class="calendar-day">15</div>
  <div class="calendar-day">16</div>
  <div class="calendar-day">17</div>
  <div class="calendar-day">18</div>
  <div class="calendar-day">19</div>
  <div class="calendar-day">20</div>
  <div class="calendar-day">21</div>
  <div class="calendar-day">22</div>
  <div class="calendar-day">23</div>
  <div class="calendar-day">24</div>
  <div class="calendar-day">25</div>
  <div class="calendar-day">26</div>
  <div class="calendar-day">27</div>
  <div class="calendar-day">28</div>
  <div class="calendar-day">29</div>
  <div class="calendar-day">30</div>
  <div class="calendar-day">31</div>
</div>

<div class="input-wrapper">
  <label for="input-date">Date:</label>
  <input type="number" id="input-date">
  <label for="input-color">Color:</label>
  <input type="text" id="input-color">
  <button id="highlight-button">Highlight Date</button>
  <button id="clear-button">Clear All</button>
</div>

// javascript code goes here
// Get all the required elements from the HTML document
const inputDate = document.querySelector('#input-date');
const inputColor = document.querySelector('#input-color');
const highlightButton = document.querySelector('#highlight-button');
const clearButton = document.querySelector('#clear-button');
const calendarDays = document.querySelectorAll('.calendar-day');

// Add event listeners to the buttons
highlightButton.addEventListener('click', highlightDate);
clearButton.addEventListener('click', clearAll);

// Function to highlight the selected date
function highlightDate() {
  // Get the selected date from the input field
  const date = inputDate.value;
  // Get the color from the input field
  const color = inputColor.value;
  
  // Loop through all the calendar days
  calendarDays.forEach(day => {
    // If the current day matches the selected date
    if (day.textContent === date) {
      // Set the background color to the selected color
      day.style.backgroundColor = color;
    }
  });

  // Reset the input fields
  inputDate.value = '';
  inputColor.value = '';
}

// Function to clear all highlighted dates
function clearAll() {
  // Loop through all the calendar days
  calendarDays.forEach(day => {
    // Reset the background color to the initial value
    day.style.backgroundColor = '';
  });

  // Reset the input fields
  inputDate.value = '';
  inputColor.value = '';
}


/* css code goes here */
.calendar {
  display: grid;
  grid-template-columns: repeat(7, 100px);
  grid-template-rows: repeat(6, 100px);
  gap: 5px;
  margin-bottom: 10px;
}

.calendar-day {
  display: flex;
  justify-content: center;
  align-items: center;
  border: 1px solid rgb(0, 0, 0);
}

.input-wrapper {
  display: flex;
  align-items: center;
}

#highlight-button,
#clear-button {
  margin-left: 10px;
}





Contest 26-03-23
Row Sort (contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an integer N and a matrix of size N x N. Find the number of rows in it that are sorted in non - decreasing order.
Input
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function solve() that takes an integer N and an array A of size N x N as parameters.

Constraints
1<=N<=30
-109<=Ai, j<=109
Output
Return the number of rows that are sorted in non - decreasing order in the given matrix.
starsASK AI
BETA
Example
Sample Input:
4
1 2 3 4
5 2 1 5
1 3 3 4
5 5 2 1

Sample Output:
2

Explanation: Only the first and third rows are sorted in non - decreasing order.

class Solution {
    public static int solve(int N,int[][] A) {
        int count = 0;
        for (int i = 0; i < N; i++) {
            boolean sorted = true;
            for (int j = 1; j < N; j++) {
                if (A[i][j] < A[i][j-1]) {
                    sorted = false;
                    break;
                }
            }
            if (sorted) {
                count++;
            }
        }
        return count;
    }
}



Gift for newton (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
On his birthday, newton was given an n*n matrix and instructions for it. The instruction consisted of symbols L and R where if the symbol L is given you need to rotate the matrix 90 degrees to the left, and for the symbol R you need to rotate the matrix 90 degrees to the right. The instruction was only 3 characters in length so newton could handle the twists with ease. Your task is to display the matrix that newton had at the end of these turns.
Input
User Task:
Since this will be a functional problem, you don't have to take input. You have to complete the function Rotate() that takes an integer n and 2d matrix a of size n*n and a string of length 3 as parameters.

Constraints:
1 ≤ N ≤ 500
Numbers can range from 1 to 500.
Output
Output the final matrix n*n.
Example
Sample Input:-
2
1 2
3 4
RLR
Sample Output:-
3 1
4 2


class Solution {
    public void Rotate(int n,int [][]a,String s) {
        for (char c : s.toCharArray()) {
            if (c == 'L') {
                // rotate matrix 90 degrees to the left
                int[][] temp = new int[n][n];
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        temp[n-j-1][i] = a[i][j];
                    }
                }
                a = temp;
            } else if (c == 'R') {
                // rotate matrix 90 degrees to the right
                int[][] temp = new int[n][n];
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        temp[i][j] = a[n-j-1][i];
                    }
                }
                a = temp;
            }
        }
        // print the final matrix
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(a[i][j] + " ");
            }
            System.out.println();
        }
    }
}





Contest 19-03-23

Nth node from end of linked list
easy
Problem Statement
Given a linked list consisting of L nodes and given a number N. The task is to find the Nth node from the end of the linked list.
Input
First line of input contains number of testcase T. For each testcase, first line of input contains number of nodes in the linked list L and the number N. Next line contains N nodes of linked list.

User Task:
The task is to complete the function getNthFromLast() which takes two arguments: reference to head and N and you need to return Nth from end.

Constraints:
1 <= T <= 100
1 <= N <= L <= 10^3
Output
For each testcase, output the data of node which is at Nth distance from end.

/*
// information about the class Node
class Node
{
    int data;
    Node next;
    Node(int d) 
    {
        data = d; 
        next = null;
    }
}
*/
static int getNthFromLast(Node head, int n)
{

    int len = 0;
    Node temp = head;

    while(temp != null){
        temp = temp.next;
        len++;
    }

    if(len < n) return -1;
    
    temp = head;

    for(int i = 1; i < len - n + 1; i++){
        temp = temp.next;
    }
    return temp.data;
}


Counting Sort using Map
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array A[] with N elements, your task is to sort it using counting sort algorithm.
Input
The first line of the input contains the number of test cases T. For each test case, the first line contains the number of elements N in the array A and the next line will contain the N elements (space separated) of A[].


Constraints:
1 <= T <= 12
1 <= N <= 100
1 <= A[] <= 100000
Output
For each test case in a new line, you need to print the sorted array using counting sort.
Example
Sample Input:
3
4
8 1 3 7
3
1 3 7
6
6 1 3 7 4 9

Sample Output:
1 3 8 7
1 3 7
1 3 4 6 7 9

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- > 0) {
            int n = sc.nextInt();
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            countingSort(arr);
            for (int i = 0; i < n; i++) {
                System.out.print(arr[i] + " ");
            }
            System.out.println();
        }
    }

    public static void countingSort(int[] arr){
        int n = arr.length;

        int max = arr[0];
        for(int i = 0; i  < n; i++){
            if(arr[i] > max){
                max = arr[i];
            }
        }

        //Creating couting map
        Map<Integer, Integer> count = new HashMap();
        for(int i = 0; i  < n; i++){
            int key = arr[i];
            count.put(key, count.getOrDefault(key, 0) + 1);
        }
        //temp output arr
        int[] output = new int[n];
        int j = 0;
        for(int i = 1; i <= max; i++){
            if(count.containsKey(i)){
                int freq = count.get(i);
                while(freq > 0){
                    output[j++] = i;
                    freq--;
                }
            }
        }
         // Copy the output array to the input array
        for (int i = 0; i < n; i++) {
            arr[i] = output[i];
        }
    }

}

Contest 12-03-23

Spiral rotation
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
There has been an attack on SHIELD. Nick Fury has given you the responsibility of protecting all the information but during the chaos he forgot to tell you how to login into the classified information. Just then a “secret code” appears on the screen.

Print the information in a 2D integer array of size (N x M) in a spiral form. That is, you need to print in the order followed for every iteration:
a. First row(left to right)
b. Last column(top to bottom)
c. Last row(right to left)
d. First column(bottom to top)
Mind that every element will be printed only once.
Input
The first line of input contains two integers N and M, the next N lines of input contains M space- separated integers each depicting the values of the matrix.

Constraints:-
2 <= N, M <= 500
1 <= Matrix[][] <= 1000000
Output
Print the matrix in spiral form as shown in the example.
Example
Sample Input:-
3 3
1 2 3
4 5 6
7 8 9

Sample Output:-
1 2 3 6 9 8 7 4 5

Sample Input:-
4 5
2 4 6 8 10
12 14 16 18 20
22 24 26 28 30
32 34 36 38 40

Sample Output:-
2 4 6 8 10 20 30 40 38 36 34 32 22 12 14 16 18 28 26 24

import java.io.*; 
import java.util.*; 

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();

        int matrix[][] = new int[n][m];
    
        for(int i = 0; i < n; i ++){
            for(int j = 0; j < m; j ++){
                matrix[i][j] = sc.nextInt(); 
                //System.out.print(matrix[i][j] + " " );
            }
        }
        sprial(matrix, n, m);
    }

    public static void sprial(int[][] matrix, int n, int m){

        int top = 0;
        int bottom = n - 1;
        int left = 0;
        int right = m - 1;
        int dir = 0;
        while (top <= bottom && left <= right) {
            if (dir == 0) { // print top row
                for (int i = left; i <= right; i++) {
                    System.out.print(matrix[top][i] + " ");
                }
                top++;
            } else if (dir == 1) { // print right column
                for (int i = top; i <= bottom; i++) {
                    System.out.print(matrix[i][right] + " ");
                }
                right--;
            } else if (dir == 2) { // print bottom row
                for (int i = right; i >= left; i--) {
                    System.out.print(matrix[bottom][i] + " ");
                }
                bottom--;
            } else if (dir == 3) { // print left column
                for (int i = bottom; i >= top; i--) {
                    System.out.print(matrix[i][left] + " ");
                }
                left++;
            }
            dir = (dir + 1) % 4; // change direction
        }
    }
}


Contest 12-02-23
Subarray with given sum
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an unsorted array A of size N of non-negative integers, find a continuous sub-array which adds to a given number S.
Input
Each test case consists of two lines. The first line of each test case is N and S, where N is the size of the array and S is the sum. The second line of each test case contains N space-separated integers denoting the array elements.

Constraints:-
1 ≤ N ≤ 105
1 ≤ Ai ≤ 105
Output
Print the starting and ending positions (1 indexing) of first such occurring subarray from the left if sum equals to subarray, else print -1.
Example
Sample Input
5 12
1 2 3 7 5

Sample Output
2 4

Explanation:
subarray starting from index 2 and ending at index 4 => {2 , 3 , 7}
sum = 2 + 3 + 7 = 12

Sample Input
10 15
1 2 3 4 5 6 7 8 9 10

Sample Output
1 5

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void findSubarray(int[] arr, int targetSum) {
        int start = 0, end = 0, currentSum = 0;
        
        while (end < arr.length) {
            if (currentSum + arr[end] <= targetSum) {
                currentSum += arr[end];
                end++;
            } else {
                currentSum -= arr[start];
                start++;
            }
            
            if (currentSum == targetSum) {
                System.out.println((start+1) + " " + (end));
                return;
            }
        }
        
        System.out.println(-1);
    }
    public static void main (String[] args) {
        // Your code here
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int targetSum = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        
        findSubarray(arr, targetSum);
    
    }
}

Contest 05-02-23
Alternate Matrix Addition
medium
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given a chessboard of size N x N, where the top left square is black. Each square contains a value. Find the sum of the values of all black squares and all white squares.

Remember that in a chessboard black and white squares are alternate.
Input
The first line of input will be the N size of the matrix. Then next N lines will consist of elements of the matrix. Each row will contain N elements since it is a square matrix.

Constraints:-
1 ≤ N ≤ 800
1 ≤ Matrix[i][j] ≤ 100000
Output
Print two lines, the first line containing the sum of black squares and the second line containing the sum of white squares.
Example
Input 1:
3
1 2 3
4 5 6
7 8 9

Output 1:
25
20

Sample Input 2:
4
1 2 3 4
6 8 9 10
11 12 13 14
15 16 17 18

Sample Output 2:
80
79

Explanation 1
The black square contains 1, 3, 5, 7, 9; sum = 25
The white square contains 2, 4, 6, 8; sum = 20

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
       Scanner sc = new Scanner (System.in);
       int n = sc.nextInt();
       int blackSum = 0 , whiteSum = 0;

       for(int i = 0; i < n; i++){
           for(int j = 0; j< n; j++){
               int value = sc.nextInt();
               if((i + j) % 2 == 0){
                   blackSum += value;
               }else{
                   whiteSum += value;
               }
           }
       }
       System.out.println(blackSum);
       System.out.println(whiteSum);
    }
}

Max XOR
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array Arr of non- negative integers of size N. The task is to find the maximum possible xor between two numbers present in the array.
Input
First line of input contains integer N (length of array). Next line contains N space separated integers which are numbers of array.

Constraints
2 <= N <= 100000
1 <= Arr[i] <= 10^9
Output
Print the the maximum possible xor between two numbers present in the array.
Example
Sample Input
6
25 10 2 8 5 3

Sample Output
28

Explanation
5^25=28

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        // Your code here
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++){
            arr[i] = sc.nextInt();
        }
        System.out.println(maxXor(arr));
    }
    public static int maxXor(int[] arr){
        int max = 0;
        int mask = 0;
        HashSet<Integer> set = new HashSet<>();
        for(int i = 31; i >= 0; i-- ){
            mask = mask |= (1<< i);
            //int set = max | (1 << i);
            set.clear();
            for(int j : arr){
                set.add(j & mask);
            }
            int temp = max | (1 << i);
            for(int pre : set){
                if(set.contains(temp ^ pre)){
                    max = temp;
                    break;
                }
            }
            // for(int j : arr){
            //     if((j & mask) == set){
            //         max = set;
            //         break;
            //     }
            // }
        }
        return max;
    }

}

Separating Negative and Positive numbers
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Separate an array of positive and negative integers while maintaining the relative order of the items using merge sort. All positive numbers should come after negative ones, with the relative order remaining the same.
Input
The first line of input will be n, which represents the array's length, followed by the n array items in the second line.

Constraints:
0< n <=100000
1<= arr[i] <= 100000
Output
The result should be an array with negative numbers separated at the front and the relative order of the elements preserved.
Example
Sample Input:
6
-1 1 2 -4 -6 5

Output:
-1 -4 -6 1 2 5

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n; i++){
            arr[i] = sc.nextInt();
        }
        int[] sortedArr = mergSort(arr, 0, n -1);
        for(int num : sortedArr){
            System.out.print(num + " ");
        }
    }

    public static int[] mergSort(int[] arr, int left, int right){
        if(left < right){
            int mid = (left + right) / 2;
            mergSort(arr, left, mid );
            mergSort(arr, mid + 1, right);
            return merge(arr, left, mid, right );
        }
        return arr;
    }
    public static int[] merge(int[] arr,int left, int mid, int right){
        int n1 = mid - left + 1;
        int n2 = right - mid;
        int[] L = new int[n1];
        int[] R = new int [n2];

        for(int i = 0; i < n1; i++){
            L[i] = arr[left + i ];
        }
        for(int  j = 0; j < n2; j ++){
            R[j] = arr[mid + 1 + j];
        }

        int i = 0, j = 0, k = left;
        while(i < n1 && L[i] < 0){
            arr[k++] = L[i++];
        }

        while(j < n2 && R[j] < 0){
            arr[k++] = R[j++];
        }

        while(i < n1){
            arr[k++] = L[i++];
        }

        while(j < n2){
            arr[k ++] = R[j++];
        }
        return arr;
    }
}


Help Samar with Chopsticks (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Actually, a pair of chopsticks need not have two sticks that are the same length. You can eat with a pair of sticks as long as the length difference is no greater than D. Samar is appointed as a head chef of a restaurant. He is provided with N sticks, the ithstick of which is L[i] units long. More than one set of chopsticks cannot share the same stick. Assist him in matching the sticks to create as many functional pairs of chopsticks as possible.
Input
The first line contains two space-separated integers N and D. The next N lines contain one integer each, the ithline giving the value of L[i].

Constraints
1 ≤ N ≤ 10,000 (105)
0 ≤ D ≤ 1,000,000,000 (109)
1 ≤ L[i] ≤ 1,000,000,000 (109) for all integers i from 1 to N
Output
Output a single line containing the maximum number of pairs of chopsticks Samar can form.
Example
Sample Input :
5 2
1
3
3
9
4
Sample Output :
2
Explanation :
The 5 sticks have lengths 1, 3, 3, 9, and 4 respectively. The maximum allowed difference in the lengths of two sticks forming a pair is at most 2. It is clear that the 4th stick (length 9) cannot be used with any other stick. The remaining 4 sticks can be paired as (1st and 3rd) and (2nd and 5th) to form 2 pairs of usable chopsticks.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        int d = sc.nextInt();

        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(int i = 0;i<n;i++){
            pq.add(sc.nextInt());
        }
        int ans = 0, first = 0, second = 0;
        while(pq.size() > 1){
            first = pq.poll();
            if(pq.peek() - first <= d){
                pq.poll();
                ans++;
            }
        }
        System.out.println(ans);
    }
}

Contest 29-01-23

Roman Number to Integer
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given a string in roman number format. Your task is to convert it to integer.

Roman numerals are based on below symbols.

SYMBOL VALUE
I 1
IV 4
V 5
IX 9
X 10
XL 40
L 50
XC 90
C 100
CD 400
D 500
CM 900
M 1000
A number in Roman Numerals is a string of these symbols written in descending order(e.g. M’s first, followed by D’s, etc.). However, in a few specific cases, to avoid four characters being repeated in succession (such as IIII or XXXX), a subtractive notation is often used as follows:

I placed before V or X indicates one less, so four is IV (one less than 5) and 9 is IX (one less than 10).
X placed before L or C indicates ten less, so forty is XL (10 less than 50) and 90 is XC (ten less than a hundred).
C placed before D or M indicates a hundred less, so four hundred is CD (a hundred less than five hundred) and nine hundred is CM (a hundred less than a thousand).
Input
The first line of each test case contains the no of test cases T. Then T test cases follow. Each test case contains a string s denoting the roman number.

Constraints:
1 <= T <=1000
1 <= roman no range <= 4000
Output
For each test case in a new line print the integer representation of roman number s.
Example
Sample Input:
2
V
III

Sample Output:
5
3

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
       int t = sc.nextInt();
       for(int i = 0; i < t; i++){
            String str = sc.next();
            System.out.println(romanToInt(str));
       }
    }

    public static int romanToInt(String s){
        if(s == null || s.length() == 0){
            return 0;
        }
        int sum = 0;
        char ch = 0;
        char pre = 0;
        for(int i = 0, len = s.length(); i < len; i++){
            pre = ch ;
            ch = s.charAt(i);
            switch(ch){
                case 'I':
                    sum ++;
                    break;
                case 'V':
                    if(pre == 'I'){
                        sum += 3;
                    }else{
                        sum += 5;
                    }
                    break;
                case 'X':
                    if(pre == 'I'){
                        sum += 8;
                    }else{
                        sum += 10;
                    }
                    break;
                case 'L':
                    if(pre=='I'){
                        sum += 48;
                    }else if(pre == 'V'){
                        sum += 40;
                    }else if(pre == 'X'){
                        sum += 30;
                    }else{
                        sum += 50;
                    }
                    break;
                case 'C':
                    if(pre == 'I' ){
                        sum += 98;
                    }else if(pre == 'V'){
                        sum += 90;
                    }else if(pre == 'X'){
                        sum += 80;
                    }else{
                        sum += 100;
                    }
                    break;
                case 'D':
                    if(pre == 'I'){
                        sum += 498;
                    }else if(pre == 'V'){
                        sum += 490;
                    }else if(pre == 'X'){
                        sum += 480;
                    }else if (pre == 'C'){
                        sum += 300;
                    }else {
                        sum += 500;
                    }
                    break;
                case 'M':
                    if(pre == 'I'){
                        sum += 998;
                    }else if(pre == 'V'){
                        sum += 990;
                    }else if(pre == 'X'){
                        sum += 980;
                    }else if(pre == 'C'){
                        sum += 800;
                    }else {
                        sum += 1000;
                    }
                    break;
            }
        }
        return sum;
    }
}

Duplicates at a distance k
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array of N integers that may contain duplicate elements and an integer K, find if there exists a pair of integers (i, j) such that i < j and arr[i]=arr[j] and i and j are exactly k distance apart i.e ( j - i ) = k.
Input
The first line of input contains two integers N and K, next line contains N space-separated integers.

Constraints:-
1 < = N < = 105
1 < = K < = N
1 < = Arr[i] < = 109
Output
Print 1 if there exist elements else print 0.
Example
Sample Input:
4 3
1 2 2 1

Sample Output:
1

Explanation:-
Pair at index 1, 4 is the required answer so output=1

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
       int n = sc.nextInt();
       int k = sc.nextInt();
       int[] arr = new int[n];
       for(int i = 0 ;i < n; i++){
           arr[i] = sc.nextInt();
       }

       for(int i = 0; i < n - k; i++ ){
           if(arr[i] == arr[i + k]){
               System.out.println(1);
               return ;
           }
       }
       System.out.println(0);
       //(findPair1(arr, n, k);
    }

    public static void findPair(int[] arr, int n, int k){
        //HashMap <Integer, Integer> hash = new HashMap<Integer, Integer>();

        // for(int i = 0; i < n ; i++){
        //     if(hash.containsKey(arr[i])){
        //         if(i - hash.get(arr[i]) == k){
        //             System.out.println(1);
        //             return;
        //         }
        //     }
        //     hash.put(arr[i], i);
        // }
        // System.out.println(0);
    }
    
}


Ropes (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
There are n ropes, you need to cut k pieces of the same length from them. Find the maximum length of the piece you can get.
Input
The first line of the input contains two integers n and k.
Next n lines contain one number each, the length of the rope ai.

Constraints
1 ≤ n, k ≤ 10000
1 ≤ ai ≤ 107
Output
Print one real number maximum length of the piece you can get. Print the result up to 6 decimal places.
Example
Sample Input
4 11
802
743
457
539

Sample Output
200.500000

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n =sc.nextInt();
        int k = sc.nextInt() ;
        double[] arr = new double[n];
        for(int i = 0; i < n; i++){
            arr[i] = sc.nextDouble();
        }
        double l = 0, r = 1e9;
        while(r - l > 0.000001 ){
            double mid = l + (r - l)/ 2;
            int pieces = 0;
            for(int i = 0; i < n; i ++){
                pieces += (arr[i] / mid);
            }
            if(pieces >= k){
                l = mid;
            }else{
                r = mid;
            }

        }
        System.out.printf("%.6f", l);
    }
}


Contest 22-01-23 

Shopping
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Toros went to the supermarket to buy K items. There were a total of N items. Each item had a distinct price Pi. He is cost-effective, so he would buy the K cheapest item. But he knows that the more cheaper an item is, the more is the chances that it can be defective. So he planned to ignore 2 cheapest items and buy K from the remaining ones.
Find the total cost of all items that he would buy.
Input
The first line contains two integers N and K, denoting the total number of items in the supermarket and the number of items Toros is going to buy.
The second line contains N distinct integers Pi , denoting the prices of the items

Constraints:
1 <= N <= 100000
1 <= K <= N - 2
1 <= Pi <= 1000000
Output
Print a single integer denoting the total cost of items Toros would buy.
Example
Sample Input:
5 2
4 1 2 3 5

Sample Output:
7

Explanation:
Toros will ignore items with price 1 and 2 and would buy items with price 4 and 3.

Sample Input:
10 8
99 56 50 93 47 36 65 25 87 16

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(int i = 0; i < n; i++){
            pq.add(sc.nextInt());
        }
        long sum = 0;
        pq.poll(); pq.poll();
        for(int i = 0; i < k; i ++){
            sum += pq.poll();
        }
        System.out.println(sum);
    }
}

Moving right (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array of heights of N buildings in a row. You can start from any building and jump to the adjacent right building till the height of the building to the right is less than or equal to the height of your current building. Find the maximum number of jumps you can make.
Input
The first line of input contains a single integer N.
The second line of input contains N integers, denoting the array height.

Constraints:
1 <= N <= 105
1 <= height[i] <= 109
Output
Print the maximum number of jumps you can make.
Example
Sample Input:-
5
5 4 1 2 1

Sample Output:-
2

Explanation:
We start from building with height 5 then jump right to building with height 4 then again to building with height 1 making a total of 2 jumps.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];

        for(int i = 0; i < n ; i++){
            arr[i] = sc.nextInt();

        }
        int res = 0;
        int count = 0;
        for(int i = 0; i < n -1; i++){
            if(arr[i] > arr[i + 1]){
                count++;
            }else{
                if(res < count){
                    res = count;
                }
                count = 0;
            }
        }
        if(res < count){
            res = count;
        }

        System.out.print(res);
    }
}


Swapping Matrix (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given a 7 * 7 matrix of 48 zeroes and a single 1. In one move, you can swap any two adjacent rows or columns. Find the minimum number of moves required to bring the single 1 to the middle of the matrix.
Input
The input consists of 7 lines where each line contains 7 space-separated integers.

Constraints:
48 zeroes and a single one is present in the matrix.
Output
Print the minimum number of moves required to bring the single 1 to the middle of the matrix.
Example
Sample Input:
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 1 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0
0 0 0 0 0 0 0

Sample Output:
2

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
     Scanner sc = new Scanner(System.in);

     for(int i = 1; i <= 7; i++){
         for(int j = 1; j <= 7; j++){
             if(sc.nextInt() == 1){
                 System.out.println(Math.abs(i - 4) + Math.abs(j - 4));
                 return ;
             }
         }
     }   
    }
}


Contest 15-01-23 

Inversion of array
medium
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array of positive integers. The task is to find inversion count of array.

Inversion Count : For an array, inversion count indicates how far (or close) the array is from being sorted. If array is already sorted then inversion count is 0. If array is sorted in reverse order that inversion count is the maximum.
Formally, two elements a[i] and a[j] form an inversion if a[i] > a[j] and i < j.

Asked in Adobe, Amazon, Microsoft.
Input
The first line of each test case is N, the size of the array. The second line of each test case contains N elements.

Constraints:-
1 ≤ N ≤ 10^5
1 ≤ a[i] ≤ 10^5
Output
Print the inversion count of array.
Example
Sample Input:
5
2 4 1 3 5

Sample Output:
3

Explanation:
Testcase 1: The sequence 2, 4, 1, 3, 5 has three inversions (2, 1), (4, 1), (4, 3).

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {

    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        int arr[] = new int[n];

        for(int i = 0 ;i < n; i++){
            arr[i] = sc.nextInt();
        }

        System.out.println(mergeSortAndCount(arr, 0, arr.length - 1));
    }
    public static long  merge(int arr[], int l, int mid, int r){
        long inversionCount = 0;
        int n1 = mid - l + 1;
        int n2 = r - mid;
        int left[] = new int [n1];
        int right[] = new int[n2];
        
        for(int i = 0;i < n1; i++){
            left[i] = arr[l + i];
        }
        for(int i = 0; i < n2;i++){
            right[i] = arr[mid + i + 1];
        }

        int i = 0, j = 0, k = l;

        while(i < left.length && j < right.length){
   
            if(left[i] <= right[j])
                arr[k++] = left[i++];
            else{
                arr[k++] = right[j++];
                inversionCount += n1 - i;
            }
        }

        while(i < n1)
            arr[k++] = left[i++];
       
        while(j < n2)
            arr[k++] = right[j++];

        return inversionCount;
    }

    private static long mergeSortAndCount(int arr[], int l, int r){
        long inversionCount = 0;
        if(l < r){
            int mid= (l + r)/2;
            inversionCount += mergeSortAndCount(arr, l, mid);
            inversionCount += mergeSortAndCount(arr, mid + 1, r);
            inversionCount += merge(arr, l, mid, r);
        }
        return inversionCount;
    }
}

Lexographical Rotation (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array Arr of length N. Print the lexographically minimum rotation of the array Arr.
All the elements of the array are distinct.
Input
First line of input contains a single integer N.
Second line of input contains N integers denoting the array Arr.

Constraints:
1 <= N <= 100000
1 <= Arr[i] <= 1000000000
Output
Print the lexographically minimum rotation of the array Arr.
Example
Sample Input
5
2 3 1 4 10

Sample Output
1 4 10 2 3

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
         for(int i = 0; i < n; i++){
            arr[i] = sc.nextInt();
        }

        int minIndex = 0;
        for(int i = 0; i < n; i++){
            if(arr[i] < arr[minIndex]){
                //minIndex = i + 1;
                minIndex = i;
                //break;
            }
        }
        for(int i = minIndex; i < n; i++){
            System.out.print(arr[i] + " ");
        }
        for(int i = 0; i < minIndex;i++){
            System.out.print(arr[i] + " ");
        }
    }
}

Fast Search (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given an array a of n integers a1, a2,... , an. Your task is to response to the queries like : How many number's values are between l and r ?
Input
The first line of the input contains a single space separated integer n denoting the length of the array.
The second line of the input contains n space separated integers denoting an array a.
The third line of the input contains a single space separated integer k denoting the number of queries.
The following k lines contain a pair of integers l and r - query, described above.

Constraints
1 ≤ N ≤ 105
-109 ≤ a[i] ≤ 109
1 ≤ k ≤ 105
-109 ≤ l ≤ r ≤ 109
Output
The output must consist of k integers - responses for the queries.
Example
Sample Input
5
10 1 10 3 4
4
1 10
2 9
3 4
2 2
Sample Output
5 2 2 0

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i =0;i < n; i++){
            arr[i] = sc.nextInt();
        }
        Arrays.sort(arr);
        int k = sc.nextInt();
        while(k-- > 0 ){
            int x = sc.nextInt();
            int y = sc.nextInt();
            int val = countRange(arr, n, x,y);
            System.out.print(val + " ");
        }
    }
    static int lIndex(int arr[], int n, int x){
        int l = 0, h=n-1;
        while(l <= h){
            int mid = (l + h)/2;
            if(arr[mid] >= x){
                h= mid - 1;
            }else{
                l = mid + 1;
            }
        }
        return l;
    }
      static int rIndex(int arr[], int n, int y){
        int l = 0, h=n-1;
        while(l <= h){
            int mid = (l + h)/2;
            if(arr[mid] <= y){
                l= mid + 1;
            }else{
                h = mid - 1;
            }
        }
        return h;
    }
    static int countRange(int arr[], int n, int x, int y){
        int count = 0;
        count = rIndex(arr, n, y) - lIndex(arr,n,x) + 1;
        return count;
    }
}

Repeated substrings
medium
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given a string S, containing only letters { 'N', 'E', 'W', 'T', 'O'} like "NWTEONEW" or "NEWTON" your task is to print all the substring of size 10 which occur more than once in the given string.
Input
Input contains a single line containing the string S.

Constraints:-
10 < = |String| < = 10000
Output
Print all the sequences in lexicographical order separated by spaces, if their is no such substring exist print -1.
Example
Sample Input:-
NEWTONNEWTONNEWTON

Sample Output:-
EWTONNEWTO NEWTONNEWT WTONNEWTON

Sample Input:-
NETOWNEWOTTONTOONW

Sample Output:-
-1

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String s = sc.nextLine();
        int n = s.length();

        HashMap<String, Integer> map = new HashMap<>();
        for(int i = 0;i <= n - 10; i++){
            String substr = s.substring(i, i + 10);

            if(map.containsKey(substr)){
                map.put(substr, map.get(substr) + 1);
            }else{
                map.put(substr, 1);
            }
        }
        Set<String> result = new TreeSet<>();
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            if (entry.getValue() > 1) {
                result.add(entry.getKey());
            }
        }
        if(result.isEmpty()){
            System.out.println("-1");
        }else{
            for (String res : result) {
                System.out.print(res + " ");
            }
        }
    }
}





Contest 08-01-23

Easy - Peasy (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array of length N in which you can swap two elements if their sum is odd i.e for every i (1 to N) and j (1 to N) if (Arr[i] + Arr[j]) is odd then you can swap these elements.
What is the lexicographically smallest array you can obtain?
Input
First line of input contains a single integer N. Next line contains N space separated integers depicting the elements of the array.

Constraints:-
1 <= N <= 100000
1 <= Arr[i] <= 100000
Output
Print N space separated elements i. e the array which is the lexicographically smallest possible
Example
Sample Input:-
3
4 1 7

Sample Output:-
1 4 7

Explanation:-
Swap 1 and 2 as their sum 4 + 1 = 5 is odd

Sample Input:-
2
2 4

Sample Output:-
2 4 

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr =new int[n];

        for(int i = 0; i <n ; i++){
            arr[i] = sc.nextInt();
        }

        smallestArr(arr, n);
    }
    public static void smallestArr(int[] arr, int n){
        int odd = 0; int even = 0;
        for(int i = 0; i < n; i++){
            if(arr[i] % 2 == 1){
                odd++;
            }else{
                even++;
            }
        }
        if(odd > 0 && even > 0)
        Arrays.sort(arr);
        for(int i = 0; i < n; i++)
            System.out.print(arr[i] + " ");
            
        
    }
}

Implementing Merge Sort
easy
asked in interviews by 33 companies
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an unsorted array, your task is to sort the array using merge sort.
Input
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function implementMergeSort() that takes 3 arguments.
arr: input array
start: starting index which is 0
end: ending index of array

Constraints
1 <= T <= 100
1 <= N <= 106
0 <= Arr[i] <= 109

Sum of 'N' over all test cases does not exceed 106
Output
You need to return the sorted array. The driver code will print the array in sorted form.
Example
Sample Input:
2
3
3 1 2
3
4 5 6

Sample Output:
1 2 3
4 5 6

public static int[] implementMergeSort(int arr[], int start, int end)
    {
        // Your code here
       // You can have your own function where you will use 
      // start and end position for divide purpose  
      if(start < end){
        int mid  = start + (end - start) / 2;
        implementMergeSort(arr, start, mid);
        implementMergeSort(arr, mid + 1 , end);
        
        implementMergeArray(arr, start, mid, end);
      }
      return arr;
    }
  
  public static void implementMergeArray(int[] arr, int start, int mid, int end){
    int[] tempArr = new int[end - start + 1];
    int i = start;
    int j = mid + 1;
    int k = 0;

    while(i <= mid && j <= end){
      if(arr[i] < arr[j]){
        tempArr[k++] = arr[i++];
      }else{
        tempArr[k++] = arr[j++];
      }
    }

    while(i <= mid){
      tempArr[k++] = arr[i++];
    }
    while(j <= end ){
      tempArr[k++] = arr[j++];
    }
    int tempStart = start;
    for(int x = 0; x < tempArr.length; x++){
      arr[tempStart++] = tempArr[x];
    }
  }

Grid Magic (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given a square character grid of side length N (where N is odd). You have to find whether the given grid is magical or not. A grid is said to be magical if it contains the same character on each element in its diagonal. Moreover, all the elements that are not present on the diagonal have to have the same character (which is different than the one on the diagonal).
Input
The first line contains integer N.
Each of the next N lines contain N lowercase English latin characters.

Constraints:
3 <= N <= 500
N is odd.
Output
Print "YES" if the given grid is magical, else print "NO", without the quotes.
Example
Sample Input:
3
aba
bab
aba

Sample Output:
YES

Explaination:
All characters on its diagonal are the same.
All the characters other than the diagonal are same.
The characters on the diagonal and the rest of the grid do not match.
Thus, it is a magical grid.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        //sc.nextLine();
        //char[][] grid = new char[n][n];
        // for(int i = 0; i < n; i++){
        //     grid[i] = sc.nextLine().toCharArray();
        // }
        // System.out.println(isMagical(grid, n));

        Character[][] a = new  Character[n][n];
        HashMap<Character,Integer> ht = new HashMap<>();
        char temp =' ';
        String str = sc.nextLine();
        for(int i = 0; i < n; i++ ){
            str = sc.nextLine();
            for(int j = 0; j < n; j++){
                temp = str.charAt(j);
                ht.put(temp, ht.getOrDefault(temp, 0) + 1);
                a[i][j] = temp;
            }
        }
        if(ht.size() != 2){
            System.out.println("NO");
            return;
        }
        temp = a[0][0];
        if((ht.get(a[0][0]) != (2*n -1))){
            System.out.println("NO");
            return;
        }

        if(ht.get(a[0][1]) != (n*n - n - n +1)){
            System.out.println("NO");
            return;
        }
        System.out.println("YES");
    }

    // public static String isMagical(char[][] grid, int n){
    //     char digonalChar = grid[0][0];
    //     for(int i = 0 ; i < n; i++){
    //         if(grid[i][i] != digonalChar){
    //             return "NO";
    //         }
    //     }
    //     char nonDiagonalChar = grid[0][1];
    //     for(int i = 0; i< n; i++){
    //         for(int j = 0; j < n; j++){
    //             if(i != j && i != n-j-1 && grid[i][j] != nonDiagonalChar){
    //                 return "NO";
    //             }
    //         }
    //     }
    //     return "YES";
    // }
}



31-12-22 Contest

Minimum changes to make all substrings distinct
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given a string s, find the minimum number of changes required to it so that all substrings of the string become distinct.

Note: length of string is atmost 26.
Input
The first line contains an integer T, number of test cases. For each testcase there is only one line containing s atmost 26 characters.

1 <= T <= 100
1 <= |s| <= 26
Output
For each testcase in new line, print the minimum number of changes to the string.
Example
Sample Input:
3
aab
aebaecedabbee
ab

Sample Output:
1
8
0
Explanation:
Testcase 1: If we change one instance of 'a' to any character from 'c' to 'z', we get all distinct substrings.
Testcase 2: We need to change 2 a's, 2 b's and 4 e's to get distinct substrings.
Testcase 3: As no change is required hence 0.
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
       int n = sc.nextInt();
       for(int i = 0; i < n; i++){
           String str = sc.next();
           int changes = minChanges(str);
           System.out.println(changes);
       }
    }
    public static int minChanges(String s){
        int changes = 0;
        Map<Character, Integer> freq = new HashMap<>();
        for(char c : s.toCharArray()){
            freq.put(c, freq.getOrDefault(c,0) + 1);
        } 

        for(int f : freq.values()){
            if(f > 1){
                changes  += f - 1;
            }
        }
        return changes;
    }
}



Good array
easy
Problem Statement
A circular array is called good if, for every index i (0 to N-1), there exists an index j such that i != j and sum of all the numbers in the clockwise direction from i to j is equal to the sum of all numbers in the anticlockwise direction from i to j.
You are given an circular array of size N, Your task is to check whether the given array is good or not.
Input
First line of input contains a single integer N, the next line of input contains N space separated integes depicting values of the array.

Constraints:-
1 <= N <= 100000
1 <= Arr[i] <= 1000000
Output
Print "Yes" if array is good else print "No"
Example
Sample Input:-
4
1 4 1 4

Sample Output:-
Yes

Explanation:-
for index 1, j will be 3, then sum of elements from index 1 to 3 in clockwise direction will be 1 + 4 + 1 = 6 and the sum of elements from index 1 to 3 in anticlockwise direction will be 1 + 4 + 1 = 6.
For index 2, j will be 4
For index 3, j will be 1
For index 4, j will be 2

Sample Input:-
4
1 2 3 4

Sample Output:-
No

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static boolean check(int a[]){
        int n = a.length;
        if(n % 2 == 1){
            return false;
        }

        for(int i = 0 ; i < n/2; i++ ){
            if(a[i] != a[i + (n / 2)])
                return false;
        }
        return true;
    }
    public static void main (String[] args) {
        // Your code here
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i <  n; i++){
            arr[i] = sc.nextInt();
        }

        if(check(arr)){
            System.out.println("Yes");
        }else{
            System.out.println("No");
        }

    }
}


Row Index Identification (Contest)
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given a grid of having N*M elements. Find the index of the row (1- indexed) which has the maximum sum of elements.
Input
The first line of the input contains two integers N and M.
The next N lines each contains M space seperated integers.

Constraints:
1 <= N, M <= 103
1 <= Ai, j <= 109
Output
Print the index of the row (1- indexed) which has the maximum sum of elements.
Example
Sample Input:
3 4
3 4 2
5 1 7
2 8 1
2 3 3

Sample Output:
2

Explaination:
The row number 2 has sum = 5 + 1 + 7 = 13 which is the maximum amongst all rows.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args)throws IOException {
        //Scanner sc = new Scanner(System.in);
        BufferedReader sc= new BufferedReader(new InputStreamReader(System.in)); 
        String[] str = sc.readLine().split(" ");
        int n = Integer.parseInt(str[0]);
        int m = Integer.parseInt(str[1]);

        // int[][] grid = new int[n][m];
        long sum = 0, prefixSum = 0;
        int maxSum = 0;
        for(int i = 0; i < n; i++){
            sum = 0;
            str = sc.readLine().split(" ");
            for(int j = 0; j < m; j++){
                sum += Integer.parseInt(str[j]);
            }
            if(sum > prefixSum){
                maxSum = i + 1;
                prefixSum = sum;
            }
        }
        System.out.println(maxSum);

        // //prefix sum
        // int[] prefixSum =  new int[n];
        // prefixSum[0] = 0;
        // for(int i = 0; i < n; i++){
        //     prefixSum[i] = prefixSum[i - 1] + grid[i][0];
        //     for(int j = 1; j < m ;j++){
        //         prefixSum[i] += grid[i][j]; 
        //     }
        // }

        // int maxRow =0;
        // int maxSum = prefixSum[0];
        // for(int i = 1; i < n; i++){
        //     if(prefixSum[i] > maxSum){
        //         maxSum = prefixSum[i];
        //         maxRow = i + 1;
        //     }
            
        // }
        // for(int i = 0 ;i < n; i++){
        //     int sum = 0;
        //     for(int j = 0; j < m; j++){
        //         sum += grid[i][j];
        //     }
        //     if(sum > maxSum){
        //         maxSum = sum;
        //         maxRow= i + 1;
        //     }
        // }
        //System.out.println(maxSum);
    }
}


Array Frequency Paradigm (Contest)
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given an array A of size N. For each of the indices i (1 <= i <= N), find the the smallest index j such that i < j and the frequency of Ai is lesser than or equal to that of Aj in the array.
Input
The first line of the input contains a single integer N.
The second line of the input contains N space seperated integers.

Constraints:
1 <= N <= 105
1 <= Ai <= 105
Output
For each of the indices i (1 <= i <= N), print the the smallest index j such that i < j and the frequency of Ai is lesser than or equal to that of Aj in the array. If there is no such index j, print -1 for that particular index i.
Example
Sample Input:
7
1 2 3 3 3 1 1

Sample Output:
3 3 4 5 6 7 -1

Explaination:
For,
i = 1, j = 3
i = 2, j = 3
i = 3, j = 4
i = 4, j = 5
i = 5, j = 6
i = 6, j = 7
i = 7, no such j exists

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];

        HashMap<Integer,Integer> ht = new HashMap<>();
        for(int i = 0;i < n; i++){
            arr[i] = sc.nextInt();
            ht.put(arr[i], ht.getOrDefault(arr[i], 0) + 1);
        }

       // HashMap<Integer,Integer> count = new HashMap<>();
        for(int i = 0; i < n; i++){
            arr[i] = ht.get(arr[i]);
        }

        for(int i = 0; i < n; i++){
            int j = i + 1;
            for(j = i + 1 ; j < n; j ++){
                if(arr[i] <= arr[j]){
                    System.out.print(j+1 + " ");
                    break;
                }
            }
            if(j == n) System.out.print( "-1 ");
        }
    }
}

The high median paradigm (Contest) easy
You are given two integer N and M. You have to construct an array A having N non- negative integers such that the sum of its elements is M. As there are many such arrays possible, find the maximum median of all such possible arrays.
Input The first line of the input contains two integers N and M.
Constraints:
1 <= N, M <= 109
Output
Print the maximum median possible.
Example
Sample Input:
3 5
Sample Output:
2
Explanation:
One possible array: [1, 2, 2]

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static int maxMedian(int n, int m){
        // if(n % 2 == 0){
        //     return m / n + 1;
        // }else{
        //     return m / n;
        // }
        if(n == 1){
            return m;
        } else{
            int medianPos = (int)Math.ceil((double)(n) / (2.0));
            medianPos --;
            int median = m / (n - medianPos);
            return median;
        }

    }
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        System.out.println(maxMedian(n,m));
        //int arr[] = new int[n];
        // for(int i = 0; i < n; i++){
        //     arr[i] = sc.nextInt();
        // }

        
    }
}


Top K Players Contest 30-10-22
easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
The Newton City is going to participate in a Basket Ball tournament. You have been made the coordinator for the final team selection committee.
Lot of applications have been received and you are given with a two integer arrays. First array, height[], stores the height of the player while the second array, basketsScored[], has the number of Baskets scored for each player.
To find the top K players, you need to choose players according to their heights, that means greater the height, more suitable is the player. If height of two players is same then consider the player with greater number of baskets.
Print the heights and the baskets of the top K players.
Input
First line of the input takes the number of test cases, T. Further, for each test case, first line contains two space separated integers, N and K. Next two lines contains N space separated integers denoting the height of the players and basketsScored.

Constraints:
1 <= N <= 10^6
1 <= K <= N
1 <= height[i] <= 10^6
0 <= basketsScored[i] <= 10^6
Output
For each test case, print the K players on next lines and in each line print the value of height and basketsScored with space separation.
Example
Input:
5 3
1 3 3 3 5
1 2 3 1 2

Output:
5 2
3 3
3 2

Explanation: The top 3 players will be the one with greater heights, and the players with larger no. of baskets in case of same heights.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Pair{
    int x;
    int y;
    Pair(int x, int y){
        this.x = x;
        this.y = y;
    }
}
class Main {
    public static void main (String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str = br.readLine().split(" ");
        int n = Integer.parseInt(str[0]);
        int k = Integer.parseInt(str[1]);

        Pair[] arr = new Pair[n];
        str = br.readLine().split(" ");
        for(int i = 0 ; i < n; i++){
            arr[i] = new Pair(Integer.parseInt(str[i]),0);
            //System.out.print(arr[i].x + " ");
        }
             //System.out.println();
        str = br.readLine().split(" ");
        for(int i = 0 ; i < n; i++){
            arr[i].y = Integer.parseInt(str[i]);
             //System.out.print(arr[i].y + " ");
        }
        //System.out.println();
        Arrays.sort(arr, new Comparator<Pair>(){
            @Override
            public int compare(Pair p1, Pair p2){
                if(p1.x < p2.x){
                   // System.out.print("if me hai " + p1.x + " "+ p2.x);
                    return 1;
                }else if(p1.x == p2.x){
                    
                    if(p2.y > p1.y){
                        //System.out.println("else ke if me hai x == " + p1.x + " "+ p2.x);
                        //System.out.println("else ke if ke if me hai y == "  + p2.y + " "+ p1.y);
                        return 1;
                    }
                }
                return -1;
            }
        });
        for(int i = 0; i < k; i++){
            System.out.println(arr[i].x + " "+ arr[i].y);
        }
    }
}

Weekend Contest - 03/07/2022 -
K- Pairs (Contest)
Problem Statement
GIven an array A of size N and an integer K, find and print the number of pairs of indices i, j (1 <= i < j <= N) such that Ai * Aj <= K. Print the number of pairs of indices i, j (1 <= i < j <= N) such that Ai * Aj <= K.
Sample Input:
7 20
5 7 2 3 2 9 1
Sample Output : 5
Explaination: The following pairs of indices satisfy the condition (1-based indexing)
(1, 2) -> 5 * 7 = 35
(1, 6) -> 5 * 9 = 45
(2, 4) -> 7 * 3 = 21
(2, 6) -> 7 * 9 = 63
(4, 6) -> 3 * 9 = 27
All these products are greater than K (= 20).
There are no more pairs of indices that satisfy the above condition

Margin(Contest)
Given an array P of N integers P[1],. P[N] and other integer K. A margin is a non- negative integer L such that it is possible to choose N integers x1,. , xN such that for all i, 1 ≤ i ≤ N, the interval [xi, xi + L] contains at least K elements of array P and also contains P[i]. Compute the minimum possible margin.
Print one line with one integer, the minimum possible margin.
Example
Sample Input
5 3
1 -2 10 5 4
Sample output  6
Explanation: [-1, -2, 4, 0, 0] are n chosen integers






Distributing money (Functional Problem)
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Mahesh has won some money K from a lottery, he wants to distribute the money among his three sisters. His sisters already have some money with them. Let's say they have x, y, z amount of money. Now mahesh wants to distribute his money such that all the sisters have the same amount of total money left with them. Your task is to check if it is possible to distribute the money as Mahesh wants.
Input
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function distributingMoney() that takes the integers x, y, z, and K as parameters.

Constraints:-
0 <= x, y, z, K <= 10^7
Output
Return 1 if possible else return 0.
Example
Sample Input:-
1 2 3 3

Sample Output:-
1

Explanation:-
initial :- 1 2 3
Final :- 3 3 3

Sample Input:-
1 2 3 4

Sample Output:-
0


Problem Statement
There is a charity which has N people. Penny wants to donate some of her clothes to the charity in such a way that all people receive equal clothes and each individual receives more than 1. If she has M clothes with her what is the maximum number of clothes one individual can get?
Input
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function Charity() that takes integers N, and M as arguments.

Constraints:-
1 <= M, N <= 1000
Output
Return the maximum number of clothes one individual can get if it is impossible to distribute clothes return -1.
Example
Sample Input
6 20

Sample Output
3

Sample Input
8 5

Sample Output
-1



Problem Statement
There is a rule in ludo that a token can only be unlocked when either a 1 or 6 shown in the die. Given the die number N, Your task is to check whether the token can be unlocked or not.
Input
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function ludo() that takes integers N as argument.

Constraints:-
1 <= N <= 6
Output
Return 1 if the token can be unlocked else return 0.
Example
Sample Input:-
1

Sample Output:-
1

Sample Input:-
2



Problem Statement
A number is called Silly if it can be represented as the sum of the square of consecutive natural numbers starting from 1.
For a given number N, find the closest silly number.
Input
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function SillyNumber() that takes integer N as argument.

Constraints:-
1 <= N <= 100000
Output
Return the closest Silly number.

Note:- If more than one answer exists return the minimum one.
Example
Sample Input:-
18

Sample Output:-
14

Explanation:-
1*1 + 2*2 + 3*3 = 14

Sample Input:-
2

Sample Output:-
1

Sample Output:-
0


24-12-2022

Sort it (Contest) easy
Problem Statement
Given an array of N integers containing only 0 or 1. You can do following operations on the array:
    swap elements at two indices
    choose one index and change its value from 0 to 1 or vice- versa.
You have to do minimum number of above operations such that the final array is non-decreasing.
Input
First line of input contains a single integer N.
Second line of input contains N space separated integers denoting the array.

Constraints:
1 <= N <= 100000
elements of the array are 0 or 1.
Output
Minimum number of moves required such that the final array is non- decreasing.
Example
Sample Input 1
5
1 1 0 0 1

Sample Output 1
2

Explanation:
Swap indices (1, 3)
Swap indices (2, 4)

Sample Input 2
5
0 0 1 1 1

Sample Output 2
0

Sample Input 3
5
0 1 0 1 1

Sample Output 3
1

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];

        for(int i=0; i<n; i++){
          arr[i] =sc.nextInt();
        }
        int zero = 0;
        for(int i=0; i<n; i++){
            if(arr[i] == 0){
                zero ++;
            }            
        }
        int res =0;
        for(int i=0; i<zero; i++){
            if(arr[i] ==1){
                res++;
            }
        }
        System.out.println(res);
    }
  
}
