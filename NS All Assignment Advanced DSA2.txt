https://leetcode.com/discuss/interview-question/352743/Google-or-Onsite-or-Guaranteed-Binary-Search-Numbers
https://leetcode.com/playground/aEyByqNK

https://www.youtube.com/@SimpleSnippets/videos

https://practice.geeksforgeeks.org/courses/competitive-programming-live?utm_source=gfg&utm_medium=Submenu&utm_campaign=courses-submenu

Complexity Learning good videos
https://www.youtube.com/@abdul_bari/videos

dinesh varyani -- yuotube best couse dsa java **********
https://www.youtube.com/c/SmartProgramming

Maximum Product Subarray | LeetCode 152  hindil

MOck Question 
https://leetcode.com/problems/permutations/discuss/2773139/Permutations-Java-Solution-oror-2-Approaches
https://leetcode.com/problems/edit-distance/discuss/?currentPage=1&orderBy=hot&query=

Mock Dsa 5 
https://www.geeksforgeeks.org/compute-ncr-p-set-2-lucas-theorem/
Geek4geek - Given two integers n and r, find nCr. Since the answer may be very large, calculate the answer modulo 109+7.
static int nCr(int n, int r)
    {
        int mod = 1000000007;
        if(r > n){
            return 0;
        }else if(r == n){
            return 1;
        }
        int [][] dp = new int [n + 1][r + 1 ];
        
        for(int i = 0 ;i < n + 1 ; i++){
            for(int j = 0 ;j < r + 1 ; j++){
                if(i == j || j == 0 || i == 0){
                    dp[i][j] = 1;
                }else{
                  dp[i][j] = (dp[i - 1][j] + dp[i - 1][j - 1]) % mod; 
                }
            }
        }
        
 //       int ans = (fact(n) / fact(r))* fact (n - r);
        return dp[n][r];
    }



Very Imp to view again https://leetcode.com/problems/add-binary/
https://leetcode.com/problems/add-binary/discuss/1679423/Well-Detailed-Explaination-Java-C%2B%2B-Python-oror-Easy-for-mind-to-Accept-it

Dsa5 Medium Fail
2. https://leetcode.com/problems/prime-number-of-set-bits-in-binary-representation/

1. https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/2615698/Easy-Solution-using-Recursion-oror-Backtracking-oror-HashMap
public void backtrack(String s , int idx , HashMap<Character,String> map , StringBuilder sb , List<String> ans){
    if(idx==s.length()){ // for exmaple for "23" has length 2 to jaise hi 2 index complete ho jayega waise hi waise hi hm return kr jayenge.
        ans.add(sb.toString());
        return;
    }
    String str = map.get(s.charAt(idx)); // for eg for "23" has two index indx[0] will give the value "abc" which we store in str.
    for(int i=0;i<str.length();i++){ // then we run this loop for string "abc" 
        sb.append(str.charAt(i)); // we add every char of "abc" in string builder for i=0 we add "a" in sb.
        backtrack(s,idx+1,map,sb,ans); // we run this funtion we have to check every other possibilities for "a". for eg -> "ad","ae" and etc.
        sb.deleteCharAt(sb.length()-1); // when we got first ans ("ad") then we remove d form "ad" becoz we also have to check all other possibilities of a (e.g - "ae","af" etc).
    }
}
public List<String> letterCombinations(String digits) {
    ArrayList<String> list = new ArrayList<>();
    if(digits.length()==0) return list;
    HashMap<Character,String> map = new HashMap<>();
    map.put('2',"abc");
    map.put('3',"def");
    map.put('4',"ghi");
    map.put('5',"jkl");
    map.put('6',"mno");
    map.put('7',"pqrs");
    map.put('8',"tuv");
    map.put('9',"wxyz");
    backtrack(digits,0,map,new StringBuilder(),list);
    return list;
}


Mock 4 hard
Minimum Cost To Connect All Cities
import java.io.*;
import java.util.*;

public class Main {
  static class Edge implements Comparable<Edge> {
    int v;
    int wt;

    Edge(int nbr, int wt) {
      this.v = nbr;
      this.wt = wt;
    }

    @Override
    public int compareTo(Edge o) {
      return this.wt - o.wt;
    }
  }

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
    for (int i = 0; i < vtces; i++) {
      graph.add(new ArrayList<>());
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph.get(v1).add(new Edge(v2, wt));
      graph.get(v2).add(new Edge(v1, wt));
    }

   public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int vtces = Integer.parseInt(br.readLine());
    ArrayList<ArrayList<Edge>> graph = new ArrayList<>();
    for (int i = 0; i < vtces; i++) {
      graph.add(new ArrayList<>());
    }

    int edges = Integer.parseInt(br.readLine());
    for (int i = 0; i < edges; i++) {
      String[] parts = br.readLine().split(" ");
      int v1 = Integer.parseInt(parts[0]);
      int v2 = Integer.parseInt(parts[1]);
      int wt = Integer.parseInt(parts[2]);
      graph.get(v1).add(new Edge(v2, wt));
      graph.get(v2).add(new Edge(v1, wt));
    }
	int src = 0;
    int ans = 0;
    PriorityQueue<Edge> queue = new PriorityQueue<>();
    queue.add(new Edge(src, 0));
    boolean[] visited = new boolean[vtces];
    while (queue.size() > 0) {
      Edge rem = queue.remove();

      if (visited[rem.v] != false) {
        continue;
      }
      visited[rem.v] = true;
      ans += rem.wt;

      for (Edge e : graph.get(rem.v)) {
        if (visited[e.v] == false) {
          queue.add(new Edge(e.v, e.wt));
        }
      }
    }

    System.out.println(ans);
  }

}

                                
                        

https://www.geeksforgeeks.org/largest-value-level-binary-tree-set-2-iterative-approach/

https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns
Important Link https://www.youtube.com/c/takeUforward/videos
Most Important Link NotAll but bhaotse hai NSAssigment 
1. https://github.com/agentmishra/NewtonSchool-Assignments-Stuff

2. https://github.com/AbhishekChauhan9036/

/*Selector game to studypratice
https://flukeout.github.io/
Ans 
01. plate
02. bento
03. #fancy
04. plate apple
05. #fancy pickle
06. .small
07. orange.small
08. bento orange.small
09. plate, bento
10. *
11. plate *
12. plate + apple
13. bento ~ pickle
14. plate > apple
15. orange:first-child
16. plate apple:only-child, plate pickle:only-child
17. .small:last-child
18. plate:nth-child(3)
19. bento:nth-last-child(3)
20. apple:first-of-type
21. plate:nth-of-type(even)
22. plate:nth-of-type(2n+3)
23. plate apple:only-of-type
24. orange:last-of-type, apple:last-of-type
25. bento:empty
26. apple:not(.small)
27. *[for]
28. plate[for]
29. bento[for="Vitaly"]
30. *[for^="Sa"]
31. *[for$="ato"]
32. bento[for*="obb"]
*/
/*

Flexbox Froggy- Answers
You win! Thanks to your mastery of flexbox, you were able to help all of the frogs to their lilypads. Just look how hoppy they are!
If you found this ribbeting, be sure to visit Grid Garden to learn about another powerful new feature of CSS layout. You can also find other coding games over at Codepip.
Want to keep learning while supporting Flexbox Froggy? Try out the topnotch web design and coding courses offered by Treehouse. And be sure to share Flexbox Froggy with your friends!

1)  justify-content: flex-end;
2)  justify-content: center;
3)  justify-content: space-around;
4)  justify-content: space-between;
5)  align-items: flex-end;
6)  align-items: center;
    justify-content: center;
7)  justify-content: space-around;
8)  flex-direction: row-reverse;
9)  flex-direction: column;
10) flex-direction: row-reverse;
    justify-content: flex-end;
11) flex-direction: column;
    justify-content: flex-end;
12) flex-direction: column-reverse;
    justify-content: space-between;
13) flex-direction: row-reverse;
    justify-content: center;   
    align-items: flex-end;
14) order: 1;
15) order: -3;
16) align-self: flex-end;
17) align-self: flex-end;
    order: 1;
18) flex-wrap: wrap;
19) flex-direction: column;
    flex-wrap: wrap;
20) flex-flow: column wrap;
21) align-content: flex-start;
22) align-content: flex-end;
23) flex-direction: column-reverse;
    align-content: center; 
24) flex-flow:column-reverse wrap-reverse;
    justify-content:center;
    align-content:space-between;
*/
React Sub App solution
https://github.com/A-n-i-e/Single-price-grid-component-solution
https://www.frontendmentor.io/solutions/single-price-grid-challenge-u51o6utW8u
https://github.com/colis123/single-price-grid-component

https://www.youtube.com/watch?v=qHJPwgUPwUE ...must watch

https://github.com/Saum112/GFGCodingQuestions
imp
https://practice.geeksforgeeks.org/contest/job-a-thon-exclusive-hiring-challenge-for-amazon-alexa/instructions/

https://www.youtube.com/watch?v=HgCGys024WA --- to becheck first

Mock question asked 22822
https://www.geeksforgeeks.org/longest-alternating-subsequence/
https://leetcode.com/problems/unique-paths/discuss/2643765/JAVA-oror-beats-100-oror-oror-DP-oror-Recursive-greater-Bottom-up-greater-Top-down

Trie In/Post Class

Count prefix words
medium
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given a list of N words forming a dictionary.
You are also given a list of Q search words.
For each search word count the number of words in dictionary such that the search word is prefix of the dictionary word .
Input
First line contains N.
Next line contains N space separated strings.
Next line contains Q.
Next line contains Q space separated string s.
Constraints
1 <= N, Q<= 103
1 <= | word | <= 103
Output
Q space separated integers denoting the required answer.
Sample Input :
6
ab abc cab rat battle ba
3
rax ab ba
Output:
0 2 2
Explanation :
rax =>
ab => ab, abc
ba => battle, bat

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class TrieNode {
  // A map that stores the children of this node
  HashMap<Character, TrieNode> children;
  // A flag that indicates whether this node represents the end of a word
  boolean isEnd;
  // The number of words in the dictionary that have this node as a prefix
  int count;

  public TrieNode() {
    children = new HashMap<>();
    isEnd = false;
    count = 0;
  }
}

class Trie {
  // The root of the trie
  TrieNode root;

  public Trie() {
    root = new TrieNode();
  }

  // Inserts a word into the trie
  public void insert(String word) {
    TrieNode current = root;
    for (int i = 0; i < word.length(); i++) {
      char c = word.charAt(i);
      TrieNode child = current.children.get(c);
      if (child == null) {
        child = new TrieNode();
        current.children.put(c, child);
      }
      current = child;
      current.count++;
    }
    current.isEnd = true;
  }

  // Returns the number of words in the dictionary that have the given search word as a prefix
  public int countPrefix(String searchWord) {
    TrieNode current = root;
    for (int i = 0; i < searchWord.length(); i++) {
      char c = searchWord.charAt(i);
      TrieNode child = current.children.get(c);
      if (child == null) {
        return 0;
      }
      current = child;
    }
    return current.count;
  }
}
class Main {
    public static void main (String[] args) {
        Scanner scanner = new Scanner(System.in);

        // read the number of words in the dictionary
        int n = scanner.nextInt();
        scanner.nextLine(); // consume the remaining newline character

        // create a prefix tree
        Trie trie = new Trie();

        // insert the dictionary words into the prefix tree
        for (int i = 0; i < n; i++) {
            String word = scanner.next();
            //System.out.print(word + " ");
            trie.insert(word);
        }
        int q = scanner.nextInt();
        scanner.nextLine(); // consume the remaining newline character
        // for each search word, count the number of words in the dictionary that have the search word as a prefix
        for (int i = 0; i < q; i++) {
            String searchWord = scanner.next();
            //System.out.print(searchWord + " ");
            int count = trie.countPrefix(searchWord);
            System.out.print(count + " ");

        }
    }
}

// class TrieNode {
//     TrieNode[] children;
//     boolean isEndOfWord;

//     TrieNode() {
//         children = new TrieNode[26];
//         isEndOfWord = false;
//     }
// }

// class Trie {
//     TrieNode root;
//     Trie() {
//         root = new TrieNode();
//     }
//     // insert a word into the prefix tree
//     void insert(String word) {
//         TrieNode current = root;
//         for (int i = 0; i < word.length(); i++) {
//             char c = word.charAt(i);
//             if (!Character.isLowerCase(c)) {
//                 // the character is not a lowercase letter, so skip it
//                 continue;
//             }
//             int index = c - 'a';
//             if (current.children[index] == null) {
//                 current.children[index] = new TrieNode();
//             }
//             current = current.children[index];
//         }
//         current.isEndOfWord = true;
//     }

//     // count the number of words in the dictionary that have a search word as a prefix
//     int countWordsWithPrefix(String searchWord) {
//         TrieNode current = root;
//         for (int i = 0; i < searchWord.length(); i++) {
//             int index = searchWord.charAt(i) - 'a';
//             if (current.children[index] == null) {
//                 // the search word is not a prefix of any words in the dictionary
//                 return 0;
//             }
//             current = current.children[index];
//         }
//         // the search word is a prefix of some words in the dictionary, so return the number of child nodes of the last node in the search word
//         int count = 0;
//         for (int i = 0; i < 26; i++) {
//             if (current.children[i] != null && current.children[i].isEndOfWord) {
//                 count++;
//             }
//         }
//         return count;
//     }
// }


https://www.geeksforgeeks.org/check-if-the-given-string-of-words-can-be-formed-from-words-present-in-the-dictionary/

Priority Word easy
Consider the following simple auto complete feature. When you type some characters in the text bar, the engine automatically gives best matching options among it's database. Your job is simple. Given an incomplete search text, output the best search result.
Each entry in engine's database has a priority factor attached to it. We consider a result / search suggestion best if it has maximum weight and completes the given incomplete search query. For each query in the input, print the maximum weight of the string in the database, that completes the given incomplete search string. In case no such string exists, print -1.
Input First line contains two integers n and q, which represent number of database entries and number of search queries need to be completed. Next n lines contain a string s and an integer weight, which are the database entry and it's corresponding priority.
Next q lines follow, each line having a string t, which needs to be completed.
CONSTRAINTS
1 ≤ n, weight, len(s), len(t) ≤ 10^6
1 ≤ q ≤ 10^5
total length of all strings in database entries ≤ 10^6
total length of all query strings ≤ 10^6
Output q lines, each line containing the maximum possible weight of the match for given query, else -1, in case no valid result is obtained.
Example Sample Input
2 1
hackerearth 10
hackerrank 9
hacker
Sample Output 10
https://www.hackerearth.com/practice/data-structures/advanced-data-structures/trie-keyword-tree/tutorial/
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework


class TrieNode{
    TrieNode children[] = new TrieNode[26];
    boolean isEnd;
    int priority;
    int count;

    TrieNode(){
        for(int i = 0; i < 26; i++){
            children[i] = null;
        }
        isEnd = false;
        priority = 0;
        count = 0;
    }

    public void insert(TrieNode root, String word, int weight){
        for(int i = 0 ; i < word.length(); i++){
            int index = word.charAt(i) - 'a';

            if(root.children[index] == null){
                root.children[index] = new TrieNode();
            }

            root.children[index].count++;
            if(root.children[index].priority < weight){
                root.children[index].priority = weight;
            }
            root = root.children[index];
        }
        root.isEnd = true;
    }
}

class Main {

    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        TrieNode trie =  new TrieNode();
        int n = sc.nextInt();
        int q = sc.nextInt();

        while (n-- > 0){
            String value = sc.next();
            int weight = sc.nextInt();
            trie.insert(trie, value, weight);
        }

        while(q-- > 0){
            String value = sc.next();
           
            int max = 0;
            TrieNode currTrie = trie;

            for(char c : value.toCharArray()){
                 System.out.println(c - 'a');
                currTrie = currTrie.children[c - 'a'];
                if(currTrie == null){
                    break;
                }
            }
            System.out.println(currTrie != null ? currTrie.priority : -1); 
        }

        
    }
}



Index Pairs of a String easy 
https://docs.spiralgo.com/lc-1065.-index-pairs-of-a-string
https://xingxingpark.com/Leetcode-1065-Index-Pairs-of-a-String/
Given a string S and an array of strings A. Print an array of all index pairs [i, j] so that the substring S[i. j] is in A. Print the pairs [i, j] in sorted order (i.e., sort them by their first coordinate, and in case of tie sort them by their second coordinate).
Note: Follow 0-based indexing.
Input
First line contains an integer N.
Then N lines follow each containing a string.
The (N+2)th line contains the string S.
Constraints:
1 <= |S| <= 100
1 <= N <= 20
1 <= A[i]. length <= 50
S and A[i] consist of lowercase English letters.
All the strings of A are unique.
Outpu Print each pair i and j in a separate line in sorted order.
Sample Input 1:
2
aba
ab
ababa
Output
0 1
0 2
2 3
2 4
Explanation:Notice that matches can overlap, see "aba" is found in [0, 2] and [2, 4]. 
//One approach
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class TrieNode{
    TrieNode[] children = new TrieNode[26]; 
    boolean isEnd;   /*indicate whether there is a word*/
    public TrieNode(){
        for(int i = 0; i < 26; ++i)
            children[i] = null;

        isEnd =false;
        //children = new Trie[26];
    }
}
class Main {

    public static void indexPairs(String text, String[] words) {
        /*initializing tire and put all word from words into Trie.*/
        TrieNode trie = new TrieNode();
        for(String s:words){
            TrieNode cur = trie;
            for(char c: s.toCharArray()){
                if(cur.children[c-'a']== null){
                    cur.children[c-'a']= new TrieNode();
                }
                cur=cur.children[c-'a'];
            }
            cur.isEnd = true;       /*mark there is a word*/
        }
        
        /*if text is "ababa", check "ababa","baba","aba","ba","a" individually.*/
        int len = text.length();
        List<int[]> list = new ArrayList<>();
        for(int i = 0; i < len; i++){
            TrieNode cur = trie;
            char cc = text.charAt(i);
            int j = i;   /*j is our moving index*/
            
            while(cur.children[cc-'a']!=null){ 
                cur = cur.children[cc-'a'];
                if(cur.isEnd){   /*there is a word ending here, put into our list*/
                    list.add(new int[]{i,j});
                }
                j++;
                if(j == len){  /*reach the end of the text, we stop*/
                    break;
                }
                else{
                    cc = text.charAt(j);  
                }
            }
        }
        /*put all the pairs from list into array*/
        int size = list.size();
        int[][] res = new int[size][2];
        int i = 0;
        for(int[] r : list){
            res[i] = r;
            i++;
        }

        for(int j = 0 ; j < res.length; j++){
            for(int k = 0 ; k < res[0].length; k++){
                System.out.print(res[j][k] + " ");
            }
            System.out.println();
        }
        //return res;    
    }

    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        String[] words = new String[n];
        sc.nextLine();
        for (int i = 0; i < n; i++){
            words[i] = sc.nextLine();
        }
        String text = sc.nextLine();
 
        indexPairs(text, words) ;
    }
}



Operation on Trie medium
Given a Trie data structure, your task is to perform Q queries of insertion, deletion and searching.
Input User Task:Since this will be a functional problem, you don't have to take input. You just have to complete the functions:-
Insert() that takes the root and the string to be inserted as parameters.
delete() that takes the root and the string to be deleted as parameters.
Search() that takes the root and the string to find as parameters.
Constraints:
1 < = Q < = 1000
1 < = |String| < = 10
Input string will only contains lowercase english characters.
Custom Input:-
First line of input should contains the number of queries q, next q lines should be in the one of the format described below:-
1. 1 String ( For insertion)
2. 2 String ( For deletion)
3. 3 String (for searching)
Output Return 1 if input string is present else return 0 in the Search function.
Note:- In case if the string to be deleted is not present in the trie DO NOTHING
Sample Input:-
4
1 newton
3 newton
2 newton
3 newton
Sample Output:-
1
0

/*
    // Alphabet size (# of symbols) 
    static final int ALPHABET_SIZE = 26; 
  static class TrieNode 
    { 
        TrieNode[] children = new TrieNode[ALPHABET_SIZE]; 
       
        // isEndOfWord is true if the node represents 
        // end of a word 
        boolean isEndOfWord; 
          
        TrieNode(){ 
            isEndOfWord = false; 
            for (int i = 0; i < ALPHABET_SIZE; i++) 
                children[i] = null; 
        } 
    }; 
*/
static void insert(TrieNode root,String key) { 
  for(int i = 0; i < key.length(); i++){
    int index = key.charAt(i) - 'a';
    if(root.children[index] == null){
      root.children[index] = new TrieNode();
    }
    root = root.children[index];
  }
  root.isEndOfWord = true;
}    

private static boolean noChild(TrieNode root){
  for(int i = 0; i < root.children.length; ++i)
    if(root.children[i] != null)
        return false;
                
  return true;
}

//Deletion operation
private static TrieNode delete(TrieNode root, String key, int index){
  if(index == key.length()){
    root.isEndOfWord = false;

    if(noChild(root)) return null;
    
    return root;
  }
  int i = key.charAt(index) - 'a';
  root.children[i] = delete(root.children[i], key, index + 1);
  
  if(noChild(root) && root.isEndOfWord == false)
    return null;
  
  return root;
}

static void removeElement(TrieNode root,String key){       
  if(search(root, key) == 0)  return;  
root = delete(root, key, 0);
}

 
static int search(TrieNode root,String key) { 
  for(int i = 0; i < key.length(); i++){
    int index = key.charAt(i) - 'a';
    if(root.children[index] == null){
      return 0;
    }
    root = root.children[index];
  }
  if(root.isEndOfWord) return 1;
  else return 0;
}


Trie Implementation by Sir
class TrieNode {
    TrieNode[] children = new TrieNode[26];
    boolean isEnd;
    
    TrieNode() {
        for(int i = 0; i < 26; ++i)
            children[i] = null;
            
        isEnd = false;
    }
}

class Trie {
    TrieNode root;
    
    Trie() {
        root = new TrieNode();
    }
    
    public void insert(String word) {
        TrieNode temp = root;
        
        for(int i = 0; i < word.length(); ++i) {
            int ind = word.charAt(i) - 'a';
            
            if(temp.children[ind] == null)
                temp.children[ind] = new TrieNode();
                
            temp = temp.children[ind];
        }
        
        temp.isEnd = true;
    }
    
    public boolean search(String word) {
        TrieNode temp = root;
        
        for(int i = 0; i < word.length(); ++i) {
            int ind = word.charAt(i) - 'a';
            
            if(temp.children[ind] == null)
                return false;
                
            temp = temp.children[ind];
        }
        
        if(temp.isEnd) return true;
        else return false;
    }
    
    private boolean noChild(TrieNode node) {
        for(int i = 0; i < node.children.length; ++i)
            if(node.children[i] != null)
                return false;
                
        return true;
    }
    
    private TrieNode remove(TrieNode node, String word, int ind) {
        if(ind == word.length()) {
            node.isEnd = false;
            
            if(noChild(node))
                return null;
                
            return node;
        }
        
        int i = word.charAt(ind) - 'a';
        node.children[i] = remove(node.children[i], word, ind+1);
        
        if(noChild(node) && node.isEnd == false)
            return null;
        
        return node;
    }
    
    public void delete(String word) {
        if(!search(word))
            return;
            
        root = remove(root, word, 0);
    }
}

public class Main
{
	public static void main(String[] args) {
		String[] strings = {"the", "them", "these", "their", "and", "an", "apple", "ant"};
		
		Trie trie = new Trie();
		
		for(int i = 0; i < strings.length; ++i)
		    trie.insert(strings[i]);
		
// 		System.out.println("the -> " + (trie.search("the") ? "Present!!" : "Not Present!!"));
// 		System.out.println("then -> " + (trie.search("then") ? "Present!!" : "Not Present!!"));
// 		System.out.println("apple -> " + (trie.search("apple") ? "Present!!" : "Not Present!!"));
// 		System.out.println("app -> " + (trie.search("app") ? "Present!!" : "Not Present!!"));
		
		trie.delete("their");
		trie.delete("apple");
		
		System.out.println("then -> " + (trie.search("then") ? "Present!!" : "Not Present!!"));
		System.out.println("apple -> " + (trie.search("apple") ? "Present!!" : "Not Present!!"));
		System.out.println("app -> " + (trie.search("app") ? "Present!!" : "Not Present!!"));
	}
}


DSU - In Class / Post Class

Similar Strings medium 
https://leetcode.com/problems/similar-string-groups/discuss/2661156/Java-simple-solution-or-Using-union-find-or-16ms-Solution
Two Strings A and B are similar if we can swap two characters in A such that it becomes equal to B. Two equal strings are also similar. Given N strings in which each of them is an anagram to others in the list. We want to store the strings into multiple groups. Each string in a group must contain at least one similar string in the same group if its size is greater than 1. Your task is to find the minimum number of groups required.
Input The first line of input contains a single integer N. The next N line contains one single string each.
Constraints:- 1 <= N <= 300 1 <= |string| <= 300
Note:- String will contain only lowercase english letters
Output Print the minimum number of groups required.
Sample input:-
4
newton
tewnon
etwnon
notwen
Sample Output:-
2
Explanation:-
Group1 :- newton twenon etwon
Group 2:- notwen
Sample Input:-
2
omv
ovm
Sample Output:- 1
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    static int root[];
    static int groups;
    public static int findRoot(int x){
        if(root[x] == x)
            return x;
        return root[x] = findRoot(root[x]);
    }
    public static void union(int x, int y){
        int px = findRoot(x);
        int py = findRoot(y);
        if(px != py){
            root[py] = x;

            groups--;
        }
    }
    public static boolean isSimilar(String s, String t){
        int n = s.length();
        int count = 0;
        for(int i = 0;i < n; i++){
            if(s.charAt(i) != t.charAt(i))
                count++;
            if(count>2)
                return false;
        }
        return true;
    }
    public static int numSimilarGroups(String[] strs) {
        int n = strs.length;
        root = new int[n];
        groups = n;
        for(int i = 0;i < n; i++)
            root[i] = i;
        for(int i = 0; i < n; i++){
            for(int j = i + 1; j < n; j++){
                if(isSimilar(strs[i], strs[j])){
                    union(i, j);
                }
            }
        }
        return groups;
    }
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        String[] strArr = new String[n];
        sc.nextLine();
        for (int i = 0; i < n; i++){
            strArr[i] = sc.nextLine();
            //System.out.println(strArr[i] );
        }
        
        System.out.println(numSimilarGroups(strArr) );
    }
}
// another  solution
https://my.newtonschool.co/playground/code/kx8afpqzz213/
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        root = new int[n];
        for(int i=0; i<n; i++) root[i] = i;
        String[] arr = new String[n];
        for(int i=0; i<n; i++){
            arr[i] = sc.next();
            for(int j=0; j<i; j++){
                if(similar(arr[j],arr[i])) {
                    union(i,j);
                }
            }
        }
        int g = 0;
        for(int i=0; i<n; i++) if(root[i] == i) g++;
        System.out.print(g);

    }
    static int[] root;
    static boolean similar(String x, String y){
        // if(x==y) return true;
        int diff = 0;
        for(int i=0; i<x.length(); i++){
            if(x.charAt(i) != y.charAt(i)) diff++;
        }
        if(diff <= 2) return true;
        return false;
    }
    static int find(int x){
        if(root[x] == x) return x;
        return root[x] = find(root[x]);
    }
    static void union(int x, int y){
        int rx = find(x);
        int ry = find(y);
        if(rx != ry) root[rx] = ry;
    }

}

another solution
class Main {
    public static void main (String[] args) {
            Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
           String s[] = new String[n];
            for(int i=0; i<n; i++){
                 s[i] = sc.next();
            }  
            System.out.println( numSimilarGroups(s))     ;
    }
     public static int numSimilarGroups(String[] A) {
        if(A.length < 2) return A.length;
        int res = 0;
        for(int i=0;i<A.length;i++){
            if(A[i] == null) continue;
            String str = A[i];
            A[i] = null;
            res++;
            dfs(A,str);
        }
        return res;
    }
    public static void dfs(String[] arr,String str){
        for(int i=0;i<arr.length;i++){
            if(arr[i] == null) continue;
            if(helper(str,arr[i])){
                String s = arr[i];
                arr[i] = null;
                dfs(arr,s);
            }
        }
    }
    public static boolean helper(String s,String t){
        int res = 0, i = 0;
        while(res <= 2 && i < s.length()){

            if(s.charAt(i) != t.charAt(i)) res++;

            i++;
        }
        return res <= 2;
    }
}



GCD Sorting easy
Given an array Arr of N integers. You can perform the following operations any number of times :
- > Choose i and j (1 <= i, j <= N), and swap Arr[i] and Arr[j]. if GCD(Arr[i], Arr[j]) > 1
Your task is to check if the array can be sorted by performing the above operation.
Input The first line of input contains a single integer N. The next lien of input contains N space- separated integers depicting the value of Arr.
Constraints:-
1 <= N <= 10000
2 <= Arr[i] <= 100000
Output Print "Yes" if the array can be sorted else print "No".

Sample Input:-
3
7 35 5
Sample Output:- Yes
Sample Input:-
3
3 2 5
Sample Output:- No
https://leetcode.com/problems/gcd-sort-of-an-array/discuss/1825266/UNION-FIND-%2B-PRIME-FACTORIZATION
https://leetcode.com/problems/gcd-sort-of-an-array/discuss/1445161/Union-Find-%2B-Prime-Factorization
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
// Important concepts 
    
      // 1) if a can be swapped with b && a can be swapped with c => b can be swapped with c
      // eg -> a= 3 , b = 9 , c = 15;
      
      // 2) we have to make connected components with numbers having same gcd
    
    // IMPORTANT
    /*
     // 3) gcd of two numbers would be a number that divides both of them
          //  but finding gcd would be a n^2 task   
    
    // 4) so we will pair numbers with there prime factors 
      //  and prime factors start from 2 so the rule of gcd(a,b)>1 will also not be broken
    
    */

class Main {
    public static void main (String[] args) {
        Scanner sc= new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];

        for(int i = 0; i < n ;i++){
            arr[i] = sc.nextInt();
        }   

        boolean res = gcdSort(arr);
        if(res == true) 
            System.out.println("Yes");
        else 
            System.out.println("No");    
    }

    static int[] root;
    public static int findRoot(int u){
        if(root[u] == u) 
            return u;
            
        return root[u] = findRoot(root[u]);
    }

    public static void union(int u, int v){
        int pu = findRoot( u);
        int pv = findRoot( v);
        if(pu != pv){
            root[pv] = pu;
        }
    }

    public static boolean gcdSort(int[] nums) {
        root = new int[1000000];
        //initiliaze root/ parent
        for(int i = 0; i < 100000;i++){
            root[i] = i;
        }
        for(int e : nums){        
            int c = e;
            // finding prime factors
            for(int i = 2; i <= Math.sqrt(c); i++){
                if(c % i == 0){
                    //union
                    int p1 = findRoot(c);
                    int p2 = findRoot(i);
                    union(c , i);
                    // if(p1 != p2){
                    //     root[p2] = p1;
                    // }
                    // int p3 = findRoot(c/i);
                    // if(p1 != p3){
                    //     root[p3] = p1;
                    // }
                    union(c,c/i);
                }
            }
            
        }
        // cloning nums
        int[] temp = nums.clone();
        Arrays.sort(temp);
        for(int i=0;i<nums.length;i++){
            // if at a certain point the ith elements in sorted array and nums dont match 
            // => they don't belong to the same component the can not be swapped
            if(nums[i] != temp[i]){
                if(findRoot(nums[i])!= findRoot(temp[i])) return false;
            }
        }
        return true;
    }


    /*public static boolean gcdSort1(int[] nums) {
        for(int x: nums) {
            int y = x;
            for(int p=2; UF[y]==0 && p*p<=y; ++p) {
                if (y % p == 0) {
                    union(x, p);
                    while(y % p == 0) y /= p;
                }
            }
            if (y!=1) union(x, y);
        }
        int[] copy = nums.clone();
        Arrays.sort(copy);
        for(int i=0; i<nums.length; i++) {
            if (find(nums[i])!=find(copy[i])) return false;
        }
        return true;
    }
    
    private static int[] UF = new int[100001];
    
    private static int find(int x) {
        if (UF[x]==0) return UF[x]=x;
        return UF[x]==x? x: (UF[x]=find(UF[x]));
    }
    private static void union(int x, int y) {
        UF[find(x)] = UF[find(y)];
    }*/
}

another approach
class Main {
    static int root[];
    public static void main (String[] args) {
                   Scanner sc = new Scanner(System.in);
                   int n =  sc.nextInt();
                   int arr[] = new int[n];
                   int copy[] = new int[n];
                    root = new int[100005];
                    for(int i = 0 ; i < root.length ; i++)
                           root[i] = i;       
                   for(int i = 0 ; i < n ; i++){
                     arr[i] = sc.nextInt();
                     copy[i] = arr[i];
                     
                   }
               Arrays.sort(copy);

               for(int i = 0 ; i < n ;i++){
                    divisor(arr[i]);
               }
               for(int i = 0 ; i < n ; i++){
                   if(arr[i] != copy[i]){
                         if(findRoot(arr[i]) != findRoot(copy[i])){
                            System.out.print("No");
                            return;
                         }
                   }
                   
               }
               System.out.print("Yes");

    }
    public static int findRoot(int x){
        if(root[x] == x) return x;

      return  root[x] = findRoot(root[x]);
    }
    public static void divisor(int x){
        for(int i = 2 ; i*i <= x ;i++){
            if(x % i == 0){
                  root[findRoot(i)] = findRoot(x);
                  root[findRoot(x/i)] = findRoot(x);
            }
        }
    }
}

Number of Provinces easy
There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c. A province is a group of directly or indirectly connected cities and no other cities outside of the group.
You are given an n x n matrix isConnected where isConnected[i][j] = 1 if the ith city and the jth city are directly connected, and isConnected[i][j] = 0 otherwise.
Return the total number of provinces.
Input The first line of the input contains n value i. e the size of matrix. `
Next n lines contains an array of size n (the isConnected Grid)
Constraints
1 <= n <= 200
0 <= isConnected[i] <= 1
Output
Print the total count of Provinces.
Example
Sample Input
3
1 1 0
1 1 0
0 0 1
Sample Output 2

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    static int root[];

    public static void union(int u, int v){
        int pu = findRoot( u);
        int pv = findRoot( v);
        if(pu != pv){
            root[pv] = pu;
        }
    }

    public static int findRoot(int x){
        if(root[x] == x){
            return x;
        }
        return root[x] = findRoot(root[x]);
    }

    public static void main (String[] args) {
        Scanner sc= new Scanner(System.in);
        int n = sc.nextInt();
        root = new int[n];

        for(int i = 0; i < n; i++){
            root[i] = i;
        }

        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                int x = sc.nextInt();
                if(x == 1){
                    union(i, j);
                }
            }
        }

        int ans = 0;
        for(int i = 0; i < n; i++){
            if(root[i] == i)
                ans++;
        }
        System.out.println(ans);
    }
}

Connect nodes easy
You are given N nodes. Initially, no node is connected to any other node. There are two types of queries:
1 U V - Connect nodes U and V 2 U V - Check whether there exists a path between node U and V. There is a path between nodes U and V if either U and V is connected or there exists a sequence of nodes X1, X2,. XK such that U is connected to X1, X1 is connected to X2,. and XK is connected to V for some non- zero K. For each query of type 2, print 1 if nodes are connected otherwise print 0 on a separate line.
Input The first line contains two integers N and Q, denoting the number of nodes and the number of queries respectively. The next Q lines contain three integers denoting the queries in the following format: Type U V as mentioned in the problem statement
Constraints:
1 <= N, Q <= 500000
1 <= Type <= 2
1 <= U, V <= N, U != V
Output
For each query of type 2, print 1 if nodes are connected otherwise print 0 on a separate line.
Example
Sample Input:
5 5
1 2 3
2 1 4
1 1 3
1 1 4
2 2 4
Sample Output:
0
1
Explanation: After 1st query, node 2 and 3 are connected, there doesn't exist a path between 1 and 4. After 3rd query node 1 and 3 are connected. After 4th query, node 1 and 4 are connected. Now, there exists a path 2 - > 3 - > 1 - > 4, thus answer for last query is 1.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    static int[] root;

    public static int findRoot(int x){
        if(root[x] == x){
            return x;
        }
        return root[x] = findRoot(root[x]);
    }

    public static void union(int u, int v){
        int pu = findRoot(u);
        int pv = findRoot(v);

        if(pu != pv){
            root[pv] = pu;
        }
    }
    public static void main (String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        String input[] = br.readLine().split(" ");
        int n = Integer.parseInt(input[0]);
        int q = Integer.parseInt(input[1]);

        root = new int[n];
        for(int i = 0; i < n; i++){
            root[i] = i;
        }
        for(int i = 0; i < q; i++){
            input = br.readLine().split(" ");

            int t = Integer.parseInt(input[0]);
            int u = Integer.parseInt(input[1]);
            int v = Integer.parseInt(input[2]);

            u --;
            v --;

            if(t == 1){
                union(u, v);
            }else if(findRoot(u) == findRoot(v)){
                System.out.println(1);
            }else{
                System.out.println(0);
            }
        }
    }
}


https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/
DP Graph - Post Class  Min Cost Valid Path hard
Given an m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:
1 means go to the cell to the right. (i. e go from grid[i][j] to grid[i][j + 1])
2 means go to the cell to the left. (i. e go from grid[i][j] to grid[i][j - 1])
3 means go to the lower cell. (i. e go from grid[i][j] to grid[i + 1][j])
4 means go to the upper cell. (i. e go from grid[i][j] to grid[i - 1][j])
Notice that there could be some signs on the cells of the grid that point outside the grid. You will initially start at the upper left cell (0, 0). A valid path in the grid is a path that starts from the upper left cell (0, 0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path does not have to be the shortest.
You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.
Example Image Input
- First line contains n, m - dimensions of grid.
- Next n lines contains m input as 1, 2, 3, 4 representing directions.
Constraints 1 <= m, n <= 100 1 <= grid[i][j] <= 4
Output Return the minimum cost to make the grid have at least one valid path.
Input :
4 4
1 1 1 1
2 2 2 2
1 1 1 1
2 2 2 2
Output : 3
Explanation : You will start at point (0, 0).
The path to (3, 3) is as follows. (0, 0) - > (0, 1) - > (0, 2) - > (0, 3) change the arrow to down with cost = 1 - > (1, 3) - > (1, 2) - > (1, 1) - > (1, 0) change the arrow to down with cost = 1 - > (2, 0) - > (2, 1) - > (2, 2) - > (2, 3) change the arrow to down with cost = 1 - > (3, 3)
The total cost = 3.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Node{
    int x;
    int y;
    int val;

    Node(int x, int y, int val){
        this.x = x;
        this.y = y;
        this.val = val;
    }
    @Override
    public String toString(){
        return "{(" + x + ", " + y + "), " + val+ "} ";
    }
}
class Main {
    static int n;
    static int m;
    //Directio array 1 right x[0]y[0], 2 left x[1]y[1], 3 down x[2]y[2], 4 up x[3]y[3] 
    static int X[] = {0, 0, 1, -1};
    static int Y[] = {1, -1, 0, 0};

    public static boolean check(int x, int y){
        if(x < 0 || y < 0 || x >= n || y >= m){
            return false;
        }
        return true;
    }

    public static void printPQ(PriorityQueue<Node> pq){
        for(Node node: pq){
            System.out.print(node);
        }
        System.out.println();
    }

    public static int minCostValidPath(int[][] grid){
        PriorityQueue<Node> pq = new PriorityQueue<Node>(new Comparator<Node>(){
                @Override
                public int compare(Node n1, Node n2){
                    return n1.val - n2.val;
                }
        });

        int[][] visited = new int[n][m];
        int[][] dp = new int[n][m];

        for(int[] row : dp){
            Arrays.fill(row, Integer.MAX_VALUE);
        }

        pq.add(new Node(0,0,0));

        while(!pq.isEmpty()){
            Node node = pq.poll();
            //cheking visited hai ke nahi
            if(visited[node.x][node.y] == 1) continue;

            visited[node.x][node.y] = 1; // mark krdo visited hogya to
            
            //phelese jo dp me hai aur new wali value aa rahi vo dp me alredy store wale se kam hai to store kr rhe
            dp[node.x][node.y] = Math.min(dp[node.x][node.y], node.val);

            //moving to direction wala loop 4 direction 
            for(int i = 0; i < 4; i ++){
                int x = node.x + X[i];
                int y = node.y + Y[i];
                // checking arr ke bahar to nahi ja rha and alredy visited to nahi hai
                if(check(x,y) && visited[x][y] == 0){
                     // ya direction same hai ke nhi i ke sath check kr rhe hai aur mainly which direction we want to go is right or not 
                    if(grid[node.x][node.y] == i){
                        //agr same direction me jana haito cost will be zero 
                        pq.add(new Node(x, y, node.val));
                    }else{
                        //agr alag direction me jana haito cost will be one
                        pq.add(new Node(x, y, node.val + 1));
                    }
                }
                
            }
        }
        return dp[n - 1][m - 1];
    }

    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();

        int[][] grid = new int[n][m];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < m; j++){
                grid[i][j] = sc.nextInt();
                grid[i][j] --;
            }   
        }
        int ans = minCostValidPath(grid);
        System.out.println(ans);
    }

}
https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/discuss/2561180/Java-or-JavaScript-or-C%2B%2B-Solution.
/*
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        int[][] grid = new int[n][m];
        for(int i=0; i<n; i++){
            for(int j=0; j<m; j++){
                grid[i][j] = sc.nextInt()-1;
            }
        }
        int[][] dp = new int[n][m];
        boolean[][] vis = new boolean[n][m];
        for(int[] row: dp) Arrays.fill(row,Integer.MAX_VALUE);

        PriorityQueue<Node> pq = new PriorityQueue<>(new Comparator<Node>(){
            public int compare(Node a, Node b){
                return a.val-b.val;
            }
        });

        pq.add(new Node(0,0,0));

        while(!pq.isEmpty()){
            Node node = pq.poll();
            if(vis[node.x][node.y]) continue;
            vis[node.x][node.y] = true;
            dp[node.x][node.y] = Math.min(dp[node.x][node.y],node.val);
            for(int i=0; i<4; i++){
                int x = node.x + X[i];
                int y = node.y + Y[i];
                if(check(x,y) && !vis[x][y]){
                    if(grid[node.x][node.y] == i){
                        pq.add(new Node(x,y,node.val));
                    }
                    else pq.add(new Node(x,y,node.val+1));
                }
            }
        }

        System.out.print(dp[n-1][m-1]);
    }
    static int n,m;
    static int[] X = {0,0,1,-1};
    static int[] Y = {1,-1,0,0};
    static boolean check(int i, int j){
        if(i<0 || j<0 || i>=n || j>=m) return false;
        return true;
    }
}
class Node{
    int x,y,val;
    Node(int x,int y, int val){
        this.x = x;
        this.y = y;
        this.val = val;
    }
}
*/

Dynamic Programming, DP Tree - Post Class

Colorful Trees easy
You are given a tree with N nodes numbered from 1 to N. The tree is rooted at 1. You color all the leaf nodes with colors you have.
A tree is called colorful if all colored nodes are of different colors.
Print the maximum number of subtrees that can be made colorful using at most X colors.
Input First line contains N and X. Each of Next (N-1) lines contain 2 integers u and v. There exists an edge between u and v.
Constraints:  1<=N, X<=10^5 1<=u, v <= N
Output A single integer denoting number the maximum number of colorful trees.
Example Input:
5 2
2 4
4 1
3 1
4 5
Output: 4
Explanation: Subtree rooted at 1 can not be colorful, all other subtrees are colorful.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {

    public static ArrayList<Integer> [] adj;
    public static int [] leafNodes;

    //main logic assigning the color as level of the tree 
    //details more to add
    private static int dfs(int currentNode , int parentNode){
        leafNodes[currentNode]=0;
        for(int next: adj[currentNode]){
            if(next == parentNode) continue;
            leafNodes[currentNode] += dfs(next,currentNode);
        }
     
        if(currentNode != 1 && adj[currentNode].size() == 1){
          leafNodes[currentNode]=1;
        }
        return leafNodes[currentNode];
    }

    public static void main (String[] args) throws IOException {
        InputStreamReader isr = new InputStreamReader(System.in);
        BufferedReader br = new BufferedReader(isr);

        String inp1[] = br.readLine().split(" ");
        //int n = Integer.parseInt(inp[0]);
        int n = Integer.parseInt(inp1[0]);
        int x = Integer.parseInt(inp1[1]);

        adj = new ArrayList[n + 1];

        for(int i = 0;i <= n;i++){
            adj[i]= new ArrayList<Integer>();
        }
 
        for(int i = 1; i < n; i++){
            int u, v;
            inp1 = br.readLine().split(" ");
            u = Integer.parseInt(inp1[0]);
            v = Integer.parseInt(inp1[1]);
            //System.out.println( u + " " +  v  );
            adj[u].add(v);
            adj[v].add(u);
            //System.out.println( adj[i] + " " );
        }

        leafNodes = new int[n+1]; 
         
        dfs(1,-1);

        int ans = 0;
        for(int i = 1;i <= n;i++){
            if(leafNodes[i] <= x){
                ans++;
            }
        }
        System.out.println(ans);
        
    }
}

code from shyam jha need to be check
import java.io.*;
 import java.util.*;  
 
 public class Main {
 
     private static ArrayList<Integer> [] adj;
     private static int [] leaf;
     
     
     private static int dfs(int cur , int par){
         leaf[cur]=0;
         for(int next: adj[cur]){
           if(next == par)continue;
           leaf[cur] += dfs(next,cur);
         }
     
         if(cur != 1 && adj[cur].size() == 1){
           leaf[cur]=1;
         }
         return leaf[cur];
     }
 
     public static void main(String[] args) {
         InputStream inputStream = System.in;
         OutputStream outputStream = System.out;
         InputReader in = new InputReader(inputStream);
         OutputWriter out = new OutputWriter(outputStream);
         
         int n=Integer.parseInt(in.next());
         int x=Integer.parseInt(in.next());
 
         adj = new ArrayList[n+1];
 
         for(int i=0;i<=n;i++){
             adj[i]=new ArrayList<Integer>();
         }
 
         for(int i=1;i<n;i++){
             int u,v;
             u=Integer.parseInt(in.next());
             v=Integer.parseInt(in.next());
             adj[u].add(v);
             adj[v].add(u);
         }
 
         leaf = new int[n+1]; 
         
         dfs(1,-1);
 
         int ans=0;
         for(int i=1;i<=n;i++){
             if(leaf[i]<=x){
                 ans++;
             }
         }
         out.print(ans);
         out.close();
     }
 
     
     static class InputReader {
         BufferedReader reader;
         StringTokenizer tokenizer;
         public InputReader(InputStream stream) {
             reader = new BufferedReader(new InputStreamReader(stream), 32768);
             tokenizer = null;
         }
 
         public String next() {
             while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                 try {
                     tokenizer = new StringTokenizer(reader.readLine());
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }
             }
             return tokenizer.nextToken();
         }
 
         public int nextInt() {
             return Integer.parseInt(next());
         }
 
     }
 
     static class OutputWriter {
         private final PrintWriter writer;
 
         public OutputWriter(OutputStream outputStream) {
             writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
         }
 
         public OutputWriter(Writer writer) {
             this.writer = new PrintWriter(writer);
         }
 
         public void print(Object... objects) {
             for (int i = 0; i < objects.length; i++) {
                 if (i != 0) {
                     writer.print(' ');
                 }
                 writer.print(objects[i]);
             }
         }
 
         public void println(Object... objects) {
             print(objects);
             writer.println();
         }
 
         public void close() {
             writer.close();
         }
 
         public void println(int i) {
             writer.println(i);
         }
 
     }
 }


Tree Centroid medium
Given a tree of n nodes, your task is to find a centroid, i.e, a node such that when it is appointed the root of the tree, each subtree has at most ⌊n/2⌋ nodes.
Input The first input line contains an integer n: the number of nodes. The nodes are numbered 1, 2, …, n.
Then there are n−1 lines describing the edges. Each line contains two integers a and b: there is an edge between nodes a and b.
Constraints 1 <= n <= 2e5 1 <= a, b <= n
Output Print one integer: a centroid node (the first found one)
Example Sample Input :
5
1 2
2 3
3 4
3 5
Sample Output :3
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework


class Graph{
    int n; 
    ArrayList<Integer> adjList[];
    int subTreeSize[];
    int centroid = Integer.MAX_VALUE;

    Graph(int n){
        this.n = n;
        subTreeSize = new int[n];
        adjList = new ArrayList[n];
        for(int i = 0; i < n ; i ++){
            adjList[i] = new ArrayList<>();
        }
    }

    public void add(int u, int v){
        adjList[u - 1].add(v - 1);
        adjList[v - 1].add(u - 1);
    }

    public int getTreeCentroid(){
        // call the dfs
        dfs(0, -1 );
        
        findTreeCentroid(0 , 1 , 0);
        return centroid;
    }

    private int dfs(int u, int parentNode){
        int treeSize = 1;
        for(Integer v : adjList[u]){
            if(v != parentNode){
                treeSize += dfs(v, u);
            }
        }
        return subTreeSize[u] = treeSize;
    }

    //checking 
    private boolean checkCentroid(int u, int parentNode){
        for(int v: adjList[u]){
            if(v != parentNode && subTreeSize[v] > n/2){
                return false;
            }
        }
        return true;
    }

    private void findTreeCentroid(int u, int parentNode, int parentSize){
        if(checkCentroid(u, parentNode) && parentSize <= n/2)
            centroid = Math.min(centroid, u);

        for(int v: adjList[u]){
            if(v != parentNode){
                parentSize += subTreeSize[v];
            }
        }
        parentSize++;

        for(int v: adjList[u]){
            if(v != parentNode){
                parentSize -= subTreeSize[v];

                findTreeCentroid(v, u, parentSize);
                parentSize += subTreeSize[v];
            }
        }
    }
}
class Main {


    public static void main (String[] args) throws IOException{
        InputStreamReader isr = new InputStreamReader(System.in);
        BufferedReader br = new BufferedReader(isr);

        String inp[] = br.readLine().split(" ");

        int n = Integer.parseInt(inp[0]);
        Graph g = new Graph(n);
        for(int i = 0; i < n - 1; i++){
            inp = br.readLine().split(" ");
            int u = Integer.parseInt(inp[0]);
            int v = Integer.parseInt(inp[1]);

            g.add(u,v);
        }

        int res = g.getTreeCentroid();
        System.out.println(res + 1);
    }
}


Graph

Detect cycle in an undirected graph easy
Given an undirected graph, the task is to create a program to detect if there is a cycle in the undirected graph or not.
Input The first line of input contains two integers N and M which denotes the no of vertices and no of edges in the graph respectively.
Next M lines contain space-separated integers u and v denoting that there is a directed edge from u to v.
Constraints: 1 <= N, M <= 1000 0 <= u, v <= N-1, u != v
There are no self loops or multiple edges.
Output Print 'Yes' if there is a cycle in the graph otherwise print 'No'
Example Sample Input 1:
4 5
0 1
1 2
2 3
3 0
0 2
Sample Output 1: Yes
Explanation: There is a cycle with nodes 0, 1, 2, 3
Sample Input 2:
4 3
0 1
1 2
2 3
Sample Output 2: No
Explanation:There is no cycle in this graph

/*import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// in java code only four test cases are running  rutime erroe and one is wrong answer baki jagah chal tha hai
class Graph{
    int n;
   ArrayList<ArrayList<Integer>> list;

    Graph(int n){
        this.n=n;
        list=new ArrayList<>();

        for(int i=0;i<n;i++){
          list.add(new ArrayList<>());
        }
    }

    void add(int u,int v){
        list.get(v).add(u);
        list.get(u).add(v);
    }

    public boolean isCycle(){
        boolean[]vis = new boolean[n];
      
        for(int i = 0; i < n; i++){
            if(!vis[i]){
                if(checkForCycleDFS(i, list, vis, -1)) return true;
            }
        }
        return false;
    }

    public boolean checkForCycleDFS(int v, ArrayList<ArrayList<Integer>> adj, boolean[] visited, int parent){
        visited[v] = true;
        
        for(Integer neighbor : adj.get(v)){
            if(!visited[neighbor]){
                if(checkForCycleDFS(neighbor,adj,visited, v) == true)
                    return true;
            } else if(parent != neighbor){
                     return true;                    
            }
        }
           return false; 
    }

    // /*boolean haveCycle(){
    //     boolean[]vis=new boolean[n];
      
    //     for(int i = 0;i < n;i++){
    //         if(vis[i] == false){
    //             if(checkForCycle(i,-1,vis)) return true;
    //         }
    //     }
    //     return false;
    // }

    // boolean checkForCycle(int i, int par,boolean vis[]){

    //     vis[i] = true;
    //     for(Integer elmt:list.get(i)){
    //         if(vis[elmt] == false){
    //             if(checkForCycle(elmt,i,vis))
    //              return true;
    //             } else if(elmt != par){
    //                  return true;                    
    //             }
            
    //     }
    //    return false; 
    // }

}

class Main {
    
    public static void main (String[] args) throws IOException {
        InputStreamReader inp = new InputStreamReader(System.in);
        BufferedReader br = new BufferedReader(inp);

        String str[] = br.readLine().split(" ");

        int n = Integer.parseInt(str[0]);
        int m = Integer.parseInt(str[1]);

        Graph g = new Graph(n);

        for(int i = 0; i < m; i++){
            str = br.readLine().split(" ");

            int u = Integer.parseInt(str[0]);
            int v = Integer.parseInt(str[1]);

            g.add(u, v);
        }
 
        boolean check = g.isCycle();
        if(check == true){
            System.out.print("Yes");
        }else //if(!g.haveCycle()){
            System.out.print("No");
                    // }
    }
}*/


//In C++ 

#include "bits/stdc++.h"
#pragma GCC optimize "03"
using namespace std;
 
#define int long long int
#define ld long double
#define pi pair<int, int>
#define pb push_back
#define fi first
#define se second
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)
#ifndef LOCAL
#define endl '\n'
#endif
 
const int N = 2e5 + 5;
const int mod = 1e9 + 7;
const int inf = 1e9 + 9;

vector<int> g[N];
int vis[N];
bool flag = 0;

void dfs(int u, int p){
	vis[u] = 1;
	for(auto i: g[u]){
		if(i == p)	continue;
		if(vis[i] == 1)
			flag = 1;
		if(vis[i] == 0)	dfs(i, u);
	}
	vis[u] = 2;
}

signed main() {
	IOS;
	int n, m;
	cin >> n >> m;
	for(int i = 1; i <= m; i++){
		int u, v;
		cin >> u >> v;
		g[u].push_back(v);
		g[v].push_back(u);
	}	
	for(int i = 0; i < n; i++){
		if(vis[i])	continue;
		dfs(i, n);
	}
	if(flag)
		cout << "Yes";
	else
		cout << "No";
	return 0;
}


Shortest Cycle easy
Given an undirected graph consisting of N vertices. Determine length of Shortest Cycle. If cycle does not exist print 1000000000. The length of the cycle means the number of edges in that cycle.
InputThe first line of the input contains two integers N and M, the number of nodes and the number of edges in the graph.
The next M lines contain two integers u, v indicating there is an edge between u and v.
Constraints 2 <= N <= 100000 0 <=M<= 200000 1 <= u, v <= 100000  u != v
Output Print single integer which is answer to given problem
Example Sample Input
6 5
1 2
2 3
3 4
2 5
5 6
Sample Output 1000000000
Sample Input
3 3
1 2
2 3
3 1
Sample Output 3 

#include<bits/stdc++.h>
using namespace std;

#define pu push_back
#define fi first
#define se second
#define mp make_pair
#define int long long
#define pii pair<int,int>
#define mm (s+e)/2
#define all(x) x.begin(), x.end()
#define For(i, st, en) for(int i=st; i<en; i++)
#define tr(x) for(auto it=x.begin(); it!=x.end(); it++)
#define fast std::ios::sync_with_stdio(false);cin.tie(NULL);
#define sz 200000

vector<int> NEB[sz];
int sum=0;
int vis[sz],H[sz];
int cycl=1000000000;
void dfs(int s,int f,int h)
{
	  
    H[s]=h;
    vis[s]=1;
    //cout<<s<<endl;
	for(int i=0;i<NEB[s].size();i++)
	{  int it=NEB[s][i];
		if(it==f) continue;
		if(vis[it]==0) dfs(it,s,h+1);
		else if(vis[it]==1) 
		{ 
         cycl=min( abs(H[s]-H[it])+1, cycl);
		}
	}
}
signed main()
{	
		int n,m;
		cin>>n>>m;
		for(int i=0;i<m;i++)
		{
          int a,b;
          cin>>a>>b;
          NEB[a].pu(b);
          NEB[b].pu(a);
		}
		
        for(int i=1;i<=n;i++)
        {
        	if(vis[i]==0) dfs(i,-1,0);
        }
        cout<<cycl<<endl;	
}

Shortest Cycl easy
Given an undirected graph consisting of N vertices. Determine length of Shortest Cycle. If cycle does not exist print 1000000000. The length of the cycle means the number of edges in that cycle.
InputThe first line of the input contains two integers N and M, the number of nodes and the number of edges in the graph.
The next M lines contain two integers u, v indicating there is an edge between u and v.
Constraints2 <= N <= 1000000 <=M<= 2000001 <= u, v <= 100000 u != v
OutputPrint single integer which is answer to given problem
ExampleSample Input
6 5
1 2
2 3
3 4
2 5
5 6
Sample Output1000000000 
// import java.io.*; // for handling input/output
// import java.util.*; // contains Collections framework

// class Graph{
//     int n;
//     ArrayList<ArrayList<Integer>>list;
   
//     Graph(int n){
//         this.n = n;
//         list = new ArrayList<>();
//         for(int i = 0; i < n;i++){
//             list.add(new ArrayList<>());
//         }
//     }

//     void add(int v,int u){
//         list.get(v-1).add(u-1);
//         list.get(u-1).add(v-1);
//     }
//     // int sum=0;
//     // int vis[] = new int[n];
//     // int H[] = new int[n];
//     // int cycl=1000000000;
//     // void dfs(int s,int f,int h){
        
//     //     H[s] = h;
//     //     vis[s] = 1;
//     //     //cout<<s<<endl;
//     //     for(int i=0; i < list.get(s).size();i++){ 
//     //         int it = list.get(s).get(i);
//     //         if(it==f) continue;
//     //         if(vis[it]==0) dfs(it,s,h+1);
//     //         else if(vis[it]==1) 
//     //         { 
//     //         cycl=Math.min( Math.abs(H[s]-H[it])+1, cycl);
//     //         }
//     //     }
//     // }

//     int shortestCycle(){ //1000000000
//         int ans = Integer.MAX_VALUE;
//         for(int i = 0; i < n;i++){
           
//             int[]distance = new int[n];
//             Arrays.fill(distance,(int) 1e9);
            
//             int[]parent = new int[n];
//             Arrays.fill(parent, -1);

//             distance[i] = 0;

//             Queue<Integer> q = new LinkedList<>();
//             q.add(i);

//             while( !q.isEmpty()){
//                 int x = q.poll();

//                 for(int child : list.get(x)){
//                     if(distance[child] == (int) (1e9)){
//                         distance[child] = 1 + distance[x];

//                         parent[child] = x;

//                         q.add(child);
//                     }else if( parent[x] != child && parent[child] != x){
//                         ans = Math.min(ans, distance[x] + distance[child] + 1);
//                     }
//                 }
//             } 
         
//         }
//         if(ans == Integer.MAX_VALUE)
//           return 1000000000;
//         else
//            return ans;
//     }
// }
// class Main {
//     public static void main (String[] args)throws IOException {
        
//         BufferedReader br=new BufferedReader (new InputStreamReader(System.in));
//         String st[] = br.readLine().split(" ");
    
//         int v = Integer.parseInt(st[0]);
//         int m = Integer.parseInt(st[1]);

//         Graph g = new Graph(v);              
        
//         for(int i = 0; i < m; i++){
//             String str[]=br.readLine().split(" ");
//             int x = Integer.parseInt(str[0]);
//             int y = Integer.parseInt(str[1]);
//             g.add(x,y);
//         }

//         //System.out.print(g.shortestCycle());
//         for(int i = 0; i < v;i++) {
            
//         	if(g.vis[i] == 0) 
//                 g.dfs(i,-1,0);
//         }
//         System.out.print(g.cycl);

//     }
// }

#include<bits/stdc++.h>
using namespace std;

#define pu push_back
#define fi first
#define se second
#define mp make_pair
#define int long long
#define pii pair<int,int>
#define mm (s+e)/2
#define all(x) x.begin(), x.end()
#define For(i, st, en) for(int i=st; i<en; i++)
#define tr(x) for(auto it=x.begin(); it!=x.end(); it++)
#define fast std::ios::sync_with_stdio(false);cin.tie(NULL);
#define sz 200000

vector<int> NEB[sz];
int sum=0;
int vis[sz],H[sz];
int cycl=1000000000;
void dfs(int s,int f,int h)
{
	  
    H[s]=h;
    vis[s]=1;
    //cout<<s<<endl;
	for(int i=0;i<NEB[s].size();i++)
	{  int it=NEB[s][i];
		if(it==f) continue;
		if(vis[it]==0) dfs(it,s,h+1);
		else if(vis[it]==1) 
		{ 
         cycl=min( abs(H[s]-H[it])+1, cycl);
		}
	}
}
signed main()
{
	
		
		int n,m;
		cin>>n>>m;
		for(int i=0;i<m;i++)
		{
          int a,b;
          cin>>a>>b;
          NEB[a].pu(b);
          NEB[b].pu(a);
		}
		
        for(int i=1;i<=n;i++)
        {
        	if(vis[i]==0) dfs(i,-1,0);
        }
        cout<<cycl<<endl;
}


Great administrator hard    same problem on https://www.hackerearth.com/practice/algorithms/graphs/minimum-spanning-tree/practice-problems/algorithm/mr-president/
https://github.com/my-nguyen/hackerearth.com/blob/master/mr_president.java
Your country consists of N cities and M bidirectional roads connecting them. Each road has assigned a cost of its maintenance. The greatest achievement in the game is called "Great administrator" and it is given to a player who manage to have all cities in the country connected by roads in such a way that it is possible to travel between any two cities and that the sum of maintenance costs of these roads is not greater than K.
This is very hard to accomplish, but you are very close to do it. More precisely, you have just discovered a new method of transforming standard roads into super roads, with cost of maintenance just 1, due to their extreme durability.
The bad news is that it is very expensive to transform a standard road into a super road, but you are so excited that you are going to do it anyway.
In addition, because you have a lot of other expenses, you also want to first demolish as many roads as possible in order to safe some money on their maintenance first and then start working on getting the achievement. You can demolish any road in the country and that operation does not cost you anything.
Because you want to spend the absolutely minimum money in order to get the achievement, you are interested in the smallest number of transformations of standard roads into super roads in such a way that you can do that.
Input In the first line there are 3 integers N, M and K denoting the number of cities in the country, the number of roads in it and the desired sum of costs of maintenance. M lines describing these roads follow. In each of them there are 3 integers A, B and C, where A and B denote the endpoints of the road while C denotes the cost of its maintenance.
Constraints 2 <= N, M <= 10^6  0 <= K <= 10^18  1 <= A, B <= N and A != B 1 <= C <= 10^6
OutputIn a single line, output the minimum number of roads which need to be transformed in order to get the achievement. If you cannot do it no matter what, output -1.
ExampleSample Input
3 3 25
1 2 10
2 3 20
3 1 30
Sample Output 1
ExplanationYou can transform to super a road either the road between cities 1 and 2 or the road between cities 2 and 3 in order to produce the desired road network of costs respectively 21 and 11. Doing that will cost you one transformation and it is optimal in this case. 

Anothers Appraoch
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.List;
import java.util.PriorityQueue;
 public class Main{
    public static void main(String args[]) throws Exception{
       
			BufferedReader s = new BufferedReader(new InputStreamReader(System.in));
			PriorityQueue<Edge> pq=new PriorityQueue<Edge>();
			
			try{
				String[] line = s.readLine().split(" "); 
			int n = Integer.parseInt(line[0]);
			int m = Integer.parseInt(line[1]);
			long k = Integer.parseInt(line[2]);
			double ans=0;
			long count=0;
			int y=0;
			int weight[]=new int[n];
			for(int i=0;i<m;i++){
				String[] li = s.readLine().split(" "); 
				int a = Integer.parseInt(li[0]);
				int b = Integer.parseInt(li[1]);
				int c = Integer.parseInt(li[2]);
				Edge e=new Edge(a-1,b-1,c);
				pq.add(e);
			}
			DisjointUnionSets ds=new DisjointUnionSets(n);
			while(!pq.isEmpty()) {
				Edge e=pq.poll();
				if(ds.findSet(e.v1)!=ds.findSet(e.v2)){
					ds.union(e.v1,e.v2);
					ans+=e.weight;
					weight[y]=e.weight;
					y++;
				}
			}
			Arrays.sort(weight);
			boolean flag=true;
			int x=ds.findSet(0);
			for(int i=0;i<n;i++){
				if(ds.findSet(i)!=x) flag=false;
			}
			if(!flag){
				System.out.println("-1");
				return;
			}
			if(ans<=k) System.out.println(count);
			else{
				while(ans>k && n>0){
					if(weight[n-1]==0) break;
					ans-=weight[n-1];
					ans+=1;
					n--;
					count++;
				}
				if(ans>k)
					System.out.println("-1");
				else
					System.out.println(count);
			}
		} 
		catch(Throwable e){
			System.out.println(-1);
		}
    }
}
class Edge implements Comparable<Edge>{
	int v1,v2,weight;
	Edge(int v1,int v2,int weight){
		this.v1 = v1;
		this.v2= v2;
		this.weight=weight;
	}
	@Override
	public int compareTo(Edge that) {
		return this.weight - that.weight;
	}
}	  
	
class DisjointUnionSets {
	int[] parent;
	int n;
	public DisjointUnionSets(int n) {
		parent = new int[n];
		this.n=n;
		for(int i=0;i<n;i++) parent[i] = i;
	}
	int findSet(int x){ 
		if(parent[x]!=x) parent[x] = findSet(parent[x]);
		return parent[x];
	}
	void union(int x, int y) { 	
		int xRoot = findSet(x); 
		int yRoot = findSet(y); 
		if(xRoot == yRoot) return;
		parent[xRoot] = yRoot; 
	}
}




Jumping game medium Graph problem // https://my.newtonschool.co/playground/code/tzh9t7o6948k/
tSara is playing a jumping game in which she has been given a non-negative integer array, in which at every index the player can jump either at (i + Arr[i]), or (i - Arr[i]) index(If the position is valid) where i is the index of its current position. Now Sara wants to know the minimum number of jumps require from each index to reach at the last one.
Input The first line of input contains a single integer N denoting the size of the array. The next line of input contains N space separated integers depicting the values of the array.
Constraints:- 1 <= N <= 100000 1 <= Arr[i] <= N
Output Print N space separated integers where each integer represent the minimum number of jump needed to reach the last index. If the player is unable to reach the last index print -1.
Example
Sample Input:-
5
1 3 2 2 4
Sample Output:-
2 1 1 2 0
Explanation:-
index 1:- 1- >2- >5
index 2:- 2- >5
index 3:- 3- >5
index 4:- 4- >2- >5
index 5:-5
Sample Input:-
5
1 2 3 1 5
Sample Output:- 3 2 -1 1 0
this is also anothers appraoch with bfs https://my.newtonschool.co/playground/code/tzh9t7o6948k/

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ArrayList<ArrayList<Integer>> adList = new ArrayList<>();
        for(int i=0; i<n; i++) 
            adList.add(new ArrayList<>());
        
        for(int i=0; i<n; i++){
            int x = sc.nextInt();
            if(i+x < n)  adList.get(i+x).add(i);
            if(i-x >= 0 ) adList.get(i-x).add(i);
        }
        
        int[] ans = new int[n];
        Arrays.fill(ans,999999);
        ans[n-1] = 0;
        bfs(adList,n-1,ans);
        for(int x:ans){
            if(x == 999999) System.out.print("-1 ");
            else System.out.print(x+" ");
        }   
    }
    static void bfs(ArrayList<ArrayList<Integer>> adj, int v,int[] ans){
        Queue<Integer> q = new LinkedList<>();
        boolean vis[] = new boolean[v+1];
        q.add(v);
        while(!q.isEmpty()){
            int u = q.remove();
            vis[u] = true;
            for(int x : adj.get(u)){
                if(!vis[x]){
                    q.add(x);
                    ans[x] = Math.min(ans[x],ans[u]+1);
                }   
            }
        }
    }
}

Anothers approCH Graph problem solved by dp
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0; i<n; i++) arr[i] = sc.nextInt();
        int[] dp = new int[n];
        int max = 9999999;
        Arrays.fill(dp,max);
        dp[n-1] = 0;
        for(int i=0;i<n-1;i++){
            if(i+arr[i] == n-1) dp[i] = 1;
        }
        for(int j= 0; j*j<n;j++)
        for(int i=0; i<n-1; i++){
            // if(dp[i] != max) continue;
            if(i+arr[i] < n) dp[i] = Math.min(dp[i],1+dp[i+arr[i]]);
            if(i-arr[i] >= 0) dp[i] = Math.min(dp[i],1+dp[i-arr[i]]);
        }
        for(int i=n-2; i>=0; i--){
            // if(dp[i] != max) continue;
            if(i+arr[i] < n) dp[i] = Math.min(dp[i],1+dp[i+arr[i]]);
            if(i-arr[i] >= 0) dp[i] = Math.min(dp[i],1+dp[i-arr[i]]);
        }
        for(int x: dp) {
            if(x==max) System.out.print("-1 ");
            else System.out.print(x+" ");
        }
    }
    static int solve(int[] arr, int i, int dp[]){
        if(i<0 || i >= arr.length) return Integer.MAX_VALUE;
        // if(i == arr.length-1) return 0;
        if(dp[i] != Integer.MAX_VALUE) return dp[i];
        return dp[i] = 1+Math.min(solve(arr,i+arr[i],dp),solve(arr,i-arr[i],dp));
    }
}

Same with little diffrent 
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i=0; i<n; i++) arr[i] = sc.nextInt();
        int[] dp = new int[n];
        int max = 9999999;
        Arrays.fill(dp,max);
        dp[n-1] = 0;
        for(int i=0;i<n-1;i++){
            if(i+arr[i] == n-1) dp[i] = 1;
        }
        for(int j = 0; j*j<n; j++){
            for(int i=0; i<n-1; i++){
                if(i+arr[i] < n) dp[i] = Math.min(dp[i],1+dp[i+arr[i]]);
                if(i-arr[i] >= 0) dp[i] = Math.min(dp[i],1+dp[i-arr[i]]);
            }
        }
        for(int x: dp) {
            if(x==max) System.out.print(-1+" ");
            else System.out.print(x+" ");
        }
    }
}

Dijkstra Algorithm easy
Given a weighted undirected graph.Task is to find the shortest path from source vertex (vertex number 1) to all other vertices from 2 to n.
Input Given 2 integers N and M. N represents the number of vertices in the graph. M represents the number of edges between any 2 vertices.
Then M lines follow, each line has 2 space separated integers a, b where a and b represents an edge from vertex a to vertex b and the weight of that edge = (a+b)%1000.
Constraints 1<=N<=100000 1<=M<=1000000
Output
Print the shortest distances from the source vertex (vertex number 1) to all other vertices from 2 to n in separate line. Print "-1" in case the vertex can't be reached form the source vertex.
Example
Sample Input
4 5
1 2
1 4
4 2
4 3
2 3
Sample Output
3
8
5 
using treeset and proprity queue, hashmap
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

//video 5922see
class Edge {
    int v;
    int w;
    Edge(int v, int w) {
        this.v = v;
        this.w = w;
    }
}

class Graph {
    int n;
    ArrayList<Edge> adjList[];
    Graph(int n) {
        this.n = n;
        adjList = new ArrayList[n];

        for(int i = 0; i < n; i++)
            adjList[i] = new ArrayList<>();
    }

    public void add(int u, int v, int w) { 
        adjList[u-1].add(new Edge(v-1, w));
        adjList[v-1].add(new Edge(u-1, w));
    }
    ///this is using the treeset sirs second apporach
    public int[] shortestPaths(int source) {
        source--;
        int dist[] = new int[n];
        Arrays.fill(dist, -1);
        dist[source] = 0;
        HashSet<Integer> vis = new HashSet<>();
        TreeSet<int[]> set = new TreeSet<>(new Comparator(){
            public int compare(Object a, Object b) {
                int[] x = (int[]) a;
                int[] y = (int[]) b;

                if(x[0] < y[0])
                    return -1;

                if(x[0] > y[0])
                    return 1;

                if(x[1] < y[1])
                    return -1;

                return 1;
            }
        });
        set.add(new int[]{0, source});
        while(vis.size() != n) {
            if(set.isEmpty())
                return dist;

            int u = set.pollFirst()[1];

            if(vis.contains(u))
                continue;

            vis.add(u);

            for(Edge e: adjList[u]) {
                if(vis.contains(e.v))
                    continue;

                if(dist[e.v] > dist[u] + e.w)
                    set.remove(new int[]{dist[e.v], e.v});

                if(dist[e.v] == -1 || dist[e.v] > dist[u] + e.w) {
                    dist[e.v] = dist[u] + e.w;
                    set.add(new int[]{dist[e.v], e.v});
                }
            }
        }
        return dist;
    }

    //usoing PriorityQueue
    public  int[] dijkstraAlgo(int source){
        source--;
        int distance[] = new int[n];
        Arrays.fill(distance, -1);
        distance[source] = 0;
        //visited ka hashset liya insted boolean array
        HashSet<Integer> visited = new HashSet<>();
        //using the priority que and applying the comparator suing lambda expression insted writing big line of code
        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b)->Integer.compare(a[0],b[0]));
        pq.add(new int[]{0, source});

        while(visited.size() != n){
            if(pq.isEmpty()){
                return distance;
            }
            int u = pq.peek()[1];

            pq.poll();
            if(visited.contains(u)) 
                continue;
            
            visited.add(u);

            for(Edge e: adjList[u]){
                if(visited.contains(e.v)){ continue;}
                if(distance[e.v] == -1 || distance[e.v] > distance[u] + e.w){
                    distance[e.v] = distance[u] + e.w;
                    pq.add(new int[] {distance[e.v], e.v});
                }
            }
        }
        return distance;
    }
}

class Main {

    public static void main (String[] args) throws Exception {
        InputStreamReader inp = new InputStreamReader(System.in);
        BufferedReader br = new BufferedReader(inp);

        String str[] = br.readLine().split(" ");

        int n = Integer.parseInt(str[0]);
        int m = Integer.parseInt(str[1]);

        Graph g = new Graph(n);

        for(int i = 0; i < m; i++)  {
            str = br.readLine().split(" ");

            int u = Integer.parseInt(str[0]);
            int v = Integer.parseInt(str[1]);

            g.add(u, v, (u+v)%1000);
        }

        //int ans[] = g.shortestPaths(1);
         int ans[] = g.dijkstraAlgo(1);

        for(int i = 1; i < ans.length; i++)
            System.out.println(ans[i]);
    }
}


Sum of some nodes medium 
A Tree with N nodes and an integer K is given. For each node X in the tree you need to find sum of value of all the ancestors Y of node X if the number of direct children of ancestor Y are greater than equal to K.
Value of a node is its index itself (1 based).
A node is considered an ancestor of itself.
Root node is always 1.Input First line of input contains two space separated integers N and K, denoting the number of nodes in tree and integer key respectively.
Next N-1 lines contain two space separated integers A and B denoting an undirected edge from A to B.
Constraints:-1 <= N <= 100000 1 <= K <= 10
Output
Print N lines such that the i-th line contains only a single integer denoting the ans for ith node
Example
Sample input
8 2
1 2
1 3
1 4
2 5
2 6
3 7
6 8
Sample output
1
3
1
1
3
3
1
3

Node 1 has 3 children so it's ans is 1
Node 2 has 2 children so it's ans is 1+2=3

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); // numbr of nodes / vertex in graph  
        int k = sc.nextInt(); // sum to k of vertexor node
        Graph g = new Graph(n);

        for(int i = 1; i <= n - 1 ; i++){
            Integer u = null;
            Integer v = null;
            if(sc.hasNextInt()){
                u = sc.nextInt();
            }
            if(sc.hasNextInt()){
                v = sc.nextInt();
            }
            if(u != null && v != null){
                g.add(u,v);
            }
        }
        long[] result = new long[n + 1];
        g.DFSTraversal(result,n, k );

        for(int i = 1; i <= n; i++){
            System.out.println(result[i]);
        }
    }
}

class Graph{
    int n;
    ArrayList<ArrayList<Integer>> adjList;

    Graph(int n){
        adjList = new ArrayList<>();
        for(int i = 0; i <= n; i++){
            adjList.add(new ArrayList<>());
        }
    }
    //u vertex v edges
    void add(int u, int v){
        adjList.get(u).add(v);
        adjList.get(v).add(u);
    }
    // info for getting the visited verted 
    boolean[] visited = new boolean[n + 1];

    void DFSTraversal(long[] result, int n, int k){
        boolean[] visited = new boolean[n + 1];
        DFSTraversal(result, 1, visited, 0, k);
    }

    void DFSTraversal(long[] result, int u, boolean[] visited, int sum, int k){
        visited[u] = true;
        //geting the count of visited not from adlist
        int count = adjList.get(u).size();
        if(u != 1){
            count --;
        }
        if(count >= k) {
            sum += u;
        }
        result[u] = sum;

        for(int v : adjList.get(u)){
            if(!visited[v]){
                DFSTraversal(result, v, visited, sum, k);
            }
        }
    }
}



Rotten Oranges medium  https://www.geeksforgeeks.org/minimum-time-required-so-that-all-oranges-become-rotten/
Given a matrix of dimension n*m where each cell in the matrix can have values 0, 1 or 2 which has the following meaning:
0: Empty cell
1: Cells have fresh oranges
2: Cells have rotten oranges
So we have to determine what is the minimum time in sec required so that all the oranges become rotten. A rotten orange at index [i,j] can rot other fresh orange at indexes [i-1,j], [i+1,j], [i,j-1], [i,j+1] (up, down, left and right) in 1 sec. If it is impossible to rot every orange then simply print -1.
Input First line of input has two integers n & m .
Then n lines follows having m space seperated integers which can be 0,1 or 2.
Constraints:1 <= n,m <= 300
Output Print a single integer the minimum time required to rot all the oranges.If impossible, print -1.
Example Input:
3 5
2 1 0 2 1
1 0 1 2 1
1 0 0 2 1
Output:2
Explanation:
Testcase 1:
2 1 0 2 1
1 0 1 2 1
1 0 0 2 1
Oranges at positions {0,0}, {0, 3}, {1, 3} and {2, 3} will rot oranges at {0, 1}, {1, 0}, {0, 4}, {1, 2}, {1, 4}, {2, 4} during 1st unit time. And, during 2nd unit time, orange at {1, 0} got rotten and will rot orange at {2, 0}. Hence, total 2 unit of time is required to rot all oranges. 
//this is sir approach
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Cordinates{
    int x, y;
    Cordinates(int x, int y){
        this.x = x;
        this.y = y;
    }
}

class Main {
    static int rowN;
    static int colM;

    public static boolean check(int x, int y){
        if(x < 0 || y < 0 || x >= rowN || y >= colM )
            return false;

        return true;
    }
   
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        // ye niche wala structure xy axis jaise nbanay gaya hai so which help to acces the particular elemnt in matrix 
        //like up down an dleft and right possion in matrix whci' represent by this  x and y arr..
        int X[] = {1, -1, 0, 0};
        int Y[] = {0, 0, 1, -1};

        rowN = sc.nextInt();
        colM = sc.nextInt();
        Queue<Cordinates> q = new LinkedList<>();
        int fresh = 0; // counting the frss oranges;

        int[][] rOranges = new int[rowN][colM]; 
        for(int i = 0; i < rowN; i++){
            for(int j = 0; j < colM; j++){
                rOranges[i][j] = sc.nextInt();

                if(rOranges[i][j] == 2 ) q.add(new Cordinates(i, j));
                if(rOranges[i][j] == 1 ) fresh++;
            }
        }

        int time  = -1;
        while(!q.isEmpty()){
            int sz = q.size();
            // ye size iske liye hai 1 sec me kitne oranges rotten hua so is queu ka size indicate krenga first 
            //excution of loop me jitne bhi element the that for 1 sec rotten element
            for(int i = 0; i < sz; i++){
                Cordinates c = q.poll();

                // nye to 4 ka loop hai vo elemnt acces from  the grid or matrix se
                for(int j = 0; j < 4; j++){
                    int x = c.x + X[j];
                    int y = c.y + Y[j];
                    
                    //check funciton help to  check matrix se bahar na m=nikal jaye cordinates//
                    if(check(x,y) && rOranges[x][y] == 1){
                        fresh --;
                        rOranges[x][y] = 2;
                        q.add(new Cordinates(x,y));
                    }
                }
            }
            time ++;
        }
        if(fresh != 0) 
            System.out.println(-1);
        else
            System.out.println(time);
    }
}

Has Path easy https://www.geeksforgeeks.org/find-if-there-is-a-path-between-two-vertices-in-an-undirected-graph/
Given an undirected graph G (V, E) and two vertices v1 and v2 (as integers), check if there exists any path between them or not. Print true or false.
V is the number of vertices present in graph G and vertices are numbered from 0 to V-1.
E is the number of edges present in graph G.
InputLine 1: Two Integers V and E (separated by space)
Next E lines: Two integers a and b, denoting that there exists an edge between vertex a and vertex b (separated by space)
Line (E+2): Two integers v1 and v2 (separated by space)
Constraints :2 <= V <= 1000 1 <= E <= 1000 0 <= v1, v2 <= V-1
OutputFor each testcase in new line, you need to print true or false.
ExampleSample Input 1 :
4 4
0 1
0 3
1 2
2 3
1 3
Sample Output 1 :true

Explanation:
There are multiple path exists between 1 and 3. One of them is as such: 1 -> 2 -> 3.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
import java.util.LinkedList;
import java.util.Queue;
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        
		int vertices = sc.nextInt();
        int edge = sc.nextInt();

		Graph g = new Graph(vertices);
        
        for(int i = 0; i < edge; i++){
            	g.addEdge(sc.nextInt(), sc.nextInt());
        }

        int u = sc.nextInt();
        int v = sc.nextInt();
		if (g.isReachable(u, v))
            System.out.print("true");
        else
            System.out.print("false");
    }
}

class Graph {
    // This class represents an undirected graph using adjacency list representation
    int V; // No. of vertices
 
    // Pointer to an array containing adjacency lists
    ArrayList<ArrayList<Integer>> adj;
 
    Graph(int V){
        this.V = V;
        adj = new ArrayList<>();
        for(int i = 0; i < V; i++)
            adj.add(new ArrayList<>());
    }
 
    // function to add an edge to graph
    void addEdge(int v, int w)  {
        adj.get(v).add(w);
        adj.get(w).add(v);
    }
 
 
    // A BFS based function to check whether d is reachable from s.
    boolean isReachable(int s, int d) {
        // Base case
        if (s == d)
            return true;
 
        // Mark all the vertices as not visited
        boolean[] visited = new boolean[V];
        for (int i = 0; i < V; i++)
            visited[i] = false;
 
        // Create a queue for BFS
        Queue<Integer> queue = new LinkedList<>();
 
        // Mark the current node as visited and enqueue it
        visited[s] = true;
        queue.add(s);
 
        while (!queue.isEmpty()) {
            // Dequeue a vertex from queue and print it
            s = queue.remove();
 
            // Get all adjacent vertices of the dequeued vertex s If a adjacent has not been visited, then mark it
            // visited  and enqueue it
            for (int i=0; i<adj.get(s).size();i++) {
 
                // If this adjacent node is the destination node, then return true
                if (adj.get(s).get(i) == d)
                return true;
 
                // Else, continue to do BFS
                if (!visited[adj.get(s).get(i)]) {
                    visited[adj.get(s).get(i)] = true;
                    queue.add(adj.get(s).get(i));
                }
            }
        }
        // If BFS is complete without visiting d
        return false;
    }
}

anothers approach

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class graph{
    int n;
    ArrayList<Integer> list[];
    graph(int n){
    this.n=n;
    list=new ArrayList[n];

    for(int i=0;i<n;i++)
        list[i]=new ArrayList<>();
    }
    public void add(int u,int v){
        list[u].add(v);
        list[v].add(u);
    }
    public boolean[] doDFS(int ind) {
        boolean vis[] = new boolean[n];
                            
        dfs(ind, vis);

                return vis;
        }
    public void dfs(int u, boolean vis[]){
        if(vis[u])
         return;

         vis[u]=true;
         for(Integer v:list[u]){
             if(!vis[v])
                dfs(v,vis);
         }
    }
}

class Main {
    public static void main (String[] args) {
                      // Your code here
                      Scanner sc=new Scanner(System.in);
                      int v=sc.nextInt();
                      int e=sc.nextInt();
                      graph gh=new graph(v);
                      for(int i=0;i<e;i++)
                      {
                          int a=sc.nextInt();
                          int b=sc.nextInt();
                          gh.add(a,b);
                      }
                      int a=sc.nextInt();
                      int b=sc.nextInt();
                      boolean vis[]=gh.doDFS(a);
                      if(vis[b])
                      System.out.println("true");
                      else
                        System.out.println("false");
    }
}


Dynamic Programing

Expected Number hard https://cf.nytdoj.com/problemset/problem/1097/D   https://codeforces.com/contest/1097/submission/49331913
You have a number n written on board. You apply k operations on it. Suppose the number
written on the board is v, then in one operation you will randomly choose one of its divisor and replace v with it.
What is the expected value of number on board after k operations, modulo 10^9 + 7.
(Read modulo inverse for getting clear idea of the output format)
Input The only line of the input contains two integers n and k 1<=n<=10^15  0<=k<=10000
Output Print a single integer — the expected value of the number on the blackboard after k steps
It can be shown that this value can be represented as P/Q where P and Q are coprime integers and Q!=0 (mod10^9+7).
Print the value of P⋅Q^−1 modulo 10^9+7.
Example
Sample Input6 1
Sample Output 3
Sample Input 6 2
Sample Output 875000008 

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        // Scanner sc = new Scanner(System.in);
        // int n = sc.nextInt();
        // int k = sc.nextInt();
        try {
            new Main().solve();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    long n;
    int k,mod=1000000007;
    long[]inv;
    private void solve() throws Exception {
        InputReader in = new InputReader(System.in);
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        n = in.nextLong();
        k = in.nextInt();
        inv=getInvs(100,mod);
        long ans=1;
        for(long i=2;i*i<=n;i++){
            int cnt=0;
            while(n%i==0){
                cnt++;n/=i;
            }
            if(cnt!=0){
                ans*=getExpection(i,cnt);
                ans%=mod;
            }
        }
        if(n!=1)ans=(ans*getExpection(n,1))%mod;
        out.println(ans);
        out.flush();
    }
        private long getExpection(long num,int pow){
        long[]dp=new long[pow+1];
        dp[pow]=1;
        for(int i=0;i<k;i++) {
            long tmp = 0;
            for (int j = pow; j >= 0; j--) {
                tmp=(tmp+dp[j]*inv[j+1]%mod)%mod;
                dp[j] = tmp;
            }
        }
        long ans=0,x=1;
        for(int i=0;i<=pow;i++){
            ans+=x*dp[i]%mod;
            ans%=mod;
            x*=num;
            x%=mod;
        }
        return ans;
    }
    public static long[] getInvs(int n,int mod){
        long[]inv=new long[n+1];
        inv[1]=1;
        for(int i=2;i<inv.length;i++)
            inv[i]=(mod-mod/i)*inv[mod%i]%mod;
        return inv;
    }
    
}

class InputReader{
    StreamTokenizer tokenizer;
    public InputReader(InputStream stream){
        tokenizer=new StreamTokenizer(new BufferedReader(new InputStreamReader(stream)));
        tokenizer.ordinaryChars(33,126);
        tokenizer.wordChars(33,126);
    }
    public String next() throws IOException {
        tokenizer.nextToken();
        return tokenizer.sval;
    }
    public int nextInt() throws IOException {
        return Integer.parseInt(next());
    }
    public long nextLong() throws IOException {
        return Long.parseLong(next());
    }
    public double nextDouble() throws IOException {
        return Double.parseDouble(next());
    }
    public boolean hasNext() throws IOException {
        int res = tokenizer.nextToken();
        tokenizer.pushBack();
        return res != tokenizer.TT_EOF;
    }
}



Catalan Numbers medium
Given a number N. The task is to find the Nth Catalan number.
The first few Catalan numbers for N = 1, 2, 3, … are 1, 2, 5, 14, 42, 132, 429, 1430, 4862, …
You can read more about Catalan numbers here.
Input The first line of input contains a single integer T which denotes the number of test cases. The first line of each test case contains a single integer N.
Constraints:1 <= T <= 100000 1 <= N <= 1000000
Output For each test case, in a new line print the Catalan number at position N.
Since the answer can be large, print answer modulo (10^9 + 7)
Example
Sample Input:
3
5
4
10
Sample Output:
42
14
16796

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
import java.math.*;

class Main {
    static long[] dp = new long[1000002];
    static long mod = 1000000007;

    static long modPower(long x, long n){
        if(n == 0) return 1;
        if(n == 1) return x;
        if(n % 2 == 0) return modPower((x * x) % mod, n / 2) % mod;
        return (x * modPower((x * x) % mod, n / 2)) % mod;
    }
    
    public static void main (String[] args) throws IOException{
        BufferedReader br =new BufferedReader(new InputStreamReader(System.in));
        int tesCases = Integer.parseInt(br.readLine());        
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 1; i <= 1000000; i++){
            dp[i+1] = ( ((4 * i + 2) % mod * dp[i]) % mod * modPower( i + 2, mod - 2) ) % mod;
        }

        for(int i = 0; i < tesCases; i++){
            int n = Integer.parseInt(br.readLine());
            System.out.println(dp[n]);
        }    
    }

    /*static long catalanNumberR(long n) { 
        long res = 0; 
        if (n <= 1)  return 1; 
    
        for (int i = 0; i < n; i++) { 
            res += catalanNumberR(i) * catalanNumberR(n - i - 1); 
        } 
        return res; 
    } 
    public static long catalanNumber1(long n){
        long[] dp = new long[(int)n + 1];
        dp[0] = 1;
        dp[1] = 1;

        for(long i = 2 ;i < dp.length; i++){
            for(long j = 0 ; j < i; j++){
                dp[(int)i] += dp[(int)j] * dp[(int)(i - j - 1)]; 
            }
        }  
        
        return dp[(int)n];
    }*/
}

0-1 Knapsack Proble medium   https://www.youtube.com/watch?v=ywiH-zRH1mA&t=460s
Problem Statement https://medium.com/@fabianterh/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf
You are given weights and values of N items, put some or all of these items in a knapsack of capacity W weight to get the maximum total value in the knapsack. Note that we have at most one quantity of each item.
In other words, given two integer arrays val[0..(N-1)] and wt[0..(N-1)] which represent values and weights associated with N items respectively. Also given an integer W which represents knapsack capacity, find out the maximum value subset of val[] such that sum of the weights of this subset is smaller than or equal to W. You cannot break an item, either pick the complete item, or don’t pick it (0-1 property).
InputThe first line of input contains an integer T denoting the number of test cases. Then T test cases follow. Each test case consists of four lines.
The first line consists of N the number of items. 
The second line consists of W, the maximum capacity of the knapsack.
In the next line are N space separated positive integers denoting the values of the N items,
and in the fourth line are N space separated positive integers denoting the weights of the corresponding items.
Constraints:
1 ≤ T ≤ 100
1 ≤ N ≤ 1000
1 ≤ W ≤ 1000
1 ≤ wt[i] ≤ 1000
1 ≤ v[i] ≤ 1000
Output
For each testcase, in a new line, print the maximum possible value you can get with the given conditions that you can obtain for each test case in a new line.
Example
Input:
2
3
4
1 2 3
4 5 1
3
3
1 2 3
4 5 6
Output:
3
0
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) throws IOException{
        BufferedReader reader =new BufferedReader(new InputStreamReader(System.in));
        //Scanner sc = new Scanner(System.in);
        int testCases = Integer.parseInt(reader.readLine());
        for(int t = 0 ; t < testCases; t++){
            int noOfItem = Integer.parseInt(reader.readLine());
            int capacityKS = Integer.parseInt(reader.readLine());

            //System.out.println("capacity " + capacityKS);
            int[] values = new int[noOfItem];
            
            String str1 = reader.readLine();
            String[] s1 = str1.split(" ");
             
            for(int i = 0; i < noOfItem; i++){
                values[i] = Integer.parseInt(s1[i]);
            }

            int[] weight = new int[noOfItem];
            String str2 = reader.readLine();
            String[] s2 = str2.split(" ");
            for(int j = 0; j < noOfItem; j++){
                weight[j] = Integer.parseInt(s2[j]);
            }
            //System.out.println(knapSackSolution2(capacityKS, weight, values, noOfItem));
            System.out.println(knapsackR(weight,values, noOfItem, capacityKS));
        }
           
    }
    static int knapsackR(int[] wt,int[] val, int n, int W){
        int prev[] = new int[W+1];
        //Base Condition
        for(int i = wt[0]; i <= W; i++){
            prev[i] = val[0];
        }
        for(int ind = 1; ind < n; ind ++){
            for(int cap = W; cap >= 0; cap--){
                int notTaken = prev[cap];
                int taken = Integer.MIN_VALUE;
                if(wt[ind] <= cap)
                    taken = val[ind] + prev[cap - wt[ind]];
                prev[cap] = Math.max(notTaken, taken);
            }
        }
        return prev[W];
    }
}

    // //tabulation
    // public static int knapSackSolution(int capcity,int weight[],int[] values, int noOfItem){
    //     int dp[][] = new int[noOfItem + 1][capcity + 1];
    //     for(int i = 1; i < dp.length; i++){
    //         for(int j = 1; j < dp[0].length ;j++){
    //             if( j >= weight[i - 1]){
    //                 int remainingCapacity = j - weight[i - 1];
    //                 if(dp[i - 1][remainingCapacity] + values[i - 1] > dp[i - 1][j]){
    //                     dp[i][j] = dp[i - 1][remainingCapacity] + values[i - 1];
    //                 }else{
    //                     dp[i][j] = dp[i - 1][j];
    //                 }
    //             }else{
    //                 dp[i][j] = dp[i - 1][j];
    //             }
    //         }
    //     }
    //         return dp[noOfItem][capcity];
    // }
/*
    ///Using recusion/ Returns the value of maximum profit  
    static int knapSackRec(int capacity, int wt[], int val[], int n, int [][]dp){  
        // Base condition
        if (n == 0 || capacity == 0)  
            return 0;
            
        if (dp[n][capacity] != -1)
            return dp[n][capacity];  
        
        if (wt[n - 1] > capacity)  
            // Store the value of function call  stack in table before return
            return dp[n][capacity] = knapSackRec(capacity, wt, val, n - 1, dp);
        else
            // Return value of table after storing 
            return dp[n][capacity] = Math.max((val[n - 1] + knapSackRec(capacity - wt[n - 1], wt, val, n - 1, dp)),
                                                knapSackRec(capacity, wt, val, n - 1, dp));            
    }
 */
  /*Scanner sc = new Scanner(System.in);
            int testCases = sc.nextInt();
            for(int t = 0 ; t < testCases; t++){
                int n = sc.nextInt();
                int w = sc.nextInt();
                
                int[] val = new int[n];
                int[] wt = new int[n];

                for(int i = 0; i < n; i++){
                    val[i] = sc.nextInt();
                }
                for(int j = 0; j < n; j++){
                    wt[j] = sc.nextInt();
                }
 
                int[][] mat = new int[n + 1][w + 1];
                for (int r = 0; r < w + 1; r++) {
                    mat[0][r] = 0;
                }
                for (int c = 0; c < n + 1; c++) {
                    mat[c][0] = 0;
                }
                
                // Main logic
                for (int item = 1; item <= n; item++) {
                    for (int capacity = 1; capacity <= w; capacity++) {
                        int maxValWithoutCurr = mat[item - 1][capacity]; // This is guaranteed to exist
                        int maxValWithCurr = 0; // We initialize this value to 0
                        
                        int weightOfCurr = wt[item - 1]; // We use item -1 to account for the extra row at the top
                        if (capacity >= weightOfCurr) { // We check if the knapsack can fit the current item
                            maxValWithCurr = val[item - 1]; // If so, maxValWithCurr is at least the value of the current item
                            
                            int remainingCapacity = capacity - weightOfCurr; // remainingCapacity must be at least 0
                            maxValWithCurr += mat[item - 1][remainingCapacity]; // Add the maximum value obtainable with the remaining capacity
                        }
                        
                        mat[item][capacity] = Math.max(maxValWithoutCurr, maxValWithCurr); // Pick the larger of the two
                    }
                }
                
                System.out.println(mat[n][w]); // Final answer
                //System.out.println(Arrays.deepToString(mat)); // Visualization of the table
            }*/


Make Palindrome medium
You are given a string S of size N. Print the minimum number of characters that need to be deleted so that the resulting string (without changing the relative order of characters ) is palindrome.
Note: A palindrome is string that read same forward and backward eg : bccb, f, sas.
Input First line : A single integer N denoting size of array
Second line : a string denoting S
1<=N<=10^3
String S contains only lowercase English letters
OutputA single integer denoting the answer
Example Input:5
bccdb
Output: 1
Explanation: Deleting character 'd', results in "bccb" which is palindromic

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    static String str;
    static int dp[][] = new int[1005][1005];
    // this with recurrsion only and applying dp
    public static int makePalidrome(int start, int end){
        if(start > end) return 0;
        //applying dp storing the recusion state
        if(dp[start][end] != 0)
            return dp[start][end];

        if(str.charAt(start) == str.charAt(end))
            return dp[start][end] = makePalidrome(start + 1, end - 1);
        
        return dp[start][end] = 1 + Math.min(makePalidrome(start, end -1), makePalidrome(start + 1, end));
    }

    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        sc.nextLine();
        str = sc.nextLine();

        int ans = makePalidrome(0, n-1);
        System.out.println(ans);
    }
}

Longest Palindrome in a String medium  https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/   ---  https://www.youtube.com/watch?v=XmSOWnL6T_I
Given a string S, find the longest palindromic substring in S. Substring of string S: S[ i . . . . j ] where 0 ≤ i ≤ j < len(S). Palindrome string: A string which reads the same backwards. More formally, S is palindrome if reverse(S) = S. If there are multiple such substrings, return the substring which occurs first (with the least starting index).
NOTE: Required Time Complexity O(n^2).
Input consist of a single line containing the string S
1 <= length of S <= 100
OutputPrint the longest palindrome of the string given .
ExampleInput:aaaabbaa
Output: aabbaa

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();
        longestPalSubstr(str);
		//System.out.println();
    }

    static void printSubStr(String str, int low, int high){
		System.out.println( str.substring(low, high + 1));
	}

    // This function prints the longest palindrome substring of str[]. It also returns the length of the longest palindrome
	static void longestPalSubstr(String str){
		// get length of input string
		int n = str.length();

		// table[i][j] will be false if substring str[i..j] is not palindrome. Else table[i][j] will be true
		boolean table[][] = new boolean[n][n];

		// All substrings of length 1 are palindromes
		int maxLength = 1;
		for (int i = 0; i < n; ++i)
			table[i][i] = true;

		// check for sub-string of length 2.
		int start = 0;
		for (int i = 0; i < n - 1; ++i) {
			if (str.charAt(i) == str.charAt(i + 1)) {
				table[i][i + 1] = true;
				start = i;
				maxLength = 2;
			}
		}

		// Check for lengths greater than 2. k is length of substring
		for (int k = 3; k <= n; ++k) {

			// Fix the starting index
			for (int i = 0; i < n - k + 1; ++i) {
				// Get the ending index of substring from starting index i and length k
				int j = i + k - 1;

				// checking for sub-string from ith index to jth index iff str.charAt(i+1) to
				// str.charAt(j-1) is a palindrome
				if (table[i + 1][j - 1]
					&& str.charAt(i) == str.charAt(j)) {
					table[i][j] = true;

					if (k > maxLength) {
						start = i;
						maxLength = k;
					}
				}
			}
		}
		//System.out.print("Longest palindrome substring is; ");
		printSubStr(str, start,	start + maxLength - 1);

		// return length of LPS
		//return maxLength;
	}
}



Minimum path sum in triangle medium
Given a triangular structure of numbers. Find the minimum of the sum of numbers that appear on the paths starting from the top towards the base, so that on each path the next number is located directly below or below-and-one-place-to-the-right. (Given: The triangle is right-angled isosceles, with equal sides having N elements.)
Note:-size of each row is equal to its row number.eg of triangular structure:-
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
1 2 3 4 5 6
Input The input line contains T, denoting the number of testcases. Each testcase contains single line i.e. N
The next N lines contains the elements of each row in each line.
Constraints:1 <= T <= 15  1<= N <=50 1<= triangle[i][j ]<=1000 (for all 0<=i
Output the single integer denoting the result.
Input:
2
4
2
3 4
6 5 7
4 1 8 3
3
1
3 4
6 10 7
Output:
11
10

Explanation:
Testcase 1: The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).


import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
public static int miniPathSum(int arr[][], int n){
    int dp[][] = new int[n][n];
    //fiiling first rows of dp with sams as arr rows
    dp[0][0] = arr[0][0];

    //loop stating from nest rows thatswhay starting from 1
    for(int i = 1; i < n; i++){
        // this first coloum of any row to reach the end this is the nonly way to get their and get the sum 
        // filling the 
        dp[i][0] = arr[i][0] + dp[i - 1][0];
        /// j = 0 handle ise hi kiya hai and starting colum 1 se
        for(int j = 1; j <= i; j++){
            // by default array me zero aayega kisibhi coloum me so thay why we have to coamre i== j thaki end me kya value hai ya nhi
            // nahi to min zero milega so thay why comapre the last value with previous left one value not ecaxt upper vaki se compare mat kro
            // i - 1 matlab upper wali row and j - 1 matlab uske left wali value
            // dp[i - 1][j] upper wala
            if(i == j){
                dp[i][j] = arr[i][j] + dp[i - 1][j - 1];    
            }else{
                dp[i][j] = arr[i][j] + Math.min(dp[i - 1][j - 1], dp[i - 1][j]);
            }
        }
    }
    //int ans = 999999999; i =0
    int ans = dp[n-1][0];
    for(int i = 1; i < n; i ++){
        // find the mimimu value in the last row 
        ans = Math.min(ans, dp[n - 1][i]);
    }
    return ans;
}

    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int testCases = sc.nextInt();

        for(int t = 0; t < testCases; t++ ){
            int rows = sc.nextInt();
            int arr[][] = new int[rows][rows];
            for(int i = 0; i < rows ; i++){
                for(int j = 0; j <= i ; j++){
                    arr[i][j] = sc.nextInt();
                }
            }

            System.out.println(miniPathSum(arr,rows));
        }
    }
}

Collect the coinseasy You are given an array of N numbers, the numbers represent value of coin and you are required to collect some coins from the array. But there is one condition, if you take the coin at index i, you cannot take the coin at index (i-1) & (i+1).
Tell the maximum sum value of coins that you can collect from the array.
First line of input contains a number N, the size of array. The next line will have N numbers, value of coin at each index in the array.
Constraints: 1 <= N <= 10^4 0 <= value of coins <= 10^9
Output Print X, where X is the maximum sum of value of coins you can collect.
ExampleSample input
5
1 2 3 4 5
Sample output
9
Sample input
5
2 1 20 30 5
Sample output32
Explanation:Testcase 1:Now we can have two ways to collect coins as per the condition given, let us see what are they then find which way will give us the maximum coins:
1st: 1 + 3 + 5 = 9
2nd: 2 + 4 = 6.
From the above we can see that the 1st approach of collecting coins will give us the maximum, thus answer for the above sequence is 9.
//Sir implemtaton code id fine but failing sor said its fine 
// recusive relation top to bottom

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    //
    static int n;
    static long arr[] = new long[100005];
    static long dp[] = new long[100005];
    //static HashMap<Integer,Long> dp = new HashMap<>(); 
    
    public static long maximumSumCoins(int index){
        if (index >= n) return 0;

        if(dp[index] != 0){
            return dp[index];
        }
        dp[index] = Math.max(maximumSumCoins(index + 1), arr[index] + maximumSumCoins(index + 2));
        //if(dp.containsKey(index))
        //    return dp.get(index);
        //long ans = Math.max(arr[index] + maximumSumCoins(index + 2), maximumSumCoins(index + 1)); 
        //dp.put(index, ans);
        return dp[index];
    }
    
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        for(int i = 0; i < n; i++){
            arr[i] = sc.nextLong();
        }
        long ans = maximumSumCoins(0);
        System.out.println(ans);

    }
}
//above same code run c++ toptobtton memoizatiom
#include<iostream>
using namespace std;

int n;
long long int arr[100005];
long long int dp[100005];

long long int maximumSumCoins(int index){
    if (index >= n) return 0;
    if(dp[index] != 0){
        return dp[index];
    }
    dp[index] = max(maximumSumCoins(index + 1), arr[index] + maximumSumCoins(index + 2));
    return dp[index];
}
    
int main(){
    cin>>n;
    for(int i = 0; i < n; i++){
        cin>> arr[i];
    }
    long ans = maximumSumCoins(0);
    cout<<ans;
}
third aaproach of this using tabulation of dp botton up appraoch 
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    static int n;
    static long arr[] = new long[100005];
    static long dp[] = new long[100005];

    // Tabulation appraoch bottom up
    public static long maximumSumCoins(int index){
        dp[0] = arr[0];
        dp[1] = Math.max(arr[0], arr[1]);

        for(int i = 2; i<n; i++){
            dp[i] = Math.max(dp[i - 1], arr[i] + dp[i - 2]);
        }
        return dp[n -1];
    }

    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        for(int i = 0; i < n; i++){
            arr[i] = sc.nextLong();
        }
        long ans = maximumSumCoins(0);
        System.out.println(ans);
    }
}


Sunday Walk easy  https://www.geeksforgeeks.org/probability-reaching-point-2-3-steps-time/
Jenny was walking along the beach on a Sunday evening. She started from a point 0 and wants to reach a point N. What is the probability that she reaches exactly on point N, if she can only take 2 steps or 3 steps? Probability for step length 2 is P and probability for step length 3 is 1 – P.
Input The first line of the input contains n and p.
Constraints
1<= n <= 1e5
0 <= p <= 1
Output Print the final probability upto 2 decimal places.
Example Sample Input 5 0.2
Sample Output  0.32
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        float p = sc.nextFloat();

        System.out.printf("%.2f",findProbability(N, p));

    }
    static float findProbability(int N, float P){
        double dp[] = new double[N + 1];
        dp[0] = 1;
        dp[1] = 0;
        dp[2] = P;
        dp[3] = 1 - P;
     
        for (int i = 4; i <= N; ++i)
          dp[i] = (P) * dp[i - 2] + (1 - P) * dp[i - 3];
     
        return ((float)(dp[N]));
    }    
}


Assignment CSS, Input types, Input attributes, Input type button, Input type checkbox, Inpu ... - Post Class

Pattern making (debugging)Easy
Given an integer n, your task is to print the pattern as shown in example:-
For n=5, the pattern is:
1
1 2 1
1 2 3 2 1
1 2 3 4 3 2 1
1 2 3 4 5 4 3 2 1
1 2 3 4 3 2 1
1 2 3 2 1
1 2 1
1
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function pattern_making() that takes the integer n as parameter.
Constraints:-1 <= n <= 100
OutputPrint the pattern as shown.Example
Sample Input:-5
Sample output:-
1
1 2 1
1 2 3 2 1
1 2 3 4 3 2 1
1 2 3 4 5 4 3 2 1
1 2 3 4 3 2 1
1 2 3 2 1
1 2 1
1
Sample Input:-2

Sample Output:-
1
1 2 1
1

public static void pattern_making(int n){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            System.out.print(j+" ");
        }
        for(int j=i-1;j>=1;j--){
            
            System.out.print(j+" ");
        }
        System.out.println();
    }

    for(int i=n-1;i>=1;i--){
        for(int j=1;j<=i;j++){
            
            System.out.print(j+" ");
        }
        for(int j=i-1;j>=1;j--){
            
            System.out.print(j+" ");
        }
        System.out.println();
    }
}


Pattern Printing
Given a positive integer N, your task is to print a right angle triangle pattern of consecutive numbers of height N.For N = 5, the following pattern is printed.
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function pattern() that takes integer n as a parameter.
Constraint:1 <= N <= 100
OutputPrint a right angle triangle of numbers of height N.
Example
Sample Input:5
Sample Output:
1
1 2
1 2 3
1 2 3 4
1 2 3 4 5
Sample Input:2
Sample Output:
1
1 2
static void pattern(int n){
  //enter your code here
   int i,j;
   for(i = 1; i <= n ;i++)   {
	    for(j = 1; j <= i; j++)
    	  System.out.print(j + " ");

        System.out.println(" ");
    }
}



Heap Sort Assignment
 
Maximum Count of pairs medium
Given an array arr your task it to count maximum number of pairs that can be formed such that ith index is included in almost arr[i] pairs.
First line of input contains n, length of arr, Next line conatins input of an array arr.
Constraints 1 <= n <= 300 -300<= arr[i] <=300
Output find the maximum number of pairs that can be formed such that ith index is included in almost arr[i] pairs.
Input:
4
2 2 3 4
Output:
5
1 3
2 4
2 4
3 4
3 4
Explaination: For the given array, a maximum of 5 pairs can be created where 1st index is included in 1 pair, 2nd index in 2 pairs, 3rd index in 3 pairs and 4th index in 4 pairs as shown above

#include <bits/stdc++.h>
using namespace std;
#ifdef LOCAL
#define debug(...) cerr << "[" << #_VA_ARGS_ << "]:", debug_out(_VA_ARGS_)
#else
#define debug(...) 2351
#endif
int main() {
#ifdef LOCAL
    auto start = std::chrono::high_resolution_clock::now();
#endif
    ios::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin >> n;
    vector<int> arr;
    vector<pair<int, int>> a;
    for (int i = 0; i < n; i++) {
        int temp;
        cin >> temp;
        arr.push_back(temp);
        a.push_back({temp, i});
    }
    auto compare = [](pair<int, int>& x, pair<int, int>& y) {
        return x.first < y.first;
    };
    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(compare)> pq(compare);
    for (int i = 0; i < n; i++) {
        if (a[i].first > 0) {
            pq.push(a[i]);
        }
    }
    vector<pair<int, int>> res;
    while (pq.size() >= 2) {
        int top = pq.top().second;
        pq.pop();
        int cur = pq.top().second;
        pq.pop();
        res.push_back({top + 1, cur + 1});
        arr[top]--;
        arr[cur]--;
        if (arr[top] > 0)
            pq.push({arr[top], top});
        if (arr[cur] > 0)
            pq.push({arr[cur], cur});
    }
    cout << res.size() << "\n";
    for (auto& it : res) {
        cout << it.first << " " << it.second << "\n";
    }
#ifdef LOCAL
    auto stop = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start);
    cerr << "Time taken : " << ((long double)duration.count()) / ((long double)1e9) << "s " << endl;
#endif
    return 0;
}

/*import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Pair{
    int val;
    int freq;

    Pair(int val, int freq){
        this.val = val;
        this.freq = freq;
    }

    public int getFreq(){
        return this.freq;
    }

    public String toString(){
        return this.val + " " + this.freq;
    }
}
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i < n ; i++){
            arr[i] = sc.nextInt();
        }
        maxPairs(arr);

        //Sir approach
        /*PriorityQueue<ArrayList<Integer>> pq = new PriorityQueue<>(Comparator.comparing(Pair :: getFreq));
        for(int i = 0; i < n; i++){
            int x = sc.nextInt();
            //ArrayList<Integer> list = new ArrayList<>();
            pq.add(new Pair(i + 1, x));
        }

        while(!pq.isEmpty()){
            Pair pair = pq.poll();
            System.out.println(pair);
        }

        ArrayList<Pair> pairs = new ArrayList<>();
        while(!pq.isEmpty()){
            Pair p1 = pq.poll();
            Pair p2 = pq.poll();
            pairs.add(new Pair(p1.val, p2.val));

            p1.freq --;
            p2.freq --;

            if(p1.freq > 0)
                pq.add(p1);
            if(p2.freq > 0)
                pq.add(p2);
        }

        System.out.println(pairs.size());

        for(Pair pr : pairs){
            System.out.println(pr);
        }
    }

    // public static int customCompare(Integer p1, Integer p2){
    //     return Integer.compare(p1,p2);
    // }

      public static void maxPairs(int arr[]) {
        // Stores the final list of pairs required
        List<Integer> matchList = new ArrayList<>();
        // Max Priority Queue to store induced in order of their array value
        PriorityQueue<Integer> pq = new PriorityQueue<>((x, y) -> arr[y] - arr[x]);
        // Loop to iterate arr[]
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] > 0)
                pq.add(i);
        }
  
        // Loop to iterate pq till it has more than 2 elements
        while (pq.size() >= 2) {
            // Stores the maximum
            int top = pq.poll();
            // Stores the second maximum
            int cur = pq.poll();
            // Insert pair into the final list
            matchList.add(top + 1);
            matchList.add(cur + 1);
            arr[top]--;
            arr[cur]--;
  
            if (arr[top] > 0)
                pq.add(top);
  
            if (arr[cur] > 0)
                pq.add(cur);
        }
  
        // Print Answer
        System.out.println(matchList.size() / 2);
        for (int i = 0; i < matchList.size(); i += 2) {
            System.out.println(matchList.get(i + 1) + " " + matchList.get(i));
        }
    }
}*/

Find median in a stream Medium https://www.youtube.com/watch?v=Yv2jzDzYlp8  and https://www.geeksforgeeks.org/median-of-stream-of-running-integers-using-stl/
Given an input stream of N integers. The task is to insert these numbers into a new stream and find the median of the stream formed by each insertion of X to the new stream.
Note: Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle values.
Input User Task:Since this will be a functional problem, you don't have to take input. You just have to complete the function
getMedian() that takes X as parameter.
Constraints:
1 <= N <= 10^5
1 <= X <= 10^5
OutputYou need to return the median.
Example Sample Input:
4
5
15
1
3
Sample Output:
5.0
10.0
5.0
4.0
Explanation:
Testcase 1:
Flow in stream : 5, 15, 1, 3
5 goes to stream --> median 5.0 (5)
15 goes to stream --> median 10.0 (5, 15)
1 goes to stream --> median 5.0 (5, 15, 1)
3 goes to stream --> median 4.0 (5, 15, 1, 3)

// Function to getMedian
static PriorityQueue<Integer> maxHeap = new PriorityQueue(Collections.reverseOrder()); //containing first
static PriorityQueue<Integer> minHeap = new PriorityQueue<>();//containing second half of number

public static double getMedian(int X){
   //inseting the element in PriorityQueue
   if(maxHeap.isEmpty() || maxHeap.peek() >= X)
      maxHeap.add(X);
   else
      minHeap.add(X);
   
   //either both the heaps will have equal number of element or maxheap will have one
   //more element than the min-heap
   if(maxHeap.size() > minHeap.size() + 1)
      minHeap.add(maxHeap.poll());
   else if(maxHeap.size() < minHeap.size())
      maxHeap.add(minHeap.poll());

   if(maxHeap.size() == minHeap.size()){
      return maxHeap.peek() / 2.0 + minHeap.peek() / 2.0;
   } 
   return maxHeap.peek();
}


Kth largest element Easy  https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/2414755/Java-Priority-Queue
Given an array arr[] of N positive integers and a number K. The task is to find the kth largest element in the array.
Note: DO NOT USE sort() stl.
Input First line of input contains number of testcases. For each testcase, there will be a single line of input containing number of elements in the array and K. Next line contains N elements.
Constraints:
1 <= T <= 100
1 <= N <= 10^4
1 <= arr[i] <= 10^5
1 <= K <= N
Output
For each testcase, print a single line of output containing the kth largest element in the array.
Example
Sample Input:
2
5 3
3 5 4 2 9
5 5
4 3 7 6 5

Sample Output:
4
3

Explanation:
Testcase 1: Third largest element in the array is 4.
Testcase 2: Fifth largest element in the array is 3.
class Main {
    public static void main (String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        while(t-- > 0){
            String[] st1 = br.readLine().split(" ");
            int n = Integer.parseInt(st1[0]);
            int k = Integer.parseInt(st1[1]);

            int[] arr = new int[n];
            String[] st2 = br.readLine().split(" ");
            for(int i=0; i<n; i++){
                arr[i] = Integer.parseInt(st2[i]);
            }
            System.out.println(findKthLargest(arr, k)) ;
        }   
    }

    public static int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        for(int i=0;i<k;i++){
            pq.add(nums[i]);
        }
        for(int i=k;i<nums.length;i++){
            if(pq.peek() < nums[i]){
                pq.poll();
                pq.add(nums[i]);
            }
        }
        return pq.peek();
    }
}
Another approach
class Main {
   public static void main (String[] args)throws IOException {
BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
             int tc=Integer.parseInt(br.readLine());
            while(tc -- > 0){
               String st=br.readLine();
               String[]a=st.split(" ");
               int n=Integer.parseInt(a[0]);
               int k=Integer.parseInt(a[1]);

                String str=br.readLine();
                String arr[]=str.split(" ");
                PriorityQueue<Integer>pq=new PriorityQueue<>();
                for(int i=0;i<n;i++){
                   // int elmt=Integer.parseInt(arr[i]);
                    pq.add(Integer.parseInt(arr[i]));
                }
                    int ans=0;
                    for(int i=0;i<n-k+1;i++){
                        ans=pq.poll();
                    }
                    System.out.println(ans);
                }      
    }
}



K Most occurring elements Medium -- https://www.geeksforgeeks.org/find-k-numbers-occurrences-given-array/
Given an array arr[] of N integers in which elements may be repeating several times. Also, a positive number K is given and the task is to find sum of total frequencies of K most occurring elements
Note: The value of K is guaranteed to be less than or equal to the number of distinct elements in arr. Input First line of input contains number of testcases T. For each testcase, first line of input contains the size of array N, and next line contains N positive integers. The last line contains K.
Constraints: 1 <= T <= 100 1 <= K <= N 1 <= N <= 10^4  1 <= arr[i] <= 10^6
Output For each testcase, print the sum of total frequencies of K most occurring elements in the given array.
Example Sample Input:
2
8
3 1 4 4 5 2 6 1
2
8
3 3 3 4 1 1 6 1
2
Sample Output:
4
6
Explanation:
Testcase 1: Since, 4 and 1 are 2 most occurring elements in the array with their frequencies as 2, 2. So total frequency is 2 + 2 = 4.
Testcase 2: Since, 3 and 1 are most occurring elements in the array with frequencies 3, 3 respectively. So, total frequency is 6.

class Main {
    public static void main (String[] args) throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        while(t-- > 0){
            int n = Integer.parseInt(br.readLine());
            String s = br.readLine();
            int[] arr = new int[n];
            String[] s1 = s.split(" ");
            for(int i = 0; i < n; i++){
                arr[i] = Integer.parseInt(s1[i]);
            }
            int k = Integer.parseInt(br.readLine());

            getMostFrequentNum(arr, k);
        }
    }
    static void getMostFrequentNum(int[] arr, int k){
        Map<Integer, Integer> mp = new HashMap<Integer, Integer>();
        // Put count of all the distinct elements in Map with element as the key & count as the value.
        for (int i = 0; i < arr.length; i++) {
            // Get the count for the element if already present in the Map or get the default value which is 0.
            mp.put(arr[i],
                   mp.getOrDefault(arr[i], 0) + 1);
        }
 
        // Create a Priority Queue to sort based on the  count or on the key if the count is same
        PriorityQueue<Map.Entry<Integer,Integer>> queue = new PriorityQueue<>((a, b) -> a.getValue().equals(b.getValue())
                   ? Integer.compare(b.getKey(),
                                     a.getKey())
                   : Integer.compare(b.getValue(),
                                     a.getValue()));
 
        // Insert the data from the map to the Priority Queue.
        for (Map.Entry<Integer, Integer> entry : mp.entrySet())
            queue.offer(entry);
 
        // Print the top k elements
        int sumMostOcurr = 0;
        for (int i = 0; i < k; i++){
            sumMostOcurr += queue.poll().getValue();
        }
        System.out.println(sumMostOcurr);
    }
}

Another solution 
class Main {
    public static void main (String[] args) throws IOException{
    	InputStreamReader s  =  new InputStreamReader( System.in ) ;
	  	BufferedReader    br =  new BufferedReader( s ) ;
					  int t = Integer.parseInt ( br.readLine().trim() ) ;  
                      while ( t > 0 ) {
                           int n = Integer.parseInt( br.readLine() ) ;
                           String input[] = br.readLine().trim().split(" ");
                           int arr[] = new int[ n ] ;
                           for(int i=0; i<n; i++) arr[i] = Integer.parseInt(input[i]);
                           int k = Integer.parseInt( br.readLine().trim() ) ;
                           find ( arr , n , k ) ;
                          t-- ;
                      }
    }
    public static void find(int arr[], int n, int k ) {
        HashMap < Integer , Integer > m = new HashMap <> () ;
        for ( int i=0; i < n ; i++ ) {
            m.put ( arr[i] , m.getOrDefault ( arr[i] , 0 ) + 1) ;
        }

        //Adding frequency to The PriorityQueue
        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());
        for(Map.Entry<Integer,Integer> m2: m.entrySet()){
            int x = (int)m2.getValue();
            pq.add(x);
        }
        int ans=0,a=0;
       while ( k > 0 ) {
           a = pq.poll(); 
           ans += a ;  
           k-- ;
       }
       System.out.println(ans);
    }
}



Kth smallest element Easy https://www.geeksforgeeks.org/kth-smallestlargest-element-unsorted-array/ -- Method 7 using max heap
Given an array arr[] and a number K where K is not greater than the size of array, the task is to find the Kth smallest element in the given array. It is given that all array elements are distinct.
Note: Do Not Use sort() STL function, Use heap data structure.
The input line contains T, denoting the number of testcases. Each test case consists of two lines. The first line of each test case contains two integers N and K. Second-line contains N space-separated integer denoting elements of the array.
Constraints:
1 <= T <= 50
1 <= N <= 10000
1 <= K <= N
1 <= arr[i] <= 1000000
Output Corresponding to each test case, print the kth smallest element in a new line.
ExampleSample Input
1
6 3
7 10 4 3 20 15
Sample Output 7
Explanation:Sorted array: 3 4 7 10 15 20, 7 is the third element

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) throws Exception  {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        while(t-- > 0){
            String[] st1 = br.readLine().split(" ");
            int n = Integer.parseInt(st1[0]);
            int k = Integer.parseInt(st1[1]);

            int[] arr = new int[n];
            String[] st2 = br.readLine().split(" ");
            for(int i=0; i<n; i++){
                arr[i] = Integer.parseInt(st2[i]);
            }
            System.out.println( kthSmallest(arr, k)) ;
        }
    }

    static int kthSmallest(int[] arr, int K){
        //For finding min element we need (Max heap)priority queue
        PriorityQueue<Integer> heap1 = new PriorityQueue<Integer>(new MinHeapComparator());
        for (int i = 0; i < arr.length; ++i) {
            // Insert elements into the priority queue
            heap1.add(arr[i]);
            //If current element is less than top, that means there are other k-1 lesser elements are present at bottom
            // thus pop that element and add kth largest element into the heap till curr at last all the greater element than kth element will get pop off
            // and at the top of heap there will be kth smallest element
            if (heap1.size() > K) {
                heap1.remove();
            }
        }
        //Return the top of the heap as kth smallest element
        return heap1.peek();
    }
 
}

class MinHeapComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer number1, Integer number2) {
        int value = number1.compareTo(number2);
        // Elements are sorted in reverse order
        if (value > 0) {
            return -1;
        }
        else if (value < 0) {
            return 1;
        }
        else {
            return 0;
        }
    }
}



Choosing K elements easy
Given an integer array A of size N and an integer K. In one move, you can choose any element from array and add 1 to it. Print the maximum product of the array you can obtain. Print the product modulo 1e9 + 7.
Input First line contains two integers N and K. Next line contains N space separated integers denoting elements of array.
Constraints
1 <= N, K <= 10^5
1 <= Ai <= 10^5
Output Print the maximum product you can obtain after K moves.
Example Sample Input 1:
3 3
1 2 3
Output27
Explanation:
Add 2 to index 0 and 1 to index 1.
Array becomes {3, 3, 3}
Product = 27.
Sample Input 2:
5 1
3 6 6 9 1
Output1944
Explanation
Increment the element at index 4.
Array = {3, 6, 6, 9, 2}
Product = 1944
Sir approach

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    static int mod = 1000000007;
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();

        PriorityQueue<Integer> pq = new PriorityQueue<>();

        for(int i = 0; i<n; i++){
            int x = sc.nextInt();
            pq.add(x);
        }

        for(int i = 0; i < k; i++){
            int x = pq.poll();
            pq.add(x + 1) ;
        }
        long result = 1;

        while(!pq.isEmpty()){
            result = result * pq.poll();
            result %= mod;
        }
        System.out.println(result);
    }
}




Interview Queries Easy
An interviewer is asking you questions in form of queries. For your assistance, he has provided you with an empty array. Queries are of 4 types:-
(1 X) Add given element X to end of the array
(2 X) Delete the first instance of given element X from the array(if element is not present print -1)
(3) Return maximum element of the array.
(4) Return minimum element of the array.
See example for more clarification
Input The first line contains an integer Q.
The next Q lines will each contain a query as mentioned above:-
Constraints:
1 <= Q <= 100000
1 <= X <= 100000
OutputFor queries 3 and 4, print the answer in a new line. If the array is empty for query 2, 3 or 4, then print "-1" without the quotes.
ExampleSample Input:-
6
1 5
1 9
1 1
3
2 1
2 1
Sample Output:-
9
-1
There are 5 queries.
Query 1 -> 5 is added to the array.
Query 2 -> 9 is added to the array.
Query 3 -> 1 is added to the array.
Query 4 -> The maximum element in the array is 9.
Query 5 -> The element 1 is deleted from the array.
Query 6 -> Since there is no element in the array with value 1, so the output is -1.

//another approch
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        TreeMap<Integer,Integer> map = new TreeMap<>();
        Scanner sc = new Scanner (System.in);
        
        int queries = sc.nextInt();
        for(int i = 0 ; i<queries; i++){
            int t = sc.nextInt();
            if(t == 1){
                int x = sc.nextInt();
                map.put(x, map.getOrDefault(x, 0 ) + 1);
            }else if(t == 2){
                int x = sc.nextInt();
                if(map.containsKey(x)){
                    map.put(x, map.get(x) - 1);
                }else{
                    System.out.println(-1);
                }
                
                if(map.containsKey(x) && map.get(x) == 0)
                    map.remove(x);
            }else if(t == 3){
                if(map.size() != 0){
                     System.out.println(map.lastKey());
                }else{
                     System.out.println(-1);
                }
            }else{
                if(map.size() != 0){
                    System.out.println(map.firstKey());
                }else{
                     System.out.println(-1);
                }
            }
        }
    }
}



Max in Queue Easy
You have been given a sequence A of N digits. Each digit in this sequence ranges from 1 to 10^9. You need to perform 2 types of operations on this list:
Add(x): Add element x to the end of the list.
Max(list): Find the maximum element in the current sequence.
For each query of type 2, you need to print the result of that operation.
Input The first line consists of a single integer N denoting the size of the initial sequence. The next line consists of N space-separated integers denoting the elements of the initial sequence. The next line contains a single integer q denoting the number of queries. The next q lines contain the details of the operation. The first integer type indicates the type of query. If typei ==1, it is followed by another integer x and you need to perform an operation of type 1 else operations of type 2
Constraints
1 < = N < = 10^5
1 < = Ai < = 10^9
1 < = q < = 10^4
Output For each operation of the second type, print a single integer on a new line.
Sample Input
5
1 2 3 4 5
6
1 1
1 2
1 3
2
1 8
2
Sample Output
5
8
//Without using max or min with just simple logic
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        int result = -1;

        for(int i = 0; i < n ;i ++){
            int x = sc.nextInt();
            result = Math.max(result,x);
        }
        
        int querySize = sc.nextInt();
        for(int i = 0; i<querySize; i++){
            int queries = sc.nextInt();

            if(queries == 1) {
                int temp = sc.nextInt();
                result = Math.max(result, temp);
            }else{
                System.out.println(result);
            }
        }

    }
}

Heap Assigment IN /Post

Hard Maximum AND Value https://www.geeksforgeeks.org/maximum-value-pair-array/
Ram has an array a1, a2,....,an. Ram asks Shyam to choose two integers ai and aj (i != j) such that the value of bitwise AND of those integers is maximum. Help Shyam to find the maximum value.
Input First line contains only n, length of array.Second line contains the array elements a1, a2,. , anseparated by space.
Constraints
1 ≤ n ≤ 3*105
1 ≤ ai109
OutputThe only line of output contains an integer, maximum value value that Shyam can get.
ExampleSample Input
4
3 4 2 3
Sample Output 3
Explanation Shyam can choose a1 = 3 and a4 = 3 with bitwise AND 3 which is maximum.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        String s2 = br.readLine();
        int[] arr = new int[n];
        
        String[] s1 = s2.split(" ");
        for(int i = 0; i < n; i++){
            arr[i] = Integer.parseInt(s1[i]);
        }

        System.out.println(maxAND(arr, n));
    }

    // Utility function to check number of elements having set msb as of pattern
    static int checkBit(int pattern, int arr[], int n) {
        int count = 0;
        for (int i = 0; i < n; i++)
            if ((pattern & arr[i]) == pattern)
                count++;
        return count;
    }
  
    // Function for finding maximum and value pair
    static int maxAND (int arr[], int n){
        int res = 0, count;
        // iterate over total of 32bitsfrom msb to lsb
        for (int bit = 31; bit >= 0; bit--){
            // find the count of element having set msb
            count = checkBit(res | (1 << bit), arr, n);
            // if count >= 2 set particular   // bit in result
            if ( count >= 2 )    
                res |= (1 << bit);    
        }
    
        return res;
    }
}



Minimum Cost of ropes
You are given N ropes of L[i] lengths, you need to connect these ropes into one rope. The cost to connect two ropes is equal to sum of their lengths. The task is to connect the ropes with minimum cost.
Input The first line of input contains an integer T denoting the number of test cases. The first line of each test case is N where N is the number of ropes. The second line of each test case contains N input L[i],length of ropes.
Constraints:
1 ≤ T ≤ 100
1 <= N <= 10^5
1 <= L[i] <= 10^5
Sum of N over all test cases does not exceed 5*10^5.Output For each testcase, print the minimum cost to connect all the ropes.
ExampleSample Input:
2
4
4 3 2 6
5
4 2 7 6 9
Sample Output:
29
62
Explanation:
For example if we are given 4 ropes of lengths 4, 3, 2 and 6. We can connect the ropes in following ways.
1) First connect ropes of lengths 2 and 3. Now we have three ropes of lengths 4, 6 and 5.
2) Now connect ropes of lengths 4 and 5. Now we have two ropes of lengths 6 and 9.
3) Finally connect the two ropes and all ropes have connected.
Total cost for connecting all ropes is 5 + 9 + 15 = 29. This is the optimized cost for connecting ropes.
Other ways of connecting ropes would always have same or more cost. For example, if we connect 4 and 6 first (we get three strings of 3, 2 and 10), then connect 10 and 3 (we get two strings of 13 and 2). Finally we connect 13 and 2. 
Total cost in this way is 10 + 13 + 15 = 38
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) throws IOException{
        Scanner sc = new Scanner(System.in);
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(br.readLine());
        while (t-- > 0) {
            long size = Long.parseLong(br.readLine());
            String s2 = br.readLine();
            long[] arr = new long[(int) size];
            String[] s1 = s2.split(" ");
            for(long i=0;i<size;i++){
                arr[(int) i] = Long.parseLong(s1[(int) i]);
            }

            System.out.println(minCost(arr, size));
        }
    }
    static long minCost(long arr[], long n) {
        // Create a priority queue
        PriorityQueue<Long> pq = new PriorityQueue<Long>();
        // Adding items to the pQueue
        for (int i = 0; i < n; i++) {
            pq.add(arr[i]);
        }

        // Initialize result
        long res = 0;
 
        // While size of priority queue is more than 1
        while (pq.size() > 1) {
            // Extract shortest two ropes from pq
            long first = pq.poll();
            long second = pq.poll();
 
            // Connect the ropes: update result and insert the new rope to pq
            res += first + second;
            pq.add(first + second);
        }

        return res;
    }
}



Wedding
There are N wedding events that you need to attend. But there is a constraint. You can attend only one event per day. You are given two arrays X and Y of size N each. The ith event starts at day X[i] and ends at day Y[i]. You can attend an event i at any day d where X[i] <= d <= Y[i].
Find the maximum number of events you can attend.
Input
First line contains an integer N.
Next line contains N space separated integers denoting elements of array X.
Next line contains N space separated integers denoting elements of array Y.

Constraints
1 <= N <= 10^5
1 <= X[i] <= Y[i] <= 10^5
Output Print the maximum number of events you can attend.
ExampleSample Input 1:
3
1 2 3
5 6 7
Output3
Explanation:
Attend event 1 at day 1, event 2 at day 2 and event 3 at day 3. So, you can attend all events.
Sample Input 2:
4
1 2 3 1
2 3 4 2
Output 4
Explanation Attend event 1 at day 1,event 4 at day 2, event 2 at day 3 and event 3 at day 4. So, you can attend all events.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Pair{
    int startDate;// start date
    int endDate; //end date
}
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();

        /*int arr1[] = new int[n];
        int arr2[] = new int[n];
        for(int i = 0; i < n; i++){
            arr1[i] = sc.nextInt(); 
            //System.out.println(arr1[i] + " ");
        }
        for(int i = 0; i < n; i++){
            arr2[i] = sc.nextInt(); 
            //System.out.println(arr2[i] + " ");
        }
        System.out.println(maxEvents(arr1,arr2,n));*/

        //Sirs approach
        Pair pairs[] = new Pair[n];

        for(int i = 0; i < n ; i ++){
            pairs[i] = new Pair();
            pairs[i].startDate = sc.nextInt();
        }

        for(int i = 0; i < n ; i ++){
            pairs[i].endDate = sc.nextInt();
        }

        Arrays.sort(pairs, new Comparator<Pair>(){

                public int compare(Pair a, Pair b){
                    if(a.startDate == b.startDate){
                        if(a.endDate < b.endDate)
                            return -1;
                        return 1;
                    }else if(a.startDate < b.startDate)
                        return -1;
                    else
                        return 1;
                }
            }
        );
        
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        int ans = 0;
        int days = 1;
        int i = 0;
        while(i < n || !pq.isEmpty()){
            //removing ld maxEvents
            while(!pq.isEmpty() && days > pq.peek()){
                pq.poll();
            }

            //adding all eligible Events
            while(i < n && days >= pairs[i].startDate){
                pq.add(pairs[i].endDate);
                i++;
            }
            if(!pq.isEmpty() && pq.peek() >= days){
                pq.poll();
                ans ++;
            }

            days++;
        }
        System.out.println(ans);
    }
    
    // another approach
    /*static int maxEvents(int[] start, int[] end, int N) {
        int a[][]=new int[N][2];
        for(int i=0;i<N;i++){
            a[i][0]= start[i];
            a[i][1]= end[i];
        }
        TreeSet<Integer> set=new TreeSet<>();
        for(int i=1;i<=100000;i++)
        set.add(i);
        int ans=0;
        // Arrays.sort(a,new MIN());
        Arrays.sort(a,Comparator.<int[]>comparingInt(p->p[1]).thenComparingInt(p->p[0]));
        for(int i=0;i<N;i++) {
            Integer available=set.ceiling(a[i][0]);
            if(available==null || available>a[i][1])
            continue;
            else{
                ans++;
                set.remove(available);
            }
        }
        return ans;
    }
    static class MIN implements Comparator<int[]> {
        public int compare(int a[],int b[]) {
            if(a[1]>b[1]) return 1;
            else if(a[1]<b[1]) return -1;
            else if(a[0]>b[0]) return 1;
            else if(a[0]<b[0]) return -1;
            else return 0;
        }
    }*/
}


Minimize Product https://www.geeksforgeeks.org/minimize-sum-product-two-arrays-permutations-allowed/
The product sum of two equal length arrays num1 and num2 is equal to the sum of a[i] * b[i] for all 0 <= i < a.length (0- indexed).
For example, if num1 = [1, 2, 3, 4] and num2 = [5, 2, 3, 1], the product sum would be 1*5 + 2*2 + 3*3 + 4*1 = 22.
Given two arrays num1 and num2 of length n, return the minimum product sum if you are allowed to rearrange the order of the elements in num1.
1 <= n <= 1e5
1 <= num1[i], num2[i] <= 100
Output Print the minimum product sum.
Example
Sample Input 1:
4
5 3 4 2
4 2 2 5
Sample Output 1: 40

Used diff aprroach  not sure is heap appraoch or not
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int size = sc.nextInt();
        int arr1[] = new int[size];
        int arr2[] = new int[size];
        for(int i = 0; i < size; i++ ){
            arr1[i] = sc.nextInt();
            //System.out.print(arr1[i] + " ");
        }
        for(int i = 0; i < size; i++ ){
            arr2[i] = sc.nextInt();
            //System.out.print(arr2[i] + " ");
        }
        System.out.println(minValue(arr1, arr2, size));
    }
    // Returns minimum sum of product of two arrayswith permutations allowed
    static long minValue(int A[], int B[], int n)  {
        // Sort A and B so that minimum and maximum value can easily be fetched.
        Arrays.sort(A);
        Arrays.sort(B);
 
        // Multiplying minimum value of A and maximum value of B
        long result = 0;
        for (int i = 0; i < n; i++)
            result += (A[i] * B[n - i - 1]);
 
        return result;
    }
}
Another Approach
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        PriorityQueue<Integer> pq1 = new PriorityQueue<Integer>();
        PriorityQueue<Integer> pq2 = new PriorityQueue<Integer>(Collections.reverseOrder());

        int n = sc.nextInt();
        int arr1[] = new int[n];
        int arr2[] = new int[n];

        for(int i=0; i<n; i++) {
            arr1[i] = sc.nextInt();
            pq1.add(arr1[i]);
        }

        for(int i=0; i<n; i++) {
            arr2[i] = sc.nextInt();
            pq2.add(arr2[i]);
        }
        
        int ans = 0;
        while(!pq1.isEmpty() && !pq2.isEmpty()) {
            int a = pq1.poll();
            int b = pq2.poll();
            ans += (a * b); 
        }

        System.out.println(ans);
    }
}



BInary Search Tree


Difference in operationsEasy
Given the root of a binary search tree. Calculate the difference between the product and sum of minimum and maximum elements of the binary search tree.
Input Given root of binary search tree.
Constraints:
1<= node value<=100000
Output
print difference between product of minimum and maximum element of BST.
Example
Sample Input 1:
root = 4 2 6 1 3
Sample Output 1:-1
Explanation: Product of maximum and minimum element is 6 and their sum is 7 so difference between these two is -1.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
class Node{
    int data;
    Node left,right;
    Node(int d){
        this.data = d;
        this.left = null;
        this.right = null;
    }
}

class BST {
    Node root;  
    BST() {
        this.root = null;
    }
                                
    public Node add(int key) {
        this.root = this.insert(this.root, key);
        return root;
    }
                                          
    private Node insert(Node root, int key) {
        if(root == null)
            return new Node(key);
                                                                                            
        if(key < root.data)
            root.left = insert(root.left, key);
        else if(key > root.data)
            root.right = insert(root.right, key);
                                                                                
        return root;
    }
    static void inorder(Node root,ArrayList<Integer> ans) {
        if(root==null)
        return;
        inorder(root.left,ans);
        ans.add(root.data);
        inorder(root.right,ans);
    }
}

//old class code
/*class BST{
    Node root;
    BST(){
        this.root = null;
    }

    public void insertNode(int arr[]){
        this.root = new Node(arr[0]);

        int index = 1;
        Queue<Node> queue = new LinkedList<>();
        queue.add(this.root);

        while(index < arr.length){
            Node newNode = queue.poll();
            if(arr[index] != 0){
                newNode.left = new Node(arr[index]);
                queue.add(newNode.left);
            }
            if(index + 1 <arr.length && arr[index + 1] != 0){
                newNode.right = new Node(arr[index + 1]);
                queue.add(newNode.right);
            }
            index += 2;
        }
    }
    public int minValReturn(){
        int min = this.minValue(this.root);
        return min;
    }
    public int maxValReturn(){
        int max = this.maxValue(this.root);
        return max;
    }
    static int minValue(Node node) {
        Node curr = node;
        while(curr.left != null){
            curr = curr.left;
        }    
        return curr.data;
    }
    static int maxValue(Node node){
        Node current = node;
        // Find the rightmost leaf
        while (current.right != null)
        {
            current = current.right;
        }
        return (current.data);
    }
    
}*/

class Main {
      
    public static void main (String[] args) {
        //Node root = null;
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];

        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
          
            //System.out.println(arr[i]);
        }
        // BST tree = new BST();
        // tree.insertNode(arr);
        // int minNodeValue = tree.minValReturn();
        // int maxNodeValue = tree.maxValReturn();

        // int sum  = (maxNodeValue + minNodeValue);
        // int product  = (maxNodeValue * minNodeValue);
        // //System.out.println(maxNodeValue);
        // //System.out.print(product - sum);
        // System.out.print(sum - product);

        BST tree = new BST();
        Node root = null;
        for(int i = 0; i < n;i++)
            root = tree.add(arr[i]);
           //root=tree.add(Integer.parseInt(val[i]));

        ArrayList<Integer>ans = new ArrayList<>();
        tree.inorder(root,ans);
        int mul = ans.get(0) * ans.get(ans.size() - 1);
        int sum = ans.get(0) + ans.get(ans.size() - 1);
        int res = mul - sum;
        System.out.print(res);

    }
}
 
Reorder BST Hard https://leetcode.com/problems/number-of-ways-to-reorder-array-to-get-same-bst/discuss/1822819/Java-O(nlogn)
Given an array nums that represents a permutation of integers from 1 to n. We are going to construct a binary search tree (BST) by inserting the elements of nums in order into an initially empty BST. Find the number of different ways to reorder nums so that the constructed BST is identical to that formed from the original array nums.
Return the number of ways to reorder nums such that the BST formed is identical to the original BST formed from nums.
Since the answer may be very large, return it modulo 1e9+7.
Input The first line contains a single space separated integer N.
The second line contains N space-separated integers a[i].
Constraints 1 <= n <= 1000 1 <= a[i] <= n
Output Print the number of all possible permutations.
Example Sample Input 1:
3
2 1 3
Sample Output 1: 1
Explanation:Only single permutations of nums can produce similar BST.
Sample Input 2:
5
3 4 5 1 2
Sample Output 2: 5
Explanation:
3 1 2 4 5
3 1 4 2 5
3 1 4 5 2
3 4 1 2 5
3 4 1 5 2
There are 5 possible permutations of nums that can generate the same binary search tree.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

//Let’s say x numbers < rootValue, y number > rootValue
//F(rootValue, nums) = F(first X number, {X numbers}) * F(first Y number, {Y numbers}) * (permutation of Xs and Ys)

//permutation(x, y) =permutation (x-1, y) // first element is x + permutation (x, y-1) // first element is y
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for(int i = 0; i<n; i++){
            arr[i] = sc.nextInt();
        }
        System.out.println(numOfWays(arr));

    }

    static int MODULO = 1000000007;
    public static int numOfWays(int[] nums) {
        Deque<Integer> queue = new ArrayDeque<>();
        countMap = new HashMap();
        for (var n : nums){
            queue.add(n);
        }
        
        int result = findWays(queue) - 1;
        return result;
    }
    
    static Map<Integer, Integer> countMap;
    static int findCount(int x, int y){
        if (x == 0 || y == 0){
            return 1;
        }
        if (x > y){
            return findCount(y, x);
        }
        int key = x*1000+y;
        Integer v = countMap.get(key);
        if (v != null){
            return v;
        }
        
        long result = (long) findCount(x-1, y) + findCount(x, y-1);
        v = (int) (result > MODULO ? (result % MODULO) : result);
        countMap.put(key, v);
        return v;
    }
    
    static int findWays(Deque<Integer> nums){
        if ( nums.size() < 3){
            return 1;
        }
        var cur = nums.poll();
        Deque<Integer> xNums = new ArrayDeque<Integer>();
        Deque<Integer> yNums = new ArrayDeque<Integer>();
        while (!nums.isEmpty()){
            var n = nums.poll();
            if (n < cur){
                xNums.add(n);
            } else if (n > cur){
                yNums.add(n);
            }
        }
        
        long count = findCount(xNums.size(), yNums.size());
        count *= findWays(xNums);
        if (count > MODULO){
            count = count % MODULO;
        }
        count *= findWays(yNums);
        if (count > MODULO){
            count = count % MODULO;
        }
        return (int) count;
    }
}

Monk and his friends Medium
Monk is standing at the door of his classroom. There are currently N students in the class, i'th student got Ai candies.
There are still M more students to come. At every instant, a student enters the class and wishes to be seated with a student who has exactly the same number of candies. For each student, Monk shouts YES if such a student is found, NO otherwise.
Input
First line contains two space- separated integers N and M.
Second line contains N + M space- separated integers, the candies of the students.
Outpu output M new line, Monk's answer to the M students.
Print "YES" (without the quotes) or "NO" (without the quotes) pertaining to the Monk's answer.
Constraints:
1 ≤ N, M ≤ 100000
0 ≤ Ai ≤ 1000000000
Sample Input 1:
2 3
3 2 9 11 2
Sample Output 1:
NO
NO
YES
Explanations:
Initially students with 3 and 2 candies are in the class.
A student with 9 candies enters, No student with 9 candies in class. Hence, "NO"
A student with 11 candies enters, No student with 11 candies in class. Hence, "NO"
A student with 2 candies enters, Student with 2 candies found in class. Hence, "YES"

class Node{
    int data;
    Node left, right;
    Node(int d){
        data = d;
        left= null;
        right = null;
    }
}
class Main {
    public static void main (String[] args) {
        /*Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        HashSet<Integer> set = new HashSet<Integer>();
        for(int i=0; i<n; i++){
            set.add(sc.nextInt());
            //System.out.println(set);
        }
        int temp=0;
        for(int i=0; i<m; i++){
            temp = sc.nextInt();
            //System.out.println(temp);
            if(set.contains(temp)){
                System.out.println("YES");
            }else{
                System.out.println("NO");
                set.add(temp);
            }
        } */

        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        Node root = new Node(sc.nextInt());
        for(int i = 1; i<n; i++){
            createTree(root, sc.nextInt());
        }
        for(int i=0; i < m; i++){
            if(createTree(root, sc.nextInt())){
                System.out.println("YES");
            }else{
                System.out.println("NO");
            }
        }
    }

    public static boolean createTree(Node root, int value){
        if(root.data == value){
            return true;
        }
        if(value < root.data){
            if(root.left == null){
                root.left = new Node(value);
                return false;
            }else{
                return createTree(root.left, value);
            }
        }else{
            if(root.right == null){
                root.right = new Node(value);
                return false;
            }else{
                return createTree(root.right, value);
            }
        }
    }
}




Lowest Common Ancestor in a BST https://www.geeksforgeeks.org/lowest-common-ancestor-in-a-binary-search-tree/
Given a Binary Search Tree and 2 node value n1 and n2, your task is to find the lowest common ancestor(LCA) of the two nodes given.
It may happen that values n1 and n2 may or may be not present.
Note: Duplicates are not inserted in the BST.
Constraints:
1 <= T <= 100
1 <= N <= 10^4
1 <= node values <= 10^4
Sum of "N" over all testcases does not exceed 10^5
Output
For each testcase, you need to return the node containing LCA of n1 and n2. The driver code will print the data. If any of the node values (n1, n2) is not present then return null driver code will print -1 for that.
Example
Sample Input
2
5 4 6 3 N N 7 N N N 8
7 8
2 1 3
1 3
Sample Output
7
2
Explanation:
Testcase1:
The BST in above test case will look like
5
/ \
4 6
/ \
3 7
\
8
Here the LCA of 7 and 8 is 7.

/*
// Information about the class Node
class Node{
    int data;
    Node left;
    Node right;
    Node(int data){
        this.data = data;
        left=null;
        right=null;
    }
}
*/
static Node LCA(Node node, int n1, int n2) {
    //Iterative Approach
    /*while (node != null)    {
        // If both n1 and n2 are smaller than root, then LCA lies in left
        if (node.data > n1 && node.data > n2){
            node = node.left;
        }else if (node.data < n1 && node.data < n2){
        // If both n1 and n2 are greater than root, then LCA lies in right
            node = node.right;
        }else{ break;}
    }
    return node;*/
    
    // Recursive Approach
    if (node == null)
            return null;
  
        // If both n1 and n2 are smaller than root, then LCA lies in left
        if (node.data > n1 && node.data > n2)
            return LCA(node.left, n1, n2);
  
        // If both n1 and n2 are greater than root, then LCA lies in right
        if (node.data < n1 && node.data < n2)
            return LCA(node.right, n1, n2);
  
        return node;
}


Ceil in BST Given a BST and a number X, find Ceil of X.
Print a single integer ceil of given number X.
Constraints:
1<=N<=100000
1<=X, A[i]<=1000000
Sample Input 1:
5
4 5 8 9 13
7
Sample Output 1: 8
Explanation: ceil of given number x is 8.
class Node{
    int data;
    Node left, right;

    Node(int d){
        data = d;
        left = null; 
        right = null;
    }
}

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int len = sc.nextInt();
        Node root = new Node(sc.nextInt());
        for(int i=1; i<len; i++){
            createTree(root, sc.nextInt());
        }
        int key = sc.nextInt();
        findCeil(root, key);
        if(ans == Integer.MAX_VALUE){
            System.out.println(-1);
        }else{
            System.out.println(ans);
        }
    }
    static int ans = Integer.MAX_VALUE;
    public static void findCeil(Node root, int key){
        if(root == null){
            return;
        }
        if(key == root.data){
            ans = key;
            return;
        }
        if(key > root.data){
            findCeil(root.right, key);
        }else{
            ans = Math.min(ans, root.data);
            findCeil(root.left, key);
        }
    }
    public static void createTree(Node root, int value){
        if(value == root.data){
            return;
        }
        if(value < root.data){
            if(root.left == null){
                root.left = new Node(value);
            }else{
                createTree(root.left, value);
            }
        }else{
            if(root.right == null){
                root.right = new Node(value);
            }else{
                createTree(root.right, value);
            }
        }
    }
}

/* solution using Array
Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for(int i=0; i<n; i++){
            a[i] = sc.nextInt();
        }
        Arrays.sort(a);
        int x = sc.nextInt();
        int temp= -1;
        simple logic greter or equal value in array gives the ceil
        for(int i=0; i<n; i++){
            if(a[i]>=x){
                temp = a[i];
                break;
            }
        }
        System.out.println(temp);
        return;
    }
}
*/

Minimum in BST Problem Statement https://www.geeksforgeeks.org/find-the-minimum-element-in-a-binary-search-tree/
Given a Binary Search Tree. The task is to find the minimum element in this given BST. If the tree is empty, there is no minimum element, so print -1 in that case.
1 <= T <= 100
1 <= N <= 10^3
1 <= node values <= 10^4
Sum of "N" over all testcases does not exceed 10^5
Output For each testcase you need to return the minimum element in BST
Input:
2
5 4 6 3 N N 7 1
9 N 10 N 11
Output:
1
9
Explanation: Testcase 1: We construct the following BST by inserting given values one by one in an empty BST.
5
/ \
4 6
/ \
3 7
/
1
The minimum value in the given BST is 1.
Testcase 2: We construct the following BST by inserting given values one by one in an empty BST.
9
\
10
\
11
The minimum value in the given BST is 9.

/*
// Information about the class Node
class Node{
    int data;
    Node left;
    Node right;
    Node(int data){
        this.data = data;
        left=null;
        right=null;
    }
}
*/
static int minValue(Node node) {
   Node curr = node;
   while(curr.left != null){
     curr = curr.left;
   }    
   return curr.data;
 }


Maximum Sum BSTMedium https://www.geeksforgeeks.org/maximum-sub-tree-sum-in-a-binary-tree-such-that-the-sub-tree-is-also-a-bst/
Given the root of Full binary tree, return the maximum sum of all keys of any sub-tree which is also a Binary Search Tree.
Print maximum of BST.
Constraints:
1<=node value<=1000000000
Example
Sample Input 1:
root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]
Sample Output 1:20
Explanations :
1
/ \
4 3
/ \ / \
2 4 2 5
/\ /\ /\ /\
0 0 0 00 0 4 6
subtree with root node equal to 3 include BST with maximum sum equals 20.

//First approach with passing all arraylist to root 
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Node {
        int data;
        Node left;
        Node right;
        Node(int data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
}

class BinaryTree{
   
    Node root;
    int maxSum;
    BinaryTree(){
        this.root = null;
        this.maxSum = 0;
    }  
    
    public void insertNode(int arr[]){
        this.root = new Node(arr[0]);

        int index = 1;
        Queue<Node> queue = new LinkedList<>();
        queue.add(this.root);

        while(index <arr.length){
            Node newNode = queue.poll();

            if(arr[index] != 0){
                newNode.left = new Node(arr[index]);
                queue.add(newNode.left);
            }
            if(index + 1 < arr.length && arr[index + 1] != 0){
                newNode.right =  new Node(arr[index + 1]);
                queue.add(newNode.right);
            }
            index += 2;
        }
    }

    public int findMaxBST(){
        this.findMaxBSTUtil(this.root);
        return this.maxSum;
    }
    public ArrayList<Integer> findMaxBSTUtil(Node root){
        if(root.left == null && root.right == null){
            this.maxSum = Math.max(this.maxSum, root.data);
            
            ArrayList<Integer> list = new ArrayList<>();
            list.add(root.data);

            return list;
        }

        ArrayList<Integer> left = findMaxBSTUtil(root.left);
        ArrayList<Integer> right = findMaxBSTUtil(root.right);

        if(left.size() == 0 || right.size() == 0)
            return new ArrayList<>();
        
        if(left.get(left.size() - 1) < root.data && root.data < right.get(0)){
            left.add(root.data);
            left.addAll(right);
            
            int sum = 0;
            for(int x : left)
                sum += x;

            this.maxSum = Math.max(this.maxSum, sum);
            
            return left; 
        }
        return new ArrayList<>();
    }
}

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int len = sc.nextInt();
        int arr[] = new int[len];

        for(int i = 0; i < len; i++){
            arr[i] = sc.nextInt();
            //System.out.println(arr[i]);
        }

        BinaryTree tree = new BinaryTree();
        tree.insertNode(arr);

		int ans = tree.findMaxBST();
        System.out.println(ans);
    }
}

//second approach passing onlt three value to thr root min max sum with new class creted for function to return three value ek sath.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Node {
        int data;
        Node left;
        Node right;
        Node(int data) {
            this.data = data;
            this.left = null;
            this.right = null;
        }
}
//Another aapoach for return the three value ek sath to the root
class Solution {
    int sum;
    int min;
    int max;
    Solution(int sum,int min,int max){
        this.sum = sum;
        this.min = min;
        this.max = max;
    }
    Solution(){
        this.sum = 0;
        this.min = 0;
        this.max = 0;
    }
}

class BinaryTree{
   
    Node root;
    int maxSum;
    BinaryTree(){
        this.root = null;
        this.maxSum = 0;
    }  
    
    public void insertNode(int arr[]){
        this.root = new Node(arr[0]);

        int index = 1;
        Queue<Node> queue = new LinkedList<>();
        queue.add(this.root);

        while(index <arr.length){
            Node newNode = queue.poll();

            if(arr[index] != 0){
                newNode.left = new Node(arr[index]);
                queue.add(newNode.left);
            }
            if(index + 1 < arr.length && arr[index + 1] != 0){
                newNode.right =  new Node(arr[index + 1]);
                queue.add(newNode.right);
            }
            index += 2;
        }
    }

    public int findMaxBST(){
        this.findMaxBSTUtil(this.root);
        return this.maxSum;
    }

    //nee findMaxBSTUtil funcion with return the three va;ues tpo the root
    public Solution findMaxBSTUtil(Node root){
        if(root.left == null && root.right == null){
            this.maxSum = Math.max(this.maxSum, root.data);

            return new Solution(root.data,root.data,root.data);
        }
        Solution left = findMaxBSTUtil(root.left);
        Solution right = findMaxBSTUtil(root.right);

        if(left.sum == 0 || right.sum == 0)
            return new Solution();
        
        if(left.max < root.data && root.data < right.min){
            this.maxSum = Math.max(this.maxSum, left.sum + root.data + right.sum);
    
            return new Solution(left.sum + root.data + right.sum, left.min,right.max); 
        }
        return new Solution();
    }
    //old wala
    /*public ArrayList<Integer> findMaxBSTUtil(Node root){
        if(root.left == null && root.right == null){
            this.maxSum = Math.max(this.maxSum, root.data);
            
            ArrayList<Integer> list = new ArrayList<>();
            list.add(root.data);

            return list;
        }

        ArrayList<Integer> left = findMaxBSTUtil(root.left);
        ArrayList<Integer> right = findMaxBSTUtil(root.right);

        if(left.size() == 0 || right.size() == 0)
            return new ArrayList<>();
        
        if(left.get(left.size() - 1) < root.data && root.data < right.get(0)){
            left.add(root.data);
            left.addAll(right);
            
            int sum = 0;
            for(int x : left)
                sum += x;

            this.maxSum = Math.max(this.maxSum, sum);
            
            return left; 
        }
        return new ArrayList<>();
    }*/
}

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int len = sc.nextInt();
        int arr[] = new int[len];

        for(int i = 0; i < len; i++){
            arr[i] = sc.nextInt();
            //System.out.println(arr[i]);
        }

        BinaryTree tree = new BinaryTree();
        tree.insertNode(arr);

		int ans = tree.findMaxBST();
        System.out.println(ans);
    }
}




delete Node in a BST
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.
Basically, the deletion can be divided into two stages:
1. Search for a node to remove.
2. If the node is found, delete the node.
Constraint:
1<= number of nodes <= 10000
1 <= node values <= 100000, each values will be distinct
Output
Return the root of binary tree after deleting key from BST.
Example
Sample Input:
5 3 6 2 4 null 7
3
Sample Output 5 4 6 2 null null 7
Explanation: Given key to delete is 3. So we find the node with value 3 and delete it. 

/*
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode() {}
    TreeNode(int val) { this.val = val; }
    TreeNode(int val, TreeNode left, TreeNode right) {
        this.val = val;
        this.left = left;
        this.right = right;
    }
}
*/

public static TreeNode deleteNode(TreeNode root, int key) {
              if(root == null) return root;

    // Recursive calls to get ancestors of node to be deleted
    if (root.val > key) {
        root.left = deleteNode(root.left, key);
        return root;
    }
    else if (root.val < key) {
        root.right = deleteNode(root.right, key);
        return root;
    }

      // We reach here when root is the node to be deleted. If one of the children is empty
    if (root.left == null) {
        TreeNode temp = root.right;
        return temp;
    }else if (root.right == null){
        TreeNode temp = root.left;
        return temp;
    }else {
        // If both children exist
        TreeNode succParent = root;
  
        // Find successor
        TreeNode succ = root.right;
          
        while (succ.left != null) {
            succParent = succ;
            succ = succ.left;
        }
  
        // Delete successor. Since successor is always left child of its parent
        // we can safely make successor's right right child as left of its parent.
        // If there is no succ, then assign succ->right to succParent->right
        if (succParent != root)
            succParent.left = succ.right;
        else
            succParent.right = succ.right;
  
        // Copy Successor Data to root
        root.val = succ.val;
  
        return root;
    }
}



Insertion in BST
Given a BST and some keys, the task is to insert the keys in the given BST. Duplicates are not inserted. (If a test case contains duplicate keys, you need to consider the first occurrence and ignore duplicates).
Constraints:
1 <= T <= 100
1 <= N <= 10^3
1 <= node values <= 10^4
Sum of "N" over all testcases does not exceed 10^5
Output Return the node of BST after insertion.
Input:
2
3
2 1 3
4
8
2 1 3 N N N 6 4
1
Output:
1 2 3 4
1 2 3 4 6

Explanation:
Testcase 1: After inserting the node 4 the tree will be
2
/ \
1 3
\
4
Inorder traversal will be 1 2 3 4.
Testcase 2: After inserting the node 1 the tree will be
2
/ \
1 3
/ \ / \
N N N 6
/
4
Inorder traversal of the above tree will be 1 2 3 4 6.
/*
// Information about the Node class
class Node  
{ 
    int data; 
    Node left, right; 
   
    public Node(int d)  
    { 
        data = d; 
        left = right = null; 
    } 
}
*/
static int count = 1;
static Node insertInBST(Node root,int key){
   if(root == null) return new Node(key);

   if(root.data == key){
       count ++;
       return root;
   }
   if(key < root.data){
       root.left = insertInBST(root.left, key);
   }else{
       root.right = insertInBST(root.right, key);
   }
   return root;
}




Deletion in BST https://www.geeksforgeeks.org/binary-search-tree-set-2-delete/
Given a Binary Search Tree (BST) and a node x, your task is to delete the node 'x' from the BST.
If no node with value x exists then, do not make any changes
Input User Task:
Since this will be a functional problem. You don't have to take input. You just have to complete the function deletInBST() that takes "root" node and the value to be deleted as parameter. The printing is done by the driver code.
Constraints:
1 <= T <= 100
1 <= N <= 10^3
1 <= node values <= 10^4
1 <= K <= 10^3
Sum of "N" over all testcases does not exceed 10^5
Output Return the node of BST after deletion.
Example Input:
2
3
2 1 3 N N N N
2
9
1 N 2 N 8 5 11 4 7 9 12
9
Output:
1 3
1 2 4 5 7 8 11 12 

/*
// Information about the class
class Node{
    int data;
    Node left;
    Node right;
    Node(int data){
        this.data = data;
        left=null;
        right=null;
    }
}
*/
public static Node deleteInBST(Node root, int value) 
{
    if(root == null) return root;

    // Recursive calls to get ancestors of node to be deleted
    if (root.data > value) {
        root.left = deleteInBST(root.left, value);
        return root;
    }
    else if (root.data < value) {
        root.right = deleteInBST(root.right, value);
        return root;
    }

      // We reach here when root is the node to be deleted. If one of the children is empty
    if (root.left == null) {
        Node temp = root.right;
        return temp;
    }else if (root.right == null){
        Node temp = root.left;
        return temp;
    }else {
        // If both children exist
        Node succParent = root;
  
        // Find successor
        Node succ = root.right;
          
        while (succ.left != null) {
            succParent = succ;
            succ = succ.left;
        }
  
        // Delete successor. Since successor is always left child of its parent
        // we can safely make successor's right right child as left of its parent.
        // If there is no succ, then assign succ->right to succParent->right
        if (succParent != root)
            succParent.left = succ.right;
        else
            succParent.right = succ.right;
  
        // Copy Successor Data to root
        root.data = succ.data;
  
        return root;
    }
}

Sir given in class assigment sample 
import java.util.*;
import java.io.*;

class Node {
    int data;
    
    Node left;
    Node right;
    
    Node(int data) {
        this.data = data;
        this.left = null;
        this.right = null;
    }
}

class BinaryTree {
    Node root;
    
    BinaryTree() {
        this.root = null;
    }
    
    BinaryTree(int x) {
        this.root = new Node(x);
    }
    
    public void traversal() {
        System.out.print("PreOrder: ");
        this.preorder(root);
        System.out.println();
    }
    
    public void preorder(Node root) {
        if(root == null)
            return;
        
        System.out.print(root.data + " ");
        
        preorder(root.left);
        preorder(root.right);
    }
    
    public void insert(int arr[]) {
        this.root = new Node(arr[0]);
        int ind = 1;
        
        Queue<Node> queue = new LinkedList<>();
        queue.add(this.root);
        
        while(ind < arr.length) {
            Node node = queue.poll();
            
            if(arr[ind] != -1) {
                node.left = new Node(arr[ind]);
                queue.add(node.left);
            }
            
            if(ind+1 < arr.length && arr[ind+1] != -1) {
                node.right = new Node(arr[ind+1]);
                queue.add(node.right);
            }
            
            ind += 2;
        }
    }
    
}

public class Main
{
	public static void main(String[] args) {
	    int arr[] = {1, 4, 3, 2, 4, 2, 5, -1, -1, -1, -1, -1, -1, 4, 6, 7, -1, -1, 8};
	    
		BinaryTree tree = new BinaryTree();

        tree.insert(arr);
		
		tree.traversal();
	}
}


Insertion in BST Easy https://www.geeksforgeeks.org/how-to-handle-duplicates-in-binary-search-tree/
Given a BST and some keys, the task is to insert the keys in the given BST. Duplicates are not inserted. (If a test case contains duplicate keys, you need to consider the first occurrence and ignore duplicates).

Constraints:
1 <= T <= 100
1 <= N <= 10^3
1 <= node values <= 10^4
Sum of "N" over all testcases does not exceed 10^5
Output
Return the node of BST after insertion.
Example
Input:
2
3
2 1 3
4
8
2 1 3 N N N 6 4
1

Output:
1 2 3 4
1 2 3 4 6

Explanation:
Testcase 1: After inserting the node 4 the tree will be
2
/ \
1 3
\
4
Inorder traversal will be 1 2 3 4.
Testcase 2: After inserting the node 1 the tree will be
2
/ \
1 3
/ \ / \
N N N 6
/
4
Inorder traversal of the above tree will be 1 2 3 4 6.
/*

class Node  
{ 
    int data; 
    Node left, right; 
   
    public Node(int d)  
    { 
        data = d; 
        left = right = null; 
    } 
}
*/
static int count = 1;
static Node insertInBST(Node root,int key){
   if(root == null) return new Node(key);

   if(root.data == key){
       count ++;
       return root;
   }
   if(key < root.data){
       root.left = insertInBST(root.left, key);
   }else{
       root.right = insertInBST(root.right, key);
   }
   return root;
}


Binary Tree

Re-rooting
Given a binary tree with root 1. You have to make some other node as the root such that all conditions of a binary tree is satisfied. Print all nodes other than 1 that can be made as the root of the tree in sorted order.
Note - You cannot add/remove a node. You cannot break any edge.
Print in a single line all nodes other than 1 that can be made as the root. You must print in increasing order.
Example
Sample Input 1:
5
2 4
5 -1
-1 -1
-1 3
-1 -1
Sample output 1:
2 3 4 5

Explanation: Given binary tree
1
/ \
2 4
/ \
5 3
One possible configuration of tree when 4 is made as the root
4
/ \
1 3
/
2
/
5 
class Main {
    static int count=0;
    static int c2=0;
    public static void main (String[] args) {
                      // Your code here
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int l = sc.nextInt();
        int r = sc.nextInt();
        for(int i = 2; i <= n; i++){
            l = sc.nextInt();
            r = sc.nextInt();
                if(l < 0 || r < 0){
                System.out.print(i+" ");
            }
        }
    }
}
/* old solution, all test cases passed
        LinkedList<Integer> ll = new LinkedList<>();
        check(a, 1, ll);
        Collections.sort(ll);
        if(ll.get(0)== 1){
            ll.remove(0);
        }
        for(int i: ll){
            System.out.print(i+" ");
        }
    }
    public static void check(int[][] a,int count, LinkedList ll){
        int l = a[count][0];
        int r = a[count][1];

        if(l<0 || r<0){
            ll.add(count);
        }
        if(l>0){
            check(a, l, ll);
        }
        if(r>0){
            check(a, r, ll);
        }
    }
}
*/
Another solution 
Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 1; i <= n; i++) {
            int left = sc.nextInt();
            int right = sc.nextInt();
            if(left==-1|| right==-1){
                list.add(i);
            }
        }
        Collections.sort(list);
        for(int ele: list){
            System.out.print(ele+" ");
        }


Sum of leaves Problem Statement
Given a Binary Tree, your task is to compute the sum of all leaf nodes in the tree.
Note :- All the nodes in the tree are distinct .
Constraints:
1 <= T <= 100
1 <= N <= 10^5
1 <= node values <= 10^5
Sum of "N" over all test cases does not exceed 2*10^5 
Output Return the sum of all the leaf nodes of the binary tree.
Example
Sample Input:
2
3
10 8 34
2
48 36

Sample Output:
42
36
/*
 class Node {
    int data;
    Node left, right;

    Node(int data) {
        this.data = data;
        left = null;
        right = null;
    }
}
*/
static int sumLeaf;
public static int sumOfLeaf(Node root){
   
    if (root == null)
			return 0;
	
          //System.out.println(root.left.data);
		// add root data to sum if root is a leaf node
		if (root.left == null && root.right == null)
			return root.data;

		return sumOfLeaf(root.left) + sumOfLeaf(root.right);
 }

ZigZag Traversal
https://www.geeksforgeeks.org/zigzag-tree-traversal/
Medium
Problem Statement
Given a Binary Tree containing N nodes. The task is to print the nodes of binary tree in ZigZag manner. Below diagram shows nodes of binary tree printed in ZigZag manner.
ZigZag: While traversing binary tree level wise you have print the nodes from left to right and then right to left alternatively i.e. first level from left to right, next level right to left, then again left to right and so on.
Constraints:
1 <= T <= 50
1 <= N <= 10^4
Sum of N over all testcases does not exceed 10^5
Output
For each test case you need to return the ArrayList containing node values of binary tree in ZigZag manner. The driver code will take care of printing them up.
Example
Input:
2
3 2 1
7 7 9 8 8 6 N 10 9
Output:
3 1 2
7 9 7 8 8 6 9 10
Explanation:
Testcase 1: Given tree is
3
/ \
2 1
Hence the zigzag traversal will be 3 1 2.
Testcase 2: Given tree is
7
/ \
7 9
/ \ / \
8 8 6 N
/ \
10 9
Hence the zigzag traversal will be 7 9 7 8 8 6 9 10.

/*
 // Information about the class Node
    class Node
    {
        int data;
        Node left,right;
        Node(int data){
        this.data = data;
        left=null;
        right=null;
    }
    }
*/

static ArrayList<Integer> zigZagTraversal(Node root){
     // Your code here
     ArrayList<Integer> ans = new ArrayList<Integer>();
        // if there is no element in the tree,return empty
        // arraylist
        if (root == null)
            return ans;
        Queue<Node> q = new LinkedList<Node>();
        q.add(root);
        // this variable helps to check if elements are to be added from left to right or right to left
        boolean leftToRight = true;
        while (q.size() > 0) {
            int size = q.size();
            // this arraylist is used to store element at current level
            ArrayList<Integer> temp = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                Node curr = q.poll();
                if (curr.left != null)
                    q.add(curr.left);
                if (curr.right != null)
                    q.add(curr.right);
                temp.add(curr.data);
            }
            if (leftToRight) // at current level,add element from left to right to our / answer
            {
                // do nothing
            }
            // we have to add element from to right to left and this can be done by reversing our temp arraylist
            else {
                Collections.reverse(temp);
            }
            // add element form temp arraylist to our ans
            // arraylist
            for (int i = 0; i < temp.size(); i++) {
                ans.add(temp.get(i));
            }
            // change the value of leftToRight from true to
            // false or false to true for next iteration.
            leftToRight = !(leftToRight);
        }
        // return our ans arraylist
        return ans;
}

Short Tree hard https://codeforces.com/contest/1087/submission/147850094   https://vjudge.net/problem/CodeForces-1087D
Time Limit: 2 sec
Memory Limit: 128000 kB
Given a tree with N nodes,
Saloni wants to put weights on all edges of the tree so that all weights are non-negative real numbers and their sum is s. At the same time, she wants to make the diameter of the tree as small as possible.
Let's define the diameter of a weighed tree as the maximum sum of the weights of the edges lying on the path between two some vertices of the tree. In other words, the diameter of a weighed tree is the length of the longest simple path in the tree, where length of a path is equal to the sum of weights over all edges in the path.
Find the minimum possible diameter that Saloni can get.
Input The first line contains two integer numbers n and s, the number of vertices in the tree and the sum of edge weights.
Each of the following n−1 lines contains two space-separated integer numbers ai and bi (1≤ ai, bi ≤n, ai≠bi) — the indexes of vertices connected by an edge. The edges are undirected.
It is guaranteed that the given edges form a tree.
Constraints 1 <= n <= 100000 1 <= s <= 1000000000
Output
If the minimum diameter of the tree that Vanya can get by placing some non-negative real weights on its edges with the sum equal to s is d, print floor(d).
Example
Sample Input
4 3
1 2
1 3
1 4
Sample Output 2
Sample Input
5 5
1 2
2 3
3 4
3 5
Sample Output 3
Explanation: In the first sample, we place 1 weight on each of the given edges. In the second sample, we place weights 1.6666... on edges (1, 2), (3, 4), (3, 5). Therefore, minimum diameter achieved is equal to 3.333...

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        int N = 100007;
        Scanner sc = new Scanner(System.in);        
        int[] du = new int [N];
        int n,s;
        n = sc.nextInt();
        s = sc.nextInt();
        for(int i = 1;i < n; i++){
            int a,b;
            a = sc.nextInt();
            b = sc.nextInt();
            du[a]++;
            du[b]++;
        }
        int num=0;
        for(int i = 1; i <= n;i++){
            if(du[i] == 1){
                num++;
            }
        }
        //System.out.println(Math.floor(2.0 * (double) s / (double) num));
        System.out.println(2 * (int) s / (int) num);
        //printf("%.8lf\n",2.0*(double)s/(double)num);
    }
}


https://www.geeksforgeeks.org/diameter-of-a-binary-tree-in-on-a-new-method/
Given a Binary Tree, find diameter of it. The diameter of a tree is the number of nodes on the longest path between two leaves in the tree. The diagram below shows two trees each with diameter nine, the leaves that form the ends of a longest path are shaded (note that there is more than one path in each tree of length nine, but no path longer than nine nodes).
Since this will be a functional problem. You don't have to take input. You just have to complete the function getDiameter() that takes "root" node as parameter.
Constraints:
1 <= T <= 100
1 <= N <= 10^4
1 <= node values <= 10^3
Sum of "N" over all testcases does not exceed 10^5
For Custom Input:
First line of input should contains the number of test cases T. For each test case, there will be two lines of input.
First line contains number of nodes N. Second line will be a string representing the tree as described below:
The values in the string are in the order of level order traversal of the tree where, numbers denote node values, and a character “N” denotes NULL child.
Note: If a node has been declared Null using 'N', no information about its children will be given further in the array.
Output Return the diameter of the tree.
Example
Sample Input:
2
3
1 2 3
5
10 20 30 40 60

Sample Output:
3
4

Explanation:
Test Case1: The tree is
1
/ \
2 3
The diameter is of 3 length.
Test Case2: The tree is
10
/ \
20 30
/ \
40 60
The diameter is of 4 length.
/*
// Information about the class Node
class Node {
    int data;
    Node left;
    Node right;
    Node(int data) {
        this.data = data;
        left = null;
        right = null;
    }
}

*/
public static int getDiameter(Node root) {
    // Your code here
    // you can create your own helper function     
   if (root == null)
        return 0;
 
    // This will store the final answer
    A a = new A();
    int height_of_tree = height(root, a);
    return a.ans;
 }
 static class A{
    int ans = Integer.MIN_VALUE;
}
 static int height(Node root, A a){
    if (root == null)
        return 0;
 
    int left_height = height(root.left, a);
 
    int right_height = height(root.right, a);
 
    // update the answer, because diameter of a
    // tree is nothing but maximum value of
    // (left_height + right_height + 1) for each node
    a.ans = Math.max(a.ans, 1 + left_height +  right_height);
 
    return 1 + Math.max(left_height, right_height);
}

Backtracking - In Class and Post Class

Even Supremacy
Sara has N even numbers with her in which all even numbers from 2 to N appear exactly once except for one number which appears exactly K times. 
Given the sum of all the numbers S, N, and K, your task is to find the repeated number.
The input contains two space-separated integers N, K, and S.
Constraints:-
1 <= N, S <= 1000000
2 <= K <= 100000
Output Print the repeated number, it is guaranteed that for the given test case there exists a set of numbers that fulfill the given conditions.
Sample Input:-5 3 14
Sample Output:-4
Explanation:-
numbers:- {2, 4, 4, 4} 

class Main {
    public static void main (String[] args) {
                      // Your code here
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int s = sc.nextInt();
        int sum =0;
        for(int i=2; i<=n; i=i+2){
            sum += i;
        }
        s = s-sum;
        System.out.println(s/(k-1));
    }
}

Possible Words From Phone Digits 
https://www.youtube.com/watch?v=CUqylcHwWls
https://www.geeksforgeeks.org/find-possible-words-phone-digits/
Aunt May receives a letter from Peter’s school that his grades are going down. So she decides to confiscate his phone. One day when Aunt May has gone shopping, Peter decides to get his phone back. He tries unlocking the phone but soon realizes that it is locked. So he puts on his detective cap and analyses the fingerprints of his Aunt on most keypads. He soon dials down the most used number. Help Peter make a list of all possible passwords using N digits.
Given a keypad as shown in diagram, and an N digit number. List all words which are possible by pressing these numbers.
By pressing a digit you can access any of its mentioned characters.
Constraints:
1 <= T <= 100
1 <= N <= 9
2 <= D[i] <= 9
Print all possible words in lexicographical order.
Example Sample Input:
2
3
2 3 4
3
3 4 5
Sample Output:
adg adh adi aeg aeh aei afg afh afi bdg bdh bdi beg beh bei bfg bfh bfi cdg cdh cdi ceg ceh cei cfg cfh cfi
dgj dgk dgl dhj dhk dhl dij dik dil egj egk egl ehj ehk ehl eij eik eil fgj fgk fgl fhj fhk fhl fij fik fil
Explanation:
Testcase 1: When we press 2, 3, 4 then adg, adh, adi, ., cfi are the list of possible words.
Testcase 2: When we press 3, 4, 5 then dgj, dgk, dgl,. , fil are the list of possible words.

class Main {
    static Character[][] numberToCharMap;
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int tc = sc.nextInt();
        
        for(int i = 0; i<tc; i++){
            
            int n = sc.nextInt();
            int[] arrDigits = new int[n];
            for(int j = 0; j < n; j++){
                arrDigits[j] = sc.nextInt();
                //System.out.print(arrDigits[j] + " ");
            }   

            generateNumberToCharMap();
            List<String> stringList = possibleWordsFromPhone(arrDigits, arrDigits.length, 0, "");
            //stringList.stream().forEach(System.out :: println);
            stringList.forEach(value -> System.out.print(value + " "));
            System.out.println();
            
        }

    }

    private static void generateNumberToCharMap(){
        numberToCharMap = new Character[10][5];
        numberToCharMap[0] = new Character[]{'\0'};
        numberToCharMap[1] = new Character[]{'\0'};
        numberToCharMap[2] = new Character[]{'a','b','c'};
        numberToCharMap[3] = new Character[]{'d','e','f'};
        numberToCharMap[4] = new Character[]{'g','h','i'};
        numberToCharMap[5] = new Character[]{'j','k','l'};
        numberToCharMap[6] = new Character[]{'m','n','o'};
        numberToCharMap[7] = new Character[]{'p','q','r','s'};
        numberToCharMap[8] = new Character[]{'t','u','v'};
        numberToCharMap[9] = new Character[]{'w','x','y','z'};
    }
  
    private static List<String> possibleWordsFromPhone(int[] numbers, int len, int numIndex, String s) {
        if(len == numIndex){
            return new ArrayList<>(Collections.singleton(s));
        }
            
        List<String> stringList = new ArrayList<>();
        
        for(int i = 0; i < numberToCharMap[numbers[numIndex]].length; i++){
            String strCopy = String.copyValueOf(s.toCharArray());
            
            strCopy = strCopy.concat( numberToCharMap[numbers[numIndex]][i].toString());
            //Recusive call
            stringList.addAll(possibleWordsFromPhone(numbers, len, numIndex + 1, strCopy));
        }
        return stringList;
    }
}



IP addresses 
https://www.youtube.com/watch?v=qu4W3idglP4
https://www.geeksforgeeks.org/program-generate-possible-valid-ip-addresses-given-string/
https://www.geeksforgeeks.org/program-to-generate-all-possible-valid-ip-addresses-from-given-string-set-2/?ref=lbp
Given a string S of digits. Your task is to generate all possible IP addresses from the given string.
Note:- A valid IP address consists of exactly four integers, each integer is between 0 and 255, separated by single dots and cannot have leading zeros. For example, "0.1.2.201" and "192.168.1.1" are valid IP addresses and "0.011.255.245", "192.168.1.312" and "192.168@1.1" are invalid IP addresses.
Input Input contains a single string S.
Constraints:-
4 <= |S| <= 12
S will contain digits from 1 to 9.
Print all the IP addresses in sorted order. Note:- It is guaranteed that at least one ans will exist.
Sample Input:-
12345
Sample Output:-
1.2.3.45
1.2.34.5
1.23.4.5
12.3.4.5
Sample Input:-1111
Sample Output:-1.1.1.1

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        String str = sc.nextLine();

        ArrayList<String> result = new ArrayList<>();

        generateIPAddresses(str, 0, str.length() - 1, 1, "", result);

        for (String strRes : result)
            System.out.println(strRes);
    }

    static void generateIPAddresses (String s, int i, int j, int partition, String ans, ArrayList<String> res){
        if (i == (j + 1) && partition == 5) {
            res.add(ans.substring(1));
        }

        // Digits of a number ranging 0-255 can lie only between 0-3
        //partition karenge i + 1 i + 2 i + 3 decide the whre the point we can put for validate
        for (int k = i; k < i + 3 && k <= j; k++) {
            String ad = s.substring(i, k + 1);

            // Return if string starting with '0' or it is greater than 255.
            if ((s.charAt(i) == '0' && ad.length() > 1 ) || Integer.valueOf(ad) > 255)
                return;

            // Recursively call for another level.
            generateIPAddresses(s, k + 1, j, partition + 1, ans + '.' + ad, res);
        }
    }
}



Max String https://www.geeksforgeeks.org/find-maximum-number-possible-by-doing-at-most-k-swaps/
Given a string S and an integer K, your task is to find the lexicographically maximum string after performing at most K swaps.
Input The first line of input contains a single string S. The next line of input contains the value of K.
Constraints:-
1 <= |S| <= 9
S contains digits from 1 to 9
1 <= K <= 4
Print the lexicographically maximum string after performing at most K swaps.
Example
Sample Input:-
132
2
Sample Output:-321
Sample Input:-
254
1
Sample Output:-524
Sir solution also pending


class Main {
    static String max;
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in); 
        String str  = sc.nextLine();
        int k = sc.nextInt();
        max = str;
        findMaximumNum(str.toCharArray(), k);
        System.out.println(max);
    }
   
    // Function to find maximum integer possible by doing at-most K swap operations on its digits
    static void findMaximumNum(char[] str, int k){
    // Return if no swaps left
        if (k == 0)
            return;
        
        int n = str.length;
        
        // Consider every digit
        for (int i = 0; i < n - 1; i++) {
            // Compare it with all digits // after it
            for (int j = i + 1; j < n; j++) {
            // if digit at position i is less than digit at position j, swap it/ and check for maximum
            // number so far and recurse for remaining swaps
                if (str[i] < str[j]) {
                    // swap str[i] with str[j]
                    char t = str[i];
                    str[i] = str[j];
                    str[j] = t;
            
                    // If current num is more than maximum so far
                    if (String.valueOf(str).compareTo(max) > 0)
                    max = String.valueOf(str);
            
                    // recurse of the other k - 1 swaps
                    findMaximumNum(str, k - 1);
            
                    // Backtrack
                    char c = str[i];
                    str[i] = str[j];
                    str[j] = c;
                }
            }
        }
    }
 
}

Count Numbers https://hjweds.gitbooks.io/leetcode/content/count-numbers-with-unique-digits.html
https://gist.github.com/yitonghe00/827e209ed55ec66275ae70abb0ed223d
Given an integer N, print the count of all numbers with unique digits, x, where 0 <= x < 10^N.
InputFirst line contains a single integer N.
Constraints:
0 <= N <= 8
OutputPrint the count of all numbers with unique digits, x
Sample Input 1: 2
Sample Output 1:91
Explanations:
The answer should be the total numbers in the range of 0 ≤ x < 100, excluding 11, 22, 33, 44, 55, 66, 77, 88, 99.
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        int res = countNumbersWithUniqueDigits(n);
        System.out.println(res);
    }
    public static int countNumbersWithUniqueDigits(int n) {
        return doCount(n, new boolean[10], 0);
    }
                                              //d-th place starting from 0
    private static int doCount(int n, boolean[] used, int d) {
        if (d == n) return 1;
        int total = 1;
        
        for (int i = (d == 0) ? 1 : 0; i <= 9; i++) {
            if (!used[i]) {
                used[i] = true;
                total += doCount(n, used, d + 1);
                used[i] = false;
            }
        }
        return total;
    }
}



Greedy Algorithms

Minmax Moves easy
N cards are placed on an infinite number line. You are given an array(a) of size N where a[i] denotes the position of i- th card. The card is said to be an end- card if the card has a smallest or largest position.
In one turn, you can pick an end- card and place it at any position between the current endpoints which is unoccupied so that it no longer remains end- card.
For eg, if a = [2, 3, 6] you cannot move card at position 6 as moving it to position 1 or 4 would still keep it as an end- card(moving card at position 2 to position 4 is a valid move).
Onceall the cards are in consecutive positions you cannot make a valid move and the game ends.
Print the minimum and maximum valid moves possible when the game ends.
Input First line contains N - the number of cards.
The next line contains N elements denoting the position of cards.
Constraints:-
3<= N <=10^4
1<= position of cards <=10^9
All the positions are distinct.
Output Print minimum moves and maximum moves separated by space.
Example Sample Input:-
3
8 5 10
Sample Output:- 1 2
Explanation:- As the card at position 5(a[1]) has minimum position and the card at position 10(a[2]) has the maximum position, cards at position 5 and position 10 are end cards.
a = [8, 5, 10], min moves = 1(move card at 5 - > 9), max moves = 2(10 - > 6 then 5 - > 7) 

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int n = s.nextInt();
        long[] arr = new long[n];

        for (int i = 0; i < n; i++) {
            arr[i] = s.nextLong();
        }
        Arrays.sort(arr);
        long min = Long.MAX_VALUE;
        long move1 = (arr[n - 1] - arr[1]) - (n - 2);
        long move2 = (arr[n - 2] - arr[0]) - (n - 2);
        long max = Math.max(move1, move2);
        int i = 0, j = 0;
        long size = 0;
        long card = 0;
        while (j < n) {
            size = arr[j] - arr[i] + 1;
            card = j - i + 1L;
            if (size > n) {
                i++;
            } else {
                if (size == n - 1 && card == n - 1) {
                    min = Math.min(min, 2);
                } else {
                    min = Math.min(min, n - card);
                }
                j++;
            }
        }
        System.out.print(min + " " + max);

        /*Arrays.sort(arr);
        ArrayList<Integer> list = new ArrayList<>();
        for(int i = 0; i< n - 1; i++){
            int diff = arr[i + 1] - arr[i] - 1;
            if (diff > 0)
                list.add(diff);
        }

        int min = minMoves(list);
        int max = maxMoves(list);
        Collections.reverse(list);
        int min2 = minMoves(list);
        System.out.println(Math.min(min, min2) + " " + max);*/

    }
    /*static int maxMoves(ArrayList<Integer> list){
        int s = list.size();
        if(s == 0) return 0;
        if(s == 1) return list.get(0);
        int sum = 0;
        for(int x : list) sum += x;
        return Math.max(sum - list.get(0), sum - list.get(s-1));
    }

    static int minMoves(ArrayList<Integer> list){
        int s = list.size();
        if(s == 0) return 0;
        if(s == 1){
            if(list.get(0) == 1)
                return 1;
            return 2;
        }

        int swap = 0;
        for(int i = 0; i<s; i++){
            int reqSwaps = s - swap - 1 - i;
            if(list.get(i) < reqSwaps)
                swap += list.get(i);
            else if(list.get(i) == reqSwaps){
                swap += list.get(i);
                break;

            }else{
                swap += reqSwaps + 1;
                break;
            }
        }
        return swap;
    }*/
}


MarathonMedium
There is a marathon to be run on a circular track. There are N checkpoints on the track where energy drinks are placed. Checkpoints are numbered from 1 to N (both inclusive). For each checkpoint, you know the distance to the next checkpoint and also the energy replenished by the drink at this checkpoint.
Toros is going to take part in the marathon. For every 1 unit distance covered by him, his energy decreases by 1. He can't run further if he has 0 energy. Find the minimum index of the point where he should start so that he can visit every checkpoint at least once. Initially, he has 0 energy.
Constraints
1 <= N <= 10^5
1 <= E[i], D[i] <= 10^9
Output
Print a single integer containing the minimum index of the checkpoint where Toros should start so that he can complete the race.
If no such point exists, print -1
Example
Sample Input:
3
1 5
10 3
3 4
Sample Output: 2
Explanation: Toros starts at index 2, drinks energy drink. So, current energy = 10. At index 3, energy = 10 - 3 + 3 = 10. At index 1 energy = 10 - 4 + 1 = 7. 
Anotherss Approach
class Main {
    public static void main (String[] args) {
  
        Scanner sc = new Scanner(System.in);

        int n = sc.nextInt();
        
        int E[] = new int[n];
        int D[] = new int[n];

        for(int i=0; i<n; i++) {
            E[i] = sc.nextInt();
            D[i] = sc.nextInt();
        }

        for(int i=0; i<n-1; i++) {
            int energy = E[i];
            boolean flag = true;
            int ind = i;
            for(int j = i + 1; j != i; j = (j + 1) % n) {
                energy -= D[ind];
                if(energy < 0) {
                    flag = false;
                    break;
                }
                energy += E[j];
                ind = (ind + 1) % n;
            }
            if(flag) {
                System.out.print(i+1);
                return;
            }
        }
        System.out.print(-1);

    }
}

My approach only test cases fails nedd to check
class Main {
    public static void main (String[] args) {
        // Scanner sc = new Scanner (System.in);
        // int n = sc.nextInt();
        // int[] energyDrinks = new int [n];
        // int[] distanceCheckPoint = new int[n];
        // for(int i = 0;i<n ; i++){
        //     energyDrinks[i] = sc.nextInt();
        //     distanceCheckPoint[i] = sc.nextInt(); 
        // }
        // System.out.println(checkMinIndex( energyDrinks, distanceCheckPoint);

    }

   public static int checkMinIndex(int[] energyDrinks, int[] distanceCheckPoint ) {
       for(int i = 0; i < energyDrinks.length ; i++ ){
            int temp = 0;
            for(int j = i; j < distanceCheckPoint.length + i ; j++ ){
                
                temp += energyDrinks[j % distanceCheckPoint.length] - distanceCheckPoint[j % distanceCheckPoint.length];
                //System.out.println( "j= "+ j + " % distanceCheckPoint.length " + distanceCheckPoint.length + " = " + (j % distanceCheckPoint.length));
                
                //System.out.println("energy " + energyDrinks[j % distanceCheckPoint.length]+ " distance = " + distanceCheckPoint[j % distanceCheckPoint.length]);
                
                //System.out.println(" i "+ i + " temp " + temp);

                if(temp<0){break;}
                
                if(temp >= 0 && j == (distanceCheckPoint.length + i-1)){
                    return i + 1;
                }
           }
       }
       return -1;
   }
}

also Another approach

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int num = Integer.parseInt(br.readLine()); 
        int[] arr1 = new int[num];
        int[] arr2 = new int[num];

        for (int i = 0; i < num; i++) {
            String s = br.readLine();
            String[] s1 = s.split(" ");
            arr1[i] = Integer.parseInt(s1[0]);
            arr2[i] = Integer.parseInt(s1[1]);

        }

        System.out.println(possible(arr1, arr2));
    }

    public static int possible(int[] boost, int[] distance) {

        int n = boost.length;
        for (int i = 0; i < n-1; i++) {
            int sumBoost = boost[i];
            boolean flag = true;
            int ind = i;
            for(int j = i+1; j != i; j = (j+1)%n){
                sumBoost -= distance[ind];
                if(sumBoost < 0) {
                    flag = false;
                   break;
                }
                sumBoost += boost[j];
                ind = (ind+1)%n;
            }
            if(flag) return i+1;

        }
        return -1;
    }

}

Police Officer's Vicinity easy
Somewhere, at some point of time, there was/will be a vehicular traveling system where 1 Kilometre is the basic unit of traversal, that is a vehicle can either stay at rest or can travel distance which is multiple of 1 Km i. e., 2, 3, 4, 10, 35 Km are valid but 2.5, 6.34, 0.25 Km are invalid.
During the age of this system, there is a traffic policeman who stands at the intersection of 4 roads. Due to Development in the City, there are a few barriers placed on some of the roads at some distance from the intersection point.
Measurements are according to the cartesian coordinates, each unit representing a kilometer. You enter into the system and are provided with a coordinate of the Intersection point and the maximum north distance a vehicle can cover, the maximum eastern distance a vehicle can cover and the coordinates of the barrier.
You have to tell the sum of the total kilometers in which the policeman has the vicinity.
Example: > The Coordinate of Intersection point: 4, 3
> The maximum north distance = 8Km
> The maximum East distance = 8Km
Coordinates of barrier = (1, 3); (4, 6); (5, 3).
Input First- line contains 2 integers denoting maximum north and east distance.
Second- line contains 2 integers denoting the coordinate of the intersection.
the third line contains an integer ‘k’ denoting the number of barriers
next line contains the coordinate of barriers.
Constraints:- 1<=north distance, east distance<=10000
(0, 0) <=coordinates of intersection<= (10000, 10000)
1<=number of barriers<=1000
(0, 0) <=coordinates of barriers<= (10000, 10000)
Output An integer denoting the sum of the kilometers in which the police officer has his vicinity.
Example Sample Input:
8 8
4 3
3
1 3 4 6 5 3
Sample output: 6


import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner scan = new Scanner(System.in);
		int n = scan.nextInt();
		int e = scan.nextInt();
		int x = scan.nextInt();
		int y = scan.nextInt();
		int k = scan.nextInt();
		int u = n, d = 1,l = 1,r = e;
		for(int i = 0; i < k; i++){
			int a,b;
			a = scan.nextInt();
			b = scan.nextInt();
			if(a == x){
				if(b<y)
					d=b+1;
				else
					u=b-1;
			}
			else if(b == y)	{
				if(a<x)
					l = a+1;
				else
					r=a-1;
			}
		}
		System.out.println(r-l+u-d);
    }
}

Minimum number of coins
Write a program to find the minimum number of coins/ notes required to make the change of A amount of money.
For this problem, you can assume that there is an unlimited supply of the various notes/coins available in the Indian currency denominations. The various denominations available are 1, 2, 5, 10, 20, 50, 100, 200, 500 and 2000.
Input
The first line of the input contains the number of test cases T.
Each test case contains a single input A(amount).
Constraints:
1 <= T <= 100000
1 <= A <= 10^5
Output
For each test case, print the minimum number of changes of amount A.
Example
Input:
5
90
110
131
1111
23
Output:
3
2
4
5
3
Explanation:-
A = 90
O/P = 3 [50, 20, 20]
A = 120
O/P = 2 [100, 20]
Both appriach runing
https://www.geeksforgeeks.org/greedy-algorithm-to-find-minimum-number-of-coins/?ref=lbp

class Main {
    
    // All denominations of Indian Currency 
    static int denominations[] = {1, 2, 5, 10, 20, 50, 100, 200,500, 2000};
    static int n = denominations.length;
    
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int testCases =  sc.nextInt();
        for(int i = 0 ; i<testCases; i++){
            //arrAmount = new int[testCases];
            //arrAmount[i] = sc.nextInt();  
            int amount  = sc.nextInt(); 
            findMinNumCoins( amount);
            // int change = 0;
            // for(int j = n - 1; j >= 0; j--){
            //     change += amount / denominations[j];
            //     amount -= denominations[j] * (amount / denominations[j]);
            // }
            // System.out.println(change);
        }
    }
  
    public static void findMinNumCoins(int V) {
        int count = 0;
        Vector<Integer> ans = new Vector<>();
        // Traverse through all denomination 
        for (int i = n - 1; i >= 0; i--){
            // Find denominations 
            while (V >= denominations[i]){
                V -= denominations[i];
                ans.add(denominations[i]);
                count ++;
            }
        }
        // Print result 
        //for (int i = 0; i < ans.size(); i++){
            //System.out.print(" " + ans.elementAt(i));
            System.out.println(count);
        //}
    }
}



Increasing array
Abhijit has an Array Arr which may or may not be in strictly increasing order. He wants to make this array increasing but does not wish to change the position of any element so he came with an idea that he will replace an element with any of its divisors i.e he changes an element X to M if X%M=0.
Your task is to tell whether the given array can be transformed to strictly increasing by performing the operation given above.
Constraints:-
1 <= N <= 100000
1 <= Arr[i] <= 100000
Output
Print "YES" if the array can be transformed in the strictly increasing order else print "NO".
Sample Input:-
5
1 2 16 16 16

Sample Output:-YES
Sample Input:-
4
1 3 8 4
Sample Output:-NO

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int arrSize = sc.nextInt();
        int[] arr = new int[arrSize];
        for(int i =0; i< arrSize ; i++){
            arr[i] = sc.nextInt();
        }

        int divisor = 1;
        // in whole we divisior for the elemnt so printing at end yes
        for(int i = 0; i < arrSize; i++){
            //also another way with cleaner code
            //if(arr[i] % divisor == 0){
            //    divisor ++;
            //}else{
                //till the time divisor divide the arr element and not divdind the element
                // and also chekcing the divisor less equal to arr element or dvisor bada hogya not following strictly inceres order
                //if divid then the while break
                while(divisor <= arr[i] && arr[i] % divisor != 0){
                    divisor ++;
                }
                if(divisor > arr[i]){
                    System.out.println("NO");
                    return;
                }
                // for next value divisor sholud increment that why here
                divisor ++;
            //}
        }
        System.out.println("YES");
    }
}