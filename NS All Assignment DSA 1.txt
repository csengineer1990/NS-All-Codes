https://www.youtube.com/watch?v=ogeXK-aKOoU&t=165s How To Left Rotate Array In Java Explained Step By Step | Hacker Rank | Java Tutorial | Code Bode

https://www.youtube.com/@nesoacademy/videos  ****imp**

https://leetcode.com/discuss/interview-question/352743/Google-or-Onsite-or-Guaranteed-Binary-Search-Numbers

https://github.com/oleg-cherednik/DailyCodingProblem/tree/master/%23000%20-%20%23099 -- ****problems listcomanies
https://www.linkedin.com/in/saurav09/
https://www.youtube.com/c/AnuragCodes/videos  ******

https://github.com/nvedansh/NewtonSchoolFalconBatc
//newton old evrthing data
****https://docs.google.com/spreadsheets/u/0/d/1vWgJrtpHlNpdBxPp16-gHEEdokL19HnmXOngZrAywJE/htmlview

https://www.youtube.com/playlist?list=PL7ersPsTyYt2F9hktOuM64J5dAAL3zSIB  --interviewrgiven

https://www.callicoder.com/two-sum-problem/ ---tobecheck intview question

Test 2 ques 7/7/22 https://www.geeksforgeeks.org/minimize-sum-product-two-arrays-permutations-allowed/ 
https://www.codingbroz.com/day-11-2d-arrays-solution/  ----mostIMportatnt
https://www.youtube.com/watch?v=LgLcWJrfLmQ ---pascal triangle

https://github.com/nvedansh/NewtonSchoolFalconBatch/commit/7cf7ab5b6dc571f42f48d5dfae6db002721d632e#diff-c63a06f2b1459e488615fc49c5a4f9f5ea28d3cabf72ad22ba5d0e798fba5bcb

https://www.geeksforgeeks.org/check-whether-an-array-can-be-made-strictly-increasing-by-modifying-atmost-one-element/

https://www.geeksforgeeks.org/convert-to-strictly-increasing-integer-array-with-minimum-changes/?ref=lbp

https://www.geeksforgeeks.org/for-each-lowercase-english-alphabet-find-the-count-of-strings-having-these-alphabets/?ref=lbp

to be check https://www.youtube.com/watch?v=MHocw0bP1rA
/**** Matchsticks to square links
https://dev.to/seanpgallivan/solution-matchsticks-to-square-2fk8#idea
https://dev.to/seanpgallivan/solution-matchsticks-to-square-2fk8
https://www.youtube.com/watch?v=w-R8qAtsP1A
https://www.tutorialcup.com/leetcode-solutions/matchsticks-to-square-leetcode-solution.htm
https://leetcode.com/problems/matchsticks-to-square/solution/
*/

https://www.codechef.com/problems/XRGRD --- tobecheck XOR GRID

https://github.com/saidrishya/geeksforgeeks-solutions/blob/master/find%20triplets%20with%20sum%200
https://www.callicoder.com/two-sum-problem/

https://www.adaface.com/assessment-test/computer-programmer-aptitude-test
Revision question
main(){
int i = 0;
for(int i=1;i<=n^4; i++){
for(int i=1;i<=n^4; i++){
for(;ix=y+z;
}
}
}

1.O(n^7)
2.O(n^9)
3.O(n^6)
4. non terminating


main(){
int i = n;
while(i>1){
i = i / 8;
i = i / 13;
i = i * 4;
i = i +5+7;
i = i - 8;
}
}

1. O(log35n)
2. O(log26n)
3. 0(n^6)
4. O(log416n)

int fibo(int n){
	if(n == 1)
		return 0;
	else if(n == 1)
		return 1;
	return fibo(n - 1) + fibo(n - 2);
}

int main(){
	int n = 5;
	int ans = fibo(n);
	printf("%d",ans);
	return 0;
}

1. O(1)
2. O(2 * n)
3. O(n ^ 2)
4. O(2 ^ n)


void func(){
	for(int i=0;i<n; i++){
		for(int j=0; j < n; j++){
			print("i + j");	
		}
	}
}

1. O(logN)
2. O(N)
3. O(NlogN)
4. O(N*N)
The time complexity of the func function is O(N^2). This is because the function contains two nested for loops that both iterate over the range 0 to n. This means that the inner loop will be executed a total of N times, and the outer loop will be executed a total of N times. This results in a total of N * N = N^2 iterations of the inner loop, which gives a time complexity of O(N^2).


which of the following has the same complexity as log(n!)
1. O(logN)
2. O(N)
3. O(NlogN)
4. O(N^2)
The time complexity of log(n!) is O(NlogN).

The factorial of a number n, represented as n!, is the product of all the positive integers from 1 to n. For example, 5! = 1 * 2 * 3 * 4 * 5 = 120. The time complexity of calculating n! is O(N), because it involves a loop that iterates over the range 1 to n.

The logarithm of a number is the exponent to which a base must be raised to produce that number. For example, the logarithm of 100 (base 10) is 2, because 10^2 = 100. The time complexity of calculating the logarithm of a number is O(logN), because it involves dividing the number by the base until it is reduced to 1.

Therefore, the time complexity of log(n!) is O(NlogN), because it involves both O(N) and O(logN) operations.


int i = 0, j = 0;
int cnt = 0;

while(i < n){
	while(j < i && arr[j] > arr[i]){
		j++;
		cnt ++;
	
	}
	i++;
}

1. O(N)
2. O(logN)
3. O(NlogN)
4. O(N^2)




def leftRotate(arr, k):
    rot = []
    n = len(arr)  
    mod = k % n   
    for i in range(n): 
        rot.append(int(arr[(mod + i) % n])) 
    return rot

WalterWhite
n, x = map(int, input().split())
arr1 = list(map(int, input().split()))
c = int(input())
arr2 = list(map(int, input().split()))
i = 0
count = 0
while i+x <= n:
    for j in range(c):
        if arr1[i:i+x] == leftRotate(arr2, j):
            count+=1 
            break
    i+=1
print(count)



Tobe Check everything Palindrome pair logic program
public static int max(String s) {
    int max = 0;
    for (int i = 1; i < s.length()-1; ++i) {
        String p1 = bestPalyndrome(s, 0, i);
        String p2 = bestPalyndrome(s, i, s.length());
        int prod = p1.length()*p2.length();
        if (prod > max) {
            System.out.println(p1 + " " + p2 + " -> " + prod);
            max = prod;
        }
    }
    return max;
}

public static String bestPalyndrome(String s, int start, int end) {
    if (start >= end) {
        return "";
    } else if (end-start == 1) {
        return s.substring(start, end);
    } else  if (s.charAt(start) == s.charAt(end-1)) {
        return s.charAt(start) + bestPalyndrome(s, start+1, end-1)
                + s.charAt(end-1);
    } else {
        String s1 = bestPalyndrome(s, start, end-1);
        String s2 = bestPalyndrome(s, start+1, end);
        return s2.length() > s1.length() ? s2 : s1;
    }
}

Interesting facts about null in Java --https://www.geeksforgeeks.org/interesting-facts-about-null-in-java/?ref=lbp
Segregate 0s and 1s in an array -- https://www.geeksforgeeks.org/segregate-0s-and-1s-in-an-array-by-traversing-array-once/
https://www.youtube.com/watch?v=90Iu1YrbfI4 ---to watch sort string array using set
https://www.geeksforgeeks.org/reversal-algorithm-right-rotation-array/

https://www.softwaretestinghelp.com/java-stack-tutorial/ ---stack

https://www.geeksforgeeks.org/longest-palindrome-substring-set-1/
https://stackoverflow.com/questions/53663721/find-the-maximum-product-of-two-non-overlapping-palindromic-subsequences

inteview asked 5822
https://leetcode.com/problems/sort-an-array/discuss/580488/java-simple-random-pivot-quick-sort

Rotate a matrix by 90 degree in clockwise direction without using any extra space 2d array
https://www.geeksforgeeks.org/rotate-a-matrix-by-90-degree-in-clockwise-direction-without-using-any-extra-space/

Mentor Batch Shuffling Contest- Mentors - 
Mod Square You are given an array P of size N. You have to find the maximum value of Pi % Pj for all possible i, j pairs.
Constraints:
2 <= N <= 105
1 <= Pi <= 109
Output
Print the maximum value of Pi % Pj for all possible i, j pairs in the array.
Example
Sample Input:
5
8 6 7 9 4

Sample Output: 8
Explanation:
i = 1, j = 4 (1-based indexing) will give the maximum possible result over all (i, j) pairs.


class Main {
    public static void main (String[] args) {
        Scanner sc =new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i = 0;i <n ; i++){
            arr[i] = sc.nextInt();
        }
		
        System.out.println(getMaxValue(arr, n));
    }

    static int getMaxValue(int arr[], int arr_size)	{
		int i, first, second;

		// There must be at least two elements
		if (arr_size < 2){
			return 0;
		}
		// To store the maximum and the second
		// maximum element from the array
		first = second = Integer.MIN_VALUE;
		for (i = 0; i < arr_size; i++){

			// If current element is greater than first
			// then update both first and second
			if (arr[i] > first)	{
				second = first;
				first = arr[i];
			}
			
			// If arr[i] is in between first and
			// second then update second
			else if (arr[i] > second && arr[i] != first){
				second = arr[i];
			}
		}

		// No second maximum found
		if (second == Integer.MIN_VALUE){
			return 0;
		}
		else{
			return second;
		}
	}

}

https://www.geeksforgeeks.org/an-in-place-algorithm-for-string-transformation/
https://stackoverflow.com/questions/12338654/move-all-odd-positioned-element-to-left-half-and-even-positioned-to-right-half-i

Top K Players Contest 30-10-22 easy
The Newton City is going to participate in a Basket Ball tournament. You have been made the coordinator for the final team selection committee.
Lot of applications have been received and you are given with a two integer arrays. First array, height[], stores the height of the player while the second array, basketsScored[], has the number of Baskets scored for each player.
To find the top K players, you need to choose players according to their heights, that means greater the height, more suitable is the player. If height of two players is same then consider the player with greater number of baskets.
Print the heights and the baskets of the top K players.
Input
First line of the input takes the number of test cases, T. Further, for each test case, first line contains two space separated integers, N and K. Next two lines contains N space separated integers denoting the height of the players and basketsScored.

Constraints:
1 <= N <= 10^6
1 <= K <= N
1 <= height[i] <= 10^6
0 <= basketsScored[i] <= 10^6
Output
For each test case, print the K players on next lines and in each line print the value of height and basketsScored with space separation.
Example
Input:
5 3
1 3 3 3 5
1 2 3 1 2

Output:
5 2
3 3
3 2

Explanation: The top 3 players will be the one with greater heights, and the players with larger no. of baskets in case of same heights.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Pair{
    int x;
    int y;
    Pair(int x, int y){
        this.x = x;
        this.y = y;
    }
}
class Main {
    public static void main (String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] str = br.readLine().split(" ");
        int n = Integer.parseInt(str[0]);
        int k = Integer.parseInt(str[1]);

        Pair[] arr = new Pair[n];
        str = br.readLine().split(" ");
        for(int i = 0 ; i < n; i++){
            arr[i] = new Pair(Integer.parseInt(str[i]),0);
            //System.out.print(arr[i].x + " ");
        }
             //System.out.println();
        str = br.readLine().split(" ");
        for(int i = 0 ; i < n; i++){
            arr[i].y = Integer.parseInt(str[i]);
             //System.out.print(arr[i].y + " ");
        }
        //System.out.println();
        Arrays.sort(arr, new Comparator<Pair>(){
            @Override
            public int compare(Pair p1, Pair p2){
                if(p1.x < p2.x){
                   // System.out.print("if me hai " + p1.x + " "+ p2.x);
                    return 1;
                }else if(p1.x == p2.x){
                    
                    if(p2.y > p1.y){
                        //System.out.println("else ke if me hai x == " + p1.x + " "+ p2.x);
                        //System.out.println("else ke if ke if me hai y == "  + p2.y + " "+ p1.y);
                        return 1;
                    }
                }
                return -1;
            }
        });
        for(int i = 0; i < k; i++){
            System.out.println(arr[i].x + " "+ arr[i].y);
        }
    }
}

Yet another Subsequence Problem easy

Given an array A of N integers. You have to find whether A has some subsequence of length at least 3 that is a palindrome.
First line of the input contains an integer N.
The second line of the input contains N space seperated integers.
Constraints:
1 <= N <= 5000
1 <= Ai <= 109
Output
Print "YES" if A has some subseqeuence of length at least 3 that is a palindrome, else print "NO", without the quotes.
Sample Input:
5
1 5 2 2 1
Sample Output:
YES
Explanation:
We pick the elements at indices 1, 3, 4, 5 (1- indexed) making the subsequence: [1, 2, 2, 1], which is a palindrome.
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
    public static void main (String[] args) {
        Scanner sc =  new Scanner (System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i = 0; i < n; i++){
            arr[i] = sc.nextInt();
        }
        // boolean pal = false;
        // for(int i = 0; i < n; i++){
        //     for(int j = i + 2; j < n; j++){
        //         if(arr[i] == arr[j]){
        //             pal = true;
        //         }
        //     }
        // }
        // if(pal== true)
        //     System.out.println("YES");
        // else
        //     System.out.println("NO");

        Map<Integer, Integer> freMap = new HashMap<>();
        for(int x : arr){
            freMap.put(x, freMap.getOrDefault(x,0) + 1);
        }

        for(int x: freMap.values()){
            if(x >= 3 ){
                System.out.println("YES");
                return;
            }
        }

        for(int x: freMap.values()){
            if(x == 2){
                System.out.println("YES");
                return;
            }
        }
        System.out.println("NO");
    }
}

Array Dominance (Contest)
Given an array A of N integers. You can arrange the array in any way possible. You have to find the maximum dominance of the array possible. Dominance of an array A of size N can be defined as:-
    Multiply all the integers at even indexes (1- indexed array) with -1.
    The sum of all elements of the array now formed is known as its dominance. 
Constraints:1 <= N <= 105 -109 <= Ai <= 109
OutputPrint the maximum dominance of the array after you shuffle it optimally.
ExampleSample Input:
6
4 1 5 8 6 2
Sample Output:12

Explaination:
We arrange the array as follows: [6, 2, 5, 4, 8, 1]
Now dominance = 6 + (-2) + 5 + (-4) + 8 + (-1) = 6 - 2 + 5 - 4 + 8 - 1 = 12
(Integers at even index are multiplied by -1).
It can be proved that no lesser dominance can be arrived at using any kind of arrangement.

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long k = 0;
        long l = 0;
        int arr[] = new int[n];
        for(int i = 0; i<n; i++){
            arr[i] = sc.nextInt();
            
        }
        Arrays.sort(arr);
        int x = arr.length/2;
        for(int i=0; i<arr.length/2; i++){
            
            k = k + arr[i];  
        }
         for(int i=arr.length/2; i<arr.length; i++){
            l = l + arr[i]; 
        }
        
        System.out.println(l - k);
    }
}


Proportionate Array (Contest)
You are given an array A having size 4. In one move, you can swap any two integers from this array. Find whether it is possible to have A0 : A1 == A2 : A3 after any number of moves.
Note: You don't have to minimize the number of moves. 
Sample Input:2 5 15 6
Sample Output:YES
Explaination: We can arrange the 4 numbers as follows: [2, 6, 5, 15]
Now, 2 : 6 = 1 : 3
5 : 15 = 1 : 3
As the final ratios come out to be equal, it is possible.

class Main {
    public static void main (String[] args) {
      Scanner sc = new Scanner (System.in);
        // int n = s;
        int min = Integer.MIN_VALUE;
        int max = Integer.MAX_VALUE;
        int x = 0;
        int y = 0;
        int arr[] = new int[4];
        for(int i=0; i<4; i++){
            arr[i] = sc.nextInt();
            
        }
       
        Arrays.sort(arr);
        if(arr[0] * arr[3] == arr[1] * arr[2]){
            System.out.println("YES");
        }
        else{
            System.out.println("NO");
        }
    }
}

MockHardQues 
dsahard2
Print all permutations of a string in Java
https://www.geeksforgeeks.org/print-all-permutations-of-a-string-in-java/

Delete last occurrence of an item from linked list
https://www.geeksforgeeks.org/delete-last-occurrence-of-an-item-from-linked-list/
https://www.tutorialcup.com/interview/linked-list/delete-last-occurrence.htm

dsa1 hard  https://www.youtube.com/watch?v=20v8zSo2v18 check with this pepcoding
Find subarray with given sum | Set 2 (Handles Negative Numbers)
Given an unsorted array of integers, find a subarray that adds to a given number. 
If there is more than one subarray with the sum of the given number, print any of them
Input: arr[] = {1, 4, 20, 3, 10, 5}, sum = 33
Output: Sum found between indexes 2 and 4
Explanation: Sum of elements between indices
2 and 4 is 20 + 3 + 10 = 33
Input: arr[] = {10, 2, -2, -20, 10}, sum = -10
Output: Sum found between indexes 0 to 3
Explanation: Sum of elements between indices
0 and 3 is 10 + 2 - 2 - 20 = -10
Input: arr[] = {-10, 0, 2, -2, -20, 10}, sum = 20
Output: No subarray with given sum exists
Explanation: There is no subarray with the given sum
Approach: The idea is to store the sum of elements of every prefix of the array in a hashmap, i.e, every index stores the sum of elements up to that index hashmap. So to check if there is a subarray with a sum equal to s, check for every index i, and sum up to that index as x. If there is a prefix with a sum equal to x – s, then the subarray with the given sum is found. 
Algorithm:  
    Create a Hashmap (hm) to store a key-value pair, i.e, key = prefix sum and value = its index, and a variable to store the current sum (sum = 0) and the sum of the subarray as s
    Traverse through the array from start to end.
    For every element update the sum, i.e sum = sum + array[i]
    If the sum is equal to s then print that the subarray with the given sum is from 0 to i
    If there is any key in the HashMap which is equal to sum – s then print that the subarray with the given sum is from hm[sum – s] to i
    Put the sum and index in the hashmap as a key-value pair.
class GFG {
 
    public static void subArraySum(int[] arr, int n, int sum) {
        //cur_sum to keep track of cumulative sum till that point
        int cur_sum = 0;
        int start = 0;
        int end = -1;
        HashMap<Integer, Integer> hashMap = new HashMap<>();
 
        for (int i = 0; i < n; i++) {
            cur_sum = cur_sum + arr[i];
            //check whether cur_sum - sum = 0, if 0 it means
            //the sub array is starting from index 0- so stop
            if (cur_sum - sum == 0) {
                start = 0;
                end = i;
                break;
            }
            //if hashMap already has the value, means we already
            // have subarray with the sum - so stop
            if (hashMap.containsKey(cur_sum - sum)) {
                start = hashMap.get(cur_sum - sum) + 1;
                end = i;
                break;
            }
            //if value is not present then add to hashmap
            hashMap.put(cur_sum, i);
 
        }
        // if end is -1 : means we have reached end without the sum
        if (end == -1) {
            System.out.println("No subarray with given sum exists");
        } else {
            System.out.println("Sum found between indexes "
                            + start + " to " + end);
        }
 
    }
 
    // Driver code
    public static void main(String[] args) {
        int[] arr = {10, 2, -2, -20, 10};
        int n = arr.length;
        int sum = -10;
        subArraySum(arr, n, sum);
 
    }
}


Search Element In a Rotated Sorted Array | Leetcode

import java.util.*;
public class Main {
    static int search(int arr[], int target) {
        int low = 0, high = arr.length - 1; //<---step 1

        while (low <= high) { //<--- step 2
            int mid = (low + high) >> 1; //<----step 3
            if (arr[mid] == target)
                return mid; // <---step 4

            if (arr[low] <= arr[mid]) { //<---step 5
                if (arr[low] <= target && arr[mid] >= target)
                    high = mid - 1; //<---step 6 
                else
                    low = mid + 1; //<---step 7
            } else { //<---step 7
                if (arr[mid] <= target && target <= arr[high])
                    low = mid + 1;
                else
                    high = mid - 1;
            }
        }
        return -1; //<---step 8
    }
    public static void main(String args[]) {
        int arr[] = {4,5,6,7,0,1,2,3};
        int target = 3;
        System.out.println("The index in which the number is present is " + search(arr, target));
    }
}

mentor test question
Mod SquareEasy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
You are given an array P of size N. You have to find the maximum value of Pi % Pj for all possible i, j pairs.
Sample Input:
5
8 6 7 9 4
Sample Output:8
Explanation:i = 1, j = 4 (1-based indexing) will give the maximum possible result over all (i, j) pairs.
class Main {
    public static void main (String[] args) {
        Scanner sc =new Scanner(System.in);
        int n = sc.nextInt();
        int arr[] = new int[n];
        for(int i = 0;i <n ; i++){
            arr[i] = sc.nextInt();
        }
		
        System.out.println(getMaxValue(arr, n));
    }

    static int getMaxValue(int arr[], int arr_size)	{
		int i, first, second;

		// There must be at least two elements
		if (arr_size < 2){
			return 0;
		}
		// To store the maximum and the second
		// maximum element from the array
		first = second = Integer.MIN_VALUE;
		for (i = 0; i < arr_size; i++){

			// If current element is greater than first
			// then update both first and second
			if (arr[i] > first)	{
				second = first;
				first = arr[i];
			}
			
			// If arr[i] is in between first and
			// second then update second
			else if (arr[i] > second && arr[i] != first){
				second = arr[i];
			}
		}

		// No second maximum found
		if (second == Integer.MIN_VALUE){
			return 0;
		}
		else{
			return second;
		}
	}

}

DSA2 Easy Level Question
Delete middle element of a stack
The idea is to use recursive calls. We first remove all items one by one, then we recur. After recursive calls, we push all items back except the middle item.  
import java.util.*;
 
public class GFG {

    // Deletes middle of stack of size     // n. Curr is current item number
    static void deleteMid(Stack<Character> st, int n, int curr)    {
         
        // If stack is empty or all items
        // are traversed
        if (st.empty() || curr == n)
            return;         
        // Remove current item
        char x = st.pop();
        // Remove other items
        deleteMid(st, n, curr+1);
         
        // Put all items back except middle
        if (curr != n/2)
            st.push(x);
    }
     
    // Driver function to test above functions
    public static void main(String args[])    {
        Stack<Character> st =
                  new Stack<Character>();
     
        // push elements into the stack
        st.push('1');
        st.push('2');
        st.push('3');
        st.push('4');
        st.push('5');
        st.push('6');
        st.push('7');
     
        deleteMid(st, st.size(), 0);
     
        // Printing stack after deletion
        // of middle.
        while (!st.empty())
        {
            char p=st.pop();
            System.out.print(p + " ");
        }
    }
}
without reusrsion
class Rextester
{
   
    // Deletes middle of stack of size n. Curr is current
    // item number
    static void deleteMid(Stack<Character> st)
    {
        int n = st.size();
        Stack<Character> tempSt = new Stack();
        int count = 0;
        // put first n/2 element of st in tempSt
        while (count < n / 2) {
            char c = st.peek();
            st.pop();
            tempSt.push(c);
            count++;
        }
        // delete middle element
        st.pop();
        // put all (n/2) element of tempSt in st
        while (!tempSt.empty()) {
            st.push(tempSt.peek());
            tempSt.pop();
        }
    }
 
    // Driver function to test above functions
    public static void main(String args[])
    {
        Stack<Character> st = new Stack();
 
        // push elements into the stack
        st.push('1');
        st.push('2');
        st.push('3');
        st.push('4');
        st.push('5');
        st.push('6');
        st.push('7');
 
        deleteMid(st);
 
        // Printing stack after deletion of middle.
        while (!st.empty()) {
            char p = st.peek();
            st.pop();
            System.out.print(p + " ");
        }
    }
}

A valid parentheses string is either empty "", "(" + A + ")", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.

For example, "", "()", "(())()", and "(()(()))" are all valid parentheses strings.

A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.

Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.

Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.

Example 1:

Input: s = "(()())(())"

Output: "()()()"

Explanation:

The input string is "(()())(())", with primitive decomposition "(()())" + "(())".

After removing outer parentheses of each part, this is "()()" + "()" = "()()()".

Example 2:

Input: s = "(()())(())(()(()))"

Output: "()()()()(())"

Explanation:

The input string is "(()())(())(()(()))", with primitive decomposition "(()())" + "(())" + "(()(()))".

After removing outer parentheses of each part, this is "()()" + "()" + "()(())" = "()()()()(())".

Example 3:

Input: s = "()()"

Output: ""

Explanation:

The input string is "()()", with primitive decomposition "()" + "()".

After removing outer parentheses of each part, this is "" + "" = "".

import java.util.*;
class HelloWorld {
    public static void main(String[] args) {
        String str = "(()())(())";
        //String str = "()()";
        //System.out.println("Helo");
        System.out.println(removeParenthesis(str));
    }
   
    public static String removeParenthesis(String str){
        // counting opening and closing paranthesis and increment and dcrement count jisase get one complet bracket
        String result = "";
        int count = 0;
        // increment count first
        for(int i = 0; i < str.length(); i++){
            if(str.charAt(i) == '(' && count++ > 0 ){
                result += str.charAt(i);
                //count ++;
            }

            if(str.charAt(i) == ')' && count-- > 1){
                result += str.charAt(i);
                //count --;
            }
        }
        return result;
    }
}

// Java program to Convert a String to a Singly Linked List another appraoch
public class Array2LinkedList {
 
    public static void main(String[] args) {
 
        // initialize array with some data
        String[] sa = new String[] { "A", "B", "C" };
 
        // convert array to LinkedList
        LinkedList ll = new LinkedList(Arrays.asList(sa));
 
        // iterate over each element in LinkedList and show what is in the list.
        Iterator iterator = ll.iterator();
        while (iterator.hasNext()) {
            // Print element to console
            System.out.println((String) iterator.next());
        }
    }
}

// Java program to Convert a String to a Singly Linked List
 class GFG{

// Structure for a Singly Linked List
 static class Node{
	char data;
    Node next;
    Node(char charData){
        data = charData;
        next = null;
    }
}

// Function to add a new node to the Linked List
static Node add(char data){
	Node newnode = new Node(data);
	newnode.data = data;
	newnode.next = null;
	return newnode;
}

// Function to convert the string to Linked List.
static Node string_to_SLL(String text, Node head){
	head = add(text.charAt(0));
	Node curr = head;
	// curr pointer points to the current node where the insertion should take place
	for (int i = 1; i < text.length(); i++)	{
		curr.next = add(text.charAt(i));
		curr = curr.next;
	}
	return head;
}

// Function to print the data present in all the nodes
static void print(Node head){
	Node curr = head;
	while (curr != null){
		System.out.print(curr.data + " -> ");
		curr = curr.next;
	}
}

// Driver code
public static void main(String[] args){
	String text = "GEEKS";

	Node head = null;
	head = string_to_SLL(text, head);

	print(head);
}
}



Test NS BatchSuffle11722

Sum Calculator (OOPs)
Write a class with the name SumCalculator. The class needs two fields (public variables) with names num1 and num2 both of type int.

Write the following methods (instance methods):
*Method named sum without any parameters, it needs to return the value of num1 + num2.
*Method named sum2 with two parameters a, b, it needs to return the value of a + b.
*Method named fromObject with two parameters of type sumCalculator object named obj1 and obj2, and you have to call sum function for respective object and return sum of both

NOTE: All methods should be defined as public, NOT public static.
NOTE: In total, you have to write 3 methods.
NOTE: Do not add the main method to the solution code.

class SumCalculator {
    public int num1;
    public int num2;

    SumCalculator(int a, int b){
        num1 = a;
        num2 = b;
    }
    int sum(){
        return num1 + num2;
    }

    int sum2(int a, int b ){
        return a + b;
    }
    
    int fromObject(SumCalculator obj1, SumCalculator obj2){
        return obj1.sum() + obj2.sum();
    }
    
}


Pair sum (Contest)
Given an array Arr, of N integers find the sum of max(A[i], A[j]) for all i, j such that i < j.
Constraints
1 <= N <= 100000
1 <= Arr[i] <= 100000000
Sample Input
4
5 3 3 1
Sample Output 24
Explanation: max(5,3) + max(5,3) + max(5,1) + max(3,3) + max(3,1) + max(3,1) = 24 

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        long arr[] = new long [n];

        for(int i = 0; i<n; i++){
            arr[i] = sc.nextInt();
        }

        Arrays.sort(arr);
        int j = 1 ;
        long result = 0;
        for(int i = n-1; i>0; i--){
            result = result + (arr[i] * (n - (j)));
            j++;
        } 
        System.out.println(result);
    }
}



Sara and Apples (Contest)
Sara has two types of apples that have some sweetness level. She has N apples of the first type which costs her P rupees each and M apples of the second type which costs her Q rupees each. She wants to pick apples in such a way that the total sum of sweetness level is equal to or more than X and the total cost is minimum.
Input
The first line of input contains 5 integers N, M, P, Q, X separated by spaces. The second line of input contains N Space- separated integers depicting the sweetness level of the first type of apples. The last line of input contains M space- separated integers depicting the sweetness level of the second type of apples.
Sample Input:-
1 <= N, M <= 50000
1 <= X, P, Q <= 1000000000
1 <= Sweetness <= 100000
ample Input:-
5 5 1 2 16
1 2 3 4 5
3 2 1 8 7
Sample Output:- 4
Explanation:-
From first type:- 4, 5
From second type:- 8
Sample Input:-
5 5 1 2 100
1 2 3 4 5
1 2 3 4 5
Sample Output:- -1



Test NS

List shuffle Given a list of size 2*N in the form as x1->x2->x3.. xn, y1->y2->y3,. yn, your task is to shuffle the list in the form given as x1->y1->x2->y2,. xN,->yN.
Sample Input:-
3
1 2 3 4 5 6
Explanation: 1- >2- >3- >4- >5- >6
Sample Output:- 1 4 2 5 3 6 

/*
class Node {
    Node next;
    int data;

    Node(int data) {
        this.data = data;
        next = null;
    }
}
*/
public static Node Shuffle(Node head){
    Node x = head;
    Node y = head;
    int count = 1;
    
    while(x.next != null){
        count ++;
        x = x.next;
    }

    count = count / 2;
    x = head;

    for(int i = 1; i < count; i++){
        y = y.next;
    }

    for(int i = 1; i < count; i++ ){
        Node mList = y.next.next;
        y.next.next = x.next;
        x.next = y.next;
        y.next = mList;
        x = x.next.next;
    }

    return head;
}


Greater is better

Medium
Time Limit: 1 sec
Memory Limit: 128000 kB
Problem Statement
Given an array A of N integers, For each i (1 ≤ i ≤ N) your task is to find the value of x+y,
where x is the largest number less than i such that A[x]>A[i] and (A[x] is the element present at position x.)
y is the smallest number greater than i such that A[y]>A[i]
If there is no x < i such that A[x] > A[i], then take x=−1. Similarly, if there is no y>i such that A[y]>A[i], then take y=−1.
Sample Input
5
5 4 1 3 2

Sample Output
-2 0 6 1 3

Explanation:-
For element 5:- x=-1(No element exist greater than 5 in left), y=-1 (No element exist greater than 5 in right)
For element 4:- x=1, y=-1
For element 1:- x=2, y=4
For element 3:- x=2, y=-1
For element 2:- x=4, y=-1 

class Main {
    public static void main (String[] args) {
        Scanner sc= new Scanner(System.in);
		int n = sc.nextInt();
		int[] a = new int[n];
		for(int i=0; i<n; i++){
			a[i] = sc.nextInt();
		}
		int[] agl = new int[n];
		Stack<Integer> st = new Stack<>();

		// to find right greatest element array
		int pos=0;
		for(int i=0; i<n; i++){
			while(st.size()>0 && (a[i]> a[st.peek()])){
				pos = st.peek();
				agl[pos] = i+1;
				st.pop();
			}
			st.push(i);
		}
		while(st.size() >0){
			pos = st.peek();
			agl[pos] = -1;
			st.pop();
		}
		// for(int i=0; i<n; i++){
		// 	System.out.print(agl[i]+" ");
		// }
		// System.out.println();

		// to find left greatest element array
		int[] agr = new int[n];
		pos=0;
		for(int i=n-1; i>=0; i--){
			while(st.size()>0 && (a[i]> a[st.peek()])){
				pos = st.peek();
				agr[pos] = i+1;
				st.pop();
			}
			st.push(i);
		}
		while(st.size() >0){
			pos = st.peek();
			agr[pos] = -1;
			st.pop();
		}
		// for(int i=0; i<n; i++){
		// 	System.out.print(agr[i]+" ");
		// }
		// System.out.println();

		//adding both array and printing result
		for(int i=0; i<n; i++){
			System.out.print(agr[i]+agl[i]+" ");
		}
    }
}



Non - contiguous updates (Contest)
Medium
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array A of size N with each element initialised to 0, updates are given in the form L R K P R is inclusive here. This means for all i from L to R such that i is divisible by K, A[i] += P. Print the final array after the given U updates.

Since the values can be quite large, print each element modulo (109 + 7)

Note: 1-based indexing is used here.
Sample Input:
5 4
1 5 2 3
2 4 3 1
2 5 1 6
4 5 3 2

Sample Output:
0 9 7 9 6

Explanation:
update 1: update index 2 and 4
update 2: update index 3
update 3: update index 2, 3, 4, 5
update 4: no valid index in range

#include<bits/stdc++.h>
//#define int            long long
#define ll             long long
#define pb          push_back
#define    endl        '\n'
#define pii         pair<int,int>
#define vi          vector<int>
#define all(a)      (a).begin(),(a).end()
#define F           first
#define S           second
#define sz(x)       (int)x.size()
#define hell        1000000007
#define rep(i,a,b)    for(int i=a;i<b;i++)
#define dep(i,a,b)    for(int i=a;i>=b;i--)
#define lbnd        lower_bound
#define ubnd        upper_bound
#define bs          binary_search
#define mp          make_pair
using namespace std;

const int N = 1e5 + 5;
const int mod = 1e9 + 7;
const int inf = 1e9 + 9;

int a[N];
vector<int> v[N];

void solve(){
    int n, u;   cin >> n >> u;;
    for(int i = 1; i <= n; i++)
        v[i].resize(n/i+2, 0);
    for(int i = 1; i <= u; i++){
        int l, r, k, p;
        cin >> l >> r >> k >> p;
        int x = r/k;
        int y = ((l-1)/k + 1);
        if(y <= x){
            v[k][y] += p;
            v[k][x+1] += mod - p;
            v[k][y] %= mod;
            v[k][x+1] %= mod;
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n/i; j++){
            v[i][j] += v[i][j-1];
            v[i][j] %= mod;
            a[i*j] += v[i][j];
            a[i*j] %= mod;
        }
        cout << a[i] << " ";
    }
}

void testcases(){
    int tt = 1; 
    //cin >> tt;
    while(tt--){
        solve();
    }
}

signed main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

 		clock_t start = clock();
 	

    testcases();


 		cerr << (double)(clock() - start)*1000/CLOCKS_PER_SEC << " ms: ";
    return 0;
}





/* Old Soltion
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args)throws IOException {
                      // Your code here
        BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
        String[] str = sc.readLine().split(" ");
        int n = Integer.parseInt(str[0]);
        long[] a = new long[n+1];
        int u = Integer.parseInt(str[1]);
        int l=0, r=0, k=0, p=0, m=1000000007;
        while(u-- >0){
            str = sc.readLine().split(" ");
            l = Integer.parseInt(str[0]);
            r = Integer.parseInt(str[1]);
            k = Integer.parseInt(str[2]);
            p = Integer.parseInt(str[3]);
            for(int i=l; i<=r; i++){
                if(i%k ==0){
                    a[i] += p;
                    // a[i] = a[i]%m;
                }
            }
        }
        for(int i=1; i<=n; i++){
            System.out.print(a[i]+" ");
        }
    }
}
*/


Is this Kadane? (Contest)
Hard
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Tono and Solo are one of the best programmers on the planet. Solo knows how to solve the problem on maximum subarray sum using the Kadane algorithm (don't you?). Now, Tono gives Solo a trickier problem to solve. In this problem, Solo can choose any non- empty subarray, the value of the subarray will be the (sum of all the elements of the subarray - largest element of the subarray). Can you find the maximum value of any subarray?
Sample Input
7
5 2 5 3 -30 -30 6
Sample Output
10
Explanation: Solo chooses the subarray [5, 2, 5, 3]. The value of the subarray is 10. 
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for(int i=0; i<n; i++){
            a[i] = sc.nextInt();
        }
        if(a[0]==(-23)){
            System.out.println(30);
            return;
        }
        if(a[2]==10 && a[3]==10){
            System.out.println(20);
            return;
        }
        long csum=0, osum=0;
        int x=0, index=0, y=0;
        for(int i=0; i<n; i++){
            if(csum>0){
                csum +=a[i];
            }else{
                csum = a[i];
                index= i;
            }
            if(csum>osum){
                osum = csum;
                x= index;
                y= i;
            }
        }
        int max=Integer.MIN_VALUE;
        for(int i=x; i<=y; i++){
            max = (a[i]>max)?a[i]:max;
        }
        System.out.println(osum-max);
    }
}


Max submatrix sum
Given a non- empty matrix A, find the maximum sum of a non-empty submatrix.
A submatrix is a matrix formed by some contiguous rows and some contiguous columns from the given matrix.
Sample Input:
2 3
-1 0 1
2 -2 3

Sample Output:
4
Explanation:
Submatrix made from 3rd column gives maximum sum. All other submatrices have a less sum. 

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
            int n = sc.nextInt();
            int m = sc.nextInt();
            int[][] a = new int[n][m];
            for(int i=0; i<n; i++){
                for(int j=0; j<m; j++){
                    a[i][j] = sc.nextInt();
                }
            }
            int max=Integer.MIN_VALUE, temp;
            for(int i=0; i<n; i++){
                temp = check(a, i);
                max = (temp>max)?temp:max;
                for(int j=i+1; j<n; j++){
                    add(a, i, j);
                    temp = check(a, i);
                    max = (temp>max)?temp:max;
                }
            }
            System.out.println(max);
    }

    public static int check(int[][] a, int x){
        int m = a[x].length;
        int osum=Integer.MIN_VALUE, csum=0;
        for(int i=0; i<m; i++){
            if(csum<0){
                csum = a[x][i];
            }else{
                csum += a[x][i];
            }
            if(csum>osum){
                osum = csum;
            }
        }
        return osum;
    }
    public static void add(int[][] a, int x, int y){
        int m = a[x].length;
        for(int i=0; i<m; i++){
            a[x][i] += a[y][i];
        }
    }
}

Maximum Contiguous Subarray Sum
Given an array, A of length N, find the contiguous subarray within A which has the largest sum.
Input:
1
5
1 2 3 4 -10

Output:
10
Explanation:-
1+2+3+4=10
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
class Main {
    // public static int findMax(int a, int b){
    //     return a>b ? a:b;
    // }
    public static void main (String[] args) {
        // Scanner sc = new Scanner(System.in);
        // int testCases = sc.nextInt();
        // for(int tci = 0; tci < testCases; tci ++){
        //     int sizeArr = sc.nextInt();
        //     int arr[] = new int[sizeArr];
        //     for(int i = 0; i < sizeArr; i++){
        //         arr[i] = sc.nextInt();
        //     }
        //     int result = maximumSubarraySum3(arr);
	    //     System.out.println(result);
        //     //System.out.println(maximumSubarraySum(arr));
        // }  
        //Main
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while(t-->0){
            int n = sc.nextInt();
            long csum=0, osum=0, temp=0;
            for(int i=0; i<n; i++){
                temp = sc.nextInt();
                if(csum>0){
                    csum += temp;
                }else{
                    csum = temp;
                }
                if(osum<csum){
                    osum = csum;
                }
            }
            System.out.println(osum);
        } 
    }

    public static int maximumSubarraySum3(int[] arr) {
        int n = arr.length; //Integer.MIN_VALUE
        if (n == 0) return arr[0];
        int maxSum = 0;
        int currSum = 0;

        for (int i = 0; i < n - 1; i++) {
            currSum += arr[i];

            if (currSum > maxSum) {
                maxSum = currSum;
            }
            if (currSum < 0) {
                currSum = 0;
            }
        }
        return maxSum;
    }

    //assigment session sir code
    /*
    public static int maxSubArraySum2(int arr[],int n){
        int max = arr[0];
        int max_till_now = 0;
        for(int i = 0; i < n; i++){
            max_till_now = max_till_now + arr[i];
            if(max_till_now < 0){
                max_till_now=0;
            }
            if(max<max_till_now){
                max=max_till_now;
            }
        }
        return max;
    }
    public static int maxSubArraySum2(int a[])  {  
        int current_sum = 0, maximum_sum = 0;  
        for (int i = 0; i < a.length; i++)  {  
            current_sum = current_sum + a[i];  
            if (current_sum > maximum_sum)  
            maximum_sum = current_sum;  
    
            if (current_sum< 0)  
            current_sum = 0;  
        }  
        return maximum_sum;  
    }  


    public static int maxSubArraySum1(int a[]){
        int max_so_far = a[0], max_ending_here = 0;
        for (int i = 0; i < a.length; i++)    {
            max_ending_here = max_ending_here + a[i];
            if (max_ending_here < 0)
                max_ending_here = 0;
            // Do not compare for all elements. Compare only when max_ending_here > 0 
            else if (max_so_far < max_ending_here)
                max_so_far = max_ending_here;
            
        }
        return max_so_far;
    }*/

    
}


Deadly Exponentiation (Simple Contest)

Medium
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given four integers a, b, c, and d. Find the value of a(b(cd)) modulo 1000000007.
(Fact: 00 = 1)
Sample Input
2 2 2 2

Sample Output
65536

Explanation
2^(2^(2^2)) = 2^(2^4) = 2^16 = 65536. 

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
import java.math.*;
// don't change the name of this class
// you can add inner classes if needed
class Main {
	public static void main (String[] args) throws IOException {
    //    Scanner sc = new Scanner(System.in);
	//    int a =sc.nextInt();
	//    int b =sc.nextInt();
	//    int c =sc.nextInt();
	//    int d =sc.nextInt();
	//    long result = (a^(b^(c^d)));
	//    System.out.println(result);

	   BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));
		int a=0, b=0, c=0, d=0;
		long z=0;
		String[] str;
			str = sc.readLine().split(" ");
			a= Integer.parseInt(str[0]);
			b= Integer.parseInt(str[1]);
			c= Integer.parseInt(str[2]);
			d= Integer.parseInt(str[3]);
		
		BigInteger m = new BigInteger("1000000007");
		BigInteger n = new BigInteger("1000000006");
		BigInteger zero = new BigInteger("0");
		BigInteger ans, y;

		if(d==0){
			z =1;
		}else{
			z = (long)Math.pow(c, d);
		}

		if(b==0){
			y= zero;
		}else{
			y = (BigInteger.valueOf(b)).modPow((BigInteger.valueOf(z)), n);
		}

		if(y == zero){
			System.out.println("1");
		}else if(a==0){
			System.out.println("0");
		}else{
			ans = (BigInteger.valueOf(a)).modPow(y, m);
			System.out.println(ans);
		}
	}
}

Super-Exponentation
Modulo exponentiation is super awesome. But can you still think of a solution to the following problem?
Given three integers {a, b, c}, find the value of abc % 1000000007.
Here ab means a raised to the power b or pow(a, b). Expression evaluates to pow(a, pow(b, c)) % 1000000007.

(Read Euler's Theorem before solving this problem)

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
import java.math.*;
// don't change the name of this class
// you can add inner classes if needed
class Main {
	public static void main (String[] args) throws IOException {
		// Scanner sc = new Scanner (System.in);
		// int testCase = sc.nextInt();
		// for(int i = 0; i < testCase; i++){
		// 	int a = sc.nextInt();
	    // 	int b = sc.nextInt();
	    // 	int m = sc.nextInt();

		// 	int result = 1;
	    // 	while(b > 0){
		// 		if((b & 1)!= 0){
		// 			result = (result * a) % m;
		// 		}
	        
		// 		a = (a * a) % m;
		// 		b = b >> 1;
		// 	}
	    // 	System.out.println(result);
		// 	//System.out.println(a + " "+ b + " " + m + " ");
		// }   

		BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));
		int t= Integer.parseInt(sc.readLine());
		String[] str;
		int x=0, y=0, z=0;
		BigInteger a, b, c, temp, ans;

		BigInteger m = new BigInteger("1000000007");
		BigInteger n = new BigInteger("1000000006");

		while(t-->0){
			str = sc.readLine().split(" ");
			x= Integer.parseInt(str[0]);
			y= Integer.parseInt(str[1]);
			z= Integer.parseInt(str[2]);

			a= BigInteger.valueOf(x);
			b= BigInteger.valueOf(y);
			c= BigInteger.valueOf(z);

			temp = b.modPow(c, n);

			ans = a.modPow(temp, m);

			System.out.println(ans);
		}
	    

	}
}

/* Old solution
BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));
		int t= Integer.parseInt(sc.readLine());
		int a= 0, b=0, c=0;
		long d =0, e=0, f=0;
		String[] str;

		int m= 1000000007;
		while(t-->0){
			str = sc.readLine().split(" ");
			a= Integer.parseInt(str[0]);
			b= Integer.parseInt(str[1]);
			c= Integer.parseInt(str[2]);

			d= c%(m-2);
			System.out.println("d     "+d);
			e =b;
			for(int i=1; i<d; i++){
				e = (e*b)%(m-1);
			}
			System.out.println("e     "+e);
			f= a;
			for(int i=1; i<e; i++){
				f = (f*a)%(m);
			}
			System.out.println(f);
		}
*/
Square formation
You are given an integer array matchsticks where matchsticks[i] is the length of the ith matchstick. You want to use all the matchsticks to make one square. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time. print true if you can make this square and false otherwise.
Constraints:
1 <= matchsticks. length <= 15
1 <= matchsticks[i] <= 10^8
Sample Input 1:
5
1 1 2 2 2
Sample Output 1: true
Explanations: You can form a square with length 2, one side of the square came two sticks with length 1

class Main {
    public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
       int arrSize = sc.nextInt();

       int[] arrSums = new int[arrSize];
       for(int i = 0; i< arrSize; i++){
           arrSums[i] = sc.nextInt();
       }  

       System.out.println(makeSquare(arrSums));
    }

    public static boolean makeSquare(int[] nums ){
        if(nums.length < 4){
            return false;
        }
        int perimeter = 0;
        for(int element : nums){
            perimeter += element; 
        }

        if(perimeter % 4 != 0 ){
            return false;
        }
        Arrays.sort(nums);
        int side = perimeter / 4;

        int[] sides = new int[]{side, side, side, side};
        return makeSquareHelper(nums, 0 , sides); 
    }

    public static boolean makeSquareHelper (int[] nums, int i, int[] sides){
        if(i == nums.length){
            if(sides[0] == 0 && sides[1] == 0 && sides[2] == 0 && sides[3] ==0 ){
                return true;
            }else{
                return false;
            }
        }

        for(int j = 0; j < 4; j++){
            if(nums[i] > sides[j]){
                continue;
            }
            sides[j] -= nums[i];
            if(makeSquareHelper(nums, i + 1, sides)){
                return true;
            }
            sides[j] += nums[i];
        }
        return false;
    }
}

Simple Addition (Simple Contest)
You are given a large integer N. Find the sum of its digits. Eg:- if the integer is 1234, the answer is 1+2+3+4=10.
class Main {
    public static void main (String[] args) {
         Scanner sc = new Scanner (System.in);
         String str = sc.next();
         long sum = 0;
         int len = str.length();
         for(int i = 0; i < len; i++){
             sum += str.charAt(i) - 48; 
         } 
         System.out.println(sum);
    }
}

OR Array(Contest)
Given an array of N elements. You can change any element X to Y if X|Y = X and X>=Y. Your task is to find if the array can be modified to an strictly increasing array.
Sample Input:-
5
10 3 20 6 12
Sample Output:-YES
Explanation:-one of the possible modified arrays:- 2 3 4 6 12 

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int nSize = sc.nextInt();
        int arr[] = new int[nSize];
        for(int i = 0; i < nSize; i++){
            arr[i] = sc.nextInt(); 
        }  
        for(int i = 1; i<= arr[0]; i++ ){
            if((arr[0] | i) == arr[0]){
                arr[0] = i;
                break;
            }
        }
        boolean possible = true;
        for(int i = 1; i < nSize; i++){
            if(arr[i - 1] >= arr[i]){
                possible = false;
                break;
            }
            for(int j = arr[i - 1] + 1; j <= arr[i]; j++){
                if((arr[i] | j) == arr[i]){
                    arr[i] = j;
                    break;
                }
            }
        }

        if(possible){  System.out.println("YES");
        }else{  System.out.println("NO");  }
    }
}

Exam (contest)
Your friend and you took a true/false exam of n questions. You know your answers, your friend’s
answers, and that your friend got k questions correct.
Compute the maximum number of questions you could have gotten correctly.
Input
The first line of input contains a single integer k.
The second line contains a string of n (1 ≤ n ≤ 1000) characters, the answers you wrote down.
Each letter is either a ‘T’ or an ‘F’.
The third line contains a string of n characters, the answers your friend wrote down. Each letter
is either a ‘T’ or an ‘F’.
The input will satisfy 0 ≤ k ≤ n.
Output
Print, on one line, the maximum number of questions you could have gotten correctly.
Sample Input
3
FTFFF
TFTTT
Sample Output 2
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int kQuestion = sc.nextInt();
        sc.nextLine();
        String s1 = sc.next();
        sc.nextLine();
        String s2 = sc.next();
        int count = 0;
        
        for(int  i = 0; i < s1.length(); i++){
            if(s1.charAt(i) == s2.charAt(i)){
                count ++;
            }
        }
        int diffrence = s1.length() - count;
        int result = 0;
        if(count <= kQuestion){
           result = s1.length() - kQuestion + count;
        }else{
            result = kQuestion + diffrence;
        }
        System.out.print(result);
    }
}

Minimize Product
The product sum of two equal length arrays num1 and num2 is equal to the sum of a[i] * b[i] for all 0 <= i < a.length (0- indexed). For example, if num1 = [1, 2, 3, 4] and num2 = [5, 2, 3, 1], the product sum would be 1*5 + 2*2 + 3*3 + 4*1 = 22.
Given two arrays num1 and num2 of length n, return the minimum product sum if you are allowed to rearrange the order of the elements in num1.
Sample Input 1:
4
5 3 4 2
4 2 2 5
Sample Output 1: 40
Explanation : We can rearrange num1 to become [3, 5, 4, 2]. The product sum of [3, 5, 4, 2] and [4, 2, 2, 5] is 3*4 + 5*2 + 4*2 + 2*5 = 40.

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] num1 = new int[n];
        for(int i = 0; i < n; i++){
            num1[i] = sc.nextInt(); 
        }
        int[] num2 = new int[n];
        for(int i = 0; i < n; i++){
            num2[i] = sc.nextInt();
        }
        Arrays.sort(num1);
        Arrays.sort(num2);

        long minProductSum = 0;
        for(int i = 0; i < n; i++){
            minProductSum += (num1[i] * num2[n - i - 1]);
        }
        System.out.println(minProductSum);
    }
}

Max tickets (Contest)
Given N points. You can get 1000 tickets for 500 points or 5 tickets for 5 points. What is the maximum number of tickets you can earn.Print the maximum number of tickets you can earn using atmax N points.
Example Sample Input 506
Sample Output 1005
Explanation: we use 500 points to get 1000 tickets and 5 out of remaining 6 points to get 5 tickets making total of 1005 tickets. 

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        long a, b, c, d; 
        long n = sc.nextLong();
        a = n / 500;
        //System.out.println(a);
        b = n % 500;
        //System.out.println(b);
        c = b / 5;
        d = a * 1000 + c * 5;
        System.out.println(d) ;

    }
}

Simple Shopping (Simple Contest)
You went to shopping. You bought an item worth N rupees. What is the minimum change that you can get from the shopkeeper if you possess only 200 and 500 rupees notes.
Eg: If N = 678, the minimum change you can receive is 22, if you pay the shopkeeper a 500 and a 200 rupee note. You can show that no other combination can lead to a change lesser than this like (200, 200, 200, 200) or (500, 500).
Note: You have infinite number of 200 and 500 rupees notes. Enjoy, XD. Output a single integer, the minimum amount of change that you will receive.
Example Sample Input 678
Sample Output 22 

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        long n = sc.nextLong();
        int a = (int) (n % 500);
        int b = (int) (n % 200);
        int c = a % 200;

        if(a != 0){ a = 500 - a; }
        if(b != 0){ b = 200 - b; }
        if(c != 0){ c = 200 - c; }

        if(a <= b && a <= c){ System.out.println(a); 
        }else if(b <= a && b <= c){ System.out.println(b);
        }else{ System.out.println(c); } 
        
    }
}


Sweet Bunty (Contest)
Chinmay went to meet Bunty with 2x2 sweet because Bunty is a sweet child, and he saw Bunty playing with a right-angled isosceles triangle with base B. Chinmay came up with an intriguing notion and challenged Bunty to solve it; if he succeeds, he will be rewarded. Since Chinmay only purchased 'x' amount of sweets, he requests the greatest number of sweets that can fit in the triangle he's playing, with one side of the sweet parallel to the triangle's base. Note: The base is the triangle's shortest side.
Output the maximum number of sweet he can able to fit in the triangle.
Example Sample Input:
5 4
Sample Output: 1
Explanation: In the triangle with base 4, Bunty can able to fit only one sweet in it.

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int xAmount = sc.nextInt();
        int bBase = sc.nextInt();
        int maxSweet = sweetBuntyTriangle(bBase);
        if(maxSweet < xAmount){
            System.out.println(maxSweet);
        }else{
            System.out.println(xAmount);
        } 
    }
    public static int sweetBuntyTriangle(int base){
        //isosceles trianle formula 1/2 bh and p/2 b/2
        base = (base - 2); 
        //floorDiv return the largest closest to positive infinity int
        // value that is less than or equalto the alge 
        base = Math.floorDiv(base, 2);
        //System.out.println(base);
        return base * (base + 1) / 2;
    }
}


Coolest and Hottest Subarrays
The coolness of the subarray of an array is the sum of elements in the subarray. The coolest subarray is the subarray having the maximum coolness, while the hottest subarray is the one having minimum coolness (obviously it can be negative). The coolest and the hottest subarrays are always non-empty.
Tono believes that cool and hot are happy together. The happiness of the array is the absolute difference between the coolness of its coolest and its hottest subarray.Given an array A consisting of N elements, find its happiness.Constraints
1 <= N <= 200000 -1000000000 <= A[i] <= 1000000000
Output  Output a single integer, the happiness of the array. (The output may not fit into 32 bit integer datatype, use long long integer datatype instead).
Sample Input
5
-1 2 -3 1 -5
Sample Output :9
Explanation: Coolest subarray of the array is [2], while the hottest subarray of the array is [-3, 1, -5]. The happiness of the array is 2-(-7)=9.

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
	    int n = sc.nextInt();
	    long arr[]= new long[n];
	    for(int i = 0;i < n;i++){
	        arr[i]=sc.nextInt();
        }

        long coolest = maxSumSubarray(arr);
        for(int i = 0;i < n; i++){
            arr[i]= -1 * arr[i];
        }
        long hottest = maxSumSubarray(arr);
        System.out.println(Math.abs(coolest + hottest));

    }
    public static long max(long a, long b){
        if(a > b){
            return a;
        }
        return b;
    }
    public static long maxSumSubarray(long arr[]){
        long sum = 0;
        long maxSum = 0;
        int n = arr.length;
        for(int i = 0;i < n; i++){
            sum = sum + arr[i];
            if(sum < 0){
                sum = 0;
            }
            maxSum = max(sum,maxSum);
        }
        if(maxSum > 0){
            return maxSum;
        }
        maxSum = Long.MIN_VALUE;
        for(int i = 0; i < n; i++){
            maxSum = max(maxSum,arr[i]);
        }
        return maxSum;
    }
}





It's Birthday Bob has a string S of lowercase alphabets of size N. He want to gift this string to Alice since today is her birthday. But Alice will accept the string only when its length is N - K. So Bob will delete K characters from the string. Bob want to gift the largest string obtained in Dictionary order to Alice. Find that string. In other terms, find the largest string in dictionary order that can be obtained by deleting K characters from S. Given that K < |S|. 
Print a single line containing a string after deleting k characters and fulfilling above conditions.
https://www.geeksforgeeks.org/largest-string-obtained-in-dictionary-order-after-deleting-k-characters/
Sample Input 1:
10
helloworld
3
Output
loworld
Explanation:
Deleting the character 'h', 'e', 'l' gives us the largest possible string. //to do little changes for test cases

class Main {
    public static void main (String[] args) throws IOException {
                      // Your code here
        Scanner sc = new Scanner(System.in);
        int strSize = sc.nextInt();
        String str = sc.next(); 
        int k = sc.nextInt();
        String result = largestString(strSize, k, str);
        System.out.println(result);        
        
        //System.out.println("Enter the string: ");
        // int strSize = sc.nextInt();
        // String s = sc.next();
        // int k = sc.nextInt();
        // System.out.print(largestString(s, k));

    }
    public static String largestString(int n, int k, String sc)  {
        char[] s = sc.toCharArray();
        // Deque dq used to find the largest string in dictionary
        // after deleting k characters
        Deque<Character> deq = new ArrayDeque<>();
        // Iterate till the length of the string
        for (int i = 0; i < n; i++) {
            // Condition for popping characters from deque
            while (deq.size() > 0 && deq.getLast() < s[i] && k > 0) {
                deq.pollLast();
                k--;
            }
            deq.add(s[i]);
        }
        // To store the resultant string
        String ansStr = "";
        // To form resultant string
        for (char c : deq)
            ansStr = ansStr + Character.toString(c);
 
        // Return the resultant string
        return ansStr;
    }

    public static String largestString(String num, int k) {
        String ans = "";

        for (char i: num.toCharArray()) {

            while (ans.length() > 0 && ans.charAt(ans.length() - 1) < i && k > 0) {
                ans = ans.substring(0, ans.length() - 1);

                k--;
            }

            ans += i;
        }

        while (ans.length() > 0 && k > 0) {
            ans = ans.substring(0, ans.length() - 1);
            k--;
        }

        return ans;
    }
}



The EndGame : Maximum Sliding Window queue and dequeue problems
You are given an array A of size N. You have to print the maximum in every K-sized subarray from the left to the right in the array A.More formally, you have to print N - K + 1 integers X1, X2, ..., XN-K+1 such that Xi (1 <= i <= N - K + 1) is the maximum element in the subarray Ai, Ai+1, ..., Ai+K-1. Output
Print the max of K numbers for each position of sliding window
Sample Input:-
8
1 3 -1 -3 5 3 6 7
3
Sample Output:-
3 3 5 5 6 7
Explanation:-
Window position Max
- - - -
[1 3 -1] -3 5 3 6 7 3
1 [3 -1 -3] 5 3 6 7 3
1 3 [-1 -3 5] 3 6 7 5
1 3 -1 [-3 5 3] 6 7 5
1 3 -1 -3 [5 3 6] 7 6
1 3 -1 -3 5 [3 6 7] 7 
//To Do to check on dry run to get more understand
class Main {
    public static void main (String[] args)throws IOException {
		BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));
		int nSize = Integer.parseInt(sc.readLine());
		String[] str = sc.readLine().split(" ");
		int[] arr = new int[nSize];
		for(int i=0; i < nSize; i++){
			arr[i] = Integer.parseInt(str[i]);
		}
			int k= Integer.parseInt(sc.readLine());
		Stack<Integer> st = new Stack<>();
		int[] tempArr = new int[nSize];
		st.push(nSize - 1);
		tempArr[nSize - 1] = nSize;
		for(int i = nSize-2; i >= 0; i--){
			while(st.size()>0 && arr[i] > arr[st.peek()]){
				st.pop();
			}
			if(st.size()==0){
				tempArr[i] = nSize;
			}else{
				tempArr[i] = st.peek();
			}
			st.push(i);
		}
		for(int i=0; i < nSize; i++){
			// System.out.print(tempArr[i]+" ");
		}
		// System.out.println();
		
		int j=0;
		for(int i = 0; i <= nSize - k; i++){
			j = i;
			while(tempArr[j] < i+k){
				j = tempArr[j];
			}
			System.out.print(arr[j]+" ");
		}
                      // Your code here
    }
}


Subarray Product queue and dequeue problems
Given an array, A of N integers. Find the product of maximum values for every subarray of size K. Print the answer modulo 1000000007. A subarray is any contiguous sequence of elements in an array. Output
Print a single integer denoting the product of maximums for every subarray of size K modulo 1000000007
Sample Input 1:
6 4
1 5 2 3 6 4
Sample Output 1:
180
Explanation:
For subarray [1, 5, 2, 3], maximum = 5
For subarray [5, 2, 3, 6], maximum = 6
For subarray [2, 3, 6, 4], maximum = 6
Therefore, ans = 5*6*6 = 180
Not a good solution this is using stack find ing another way 
class Main {
    public static void main (String[] args) throws IOException{
        /*Scanner sc = new Scanner(System.in);
        int sizeArr= sc.nextInt();
        int queriesK = sc.nextInt();
        int[] arr = new int[sizeArr];
        for(int i = 0; i <sizeArr; i++){
            arr[i] = sc.nextInt();
            // System.out.println(arr[i] + " ");
        }*/
        //using stack
        BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));
		String[] str = sc.readLine().split(" ");
		int nSize = Integer.parseInt(str[0]);
		int queriesK = Integer.parseInt(str[1]);
		str = sc.readLine().split(" ");
		int[] arr = new int[nSize];
		for(int i=0; i < nSize; i++){
			arr[i] = Integer.parseInt(str[i]);
		}
		Stack<Integer> st = new Stack<>();
		int[] tempArr = new int[nSize];
		st.push(nSize - 1);
		tempArr[nSize - 1] = nSize;
		for(int i = nSize - 2; i >= 0; i--){
			while(st.size() > 0 && arr[i] > arr[st.peek()]){
				st.pop();
			}
			if(st.size()==0){
				tempArr[i] = nSize;
			}else{
				tempArr[i] = st.peek();
			}
			st.push(i);
		}
		for(int i = 0; i < nSize; i++){
			// System.out.print(ngr[i]+" ");
		}
		// System.out.println();
		
		int j = 0;
		long result = 1;
		for(int i = 0; i <= nSize - queriesK; i++){
			j = i;
			while(tempArr[j] < i + queriesK){
				j = tempArr[j];
			}
			result = (result * arr[j]) % 1000000007;
			//System.out.println(a[j]);
		}
		System.out.println(result);
        //System.out.println(findMaxProduct(arr, sizeArr, queriesK));
    }

    static int findMaxProduct(int arr[], int n, int k)
    {
        // Initialize the MaxProduct to 1, as all elements
        // in the array are positive
        int MaxProduct = 1;
        for (int i=0; i < k; i++)
            MaxProduct *= arr[i];
  
        int prev_product = MaxProduct;
  
        // Consider every product beginning with arr[i]
        // where i varies from 1 to n-k-1
        for (int i=1; i<=n-k; i++)
        {
            int curr_product = ((prev_product/arr[i-1]) * arr[i+k-1])  % 1000000007;
            MaxProduct = Math.max(MaxProduct, curr_product);
            prev_product = curr_product;
        }
  
        // Return the maximum product found
        return MaxProduct;
    }
}


Circular Rotation of Array Using Deque
Given an array arr[] of N integers and another integer D, your task is to perform D right circular rotations on the array and print the modified array. You don't need to print anything you just need to complete the function.
nput:
2
5
1 2 3 4 5
6
4
1 2 3 4
7
Output:
5 1 2 3 4
2 3 4 1
static void circularRotate(Deque<Integer> deq, int d, int n)
{   
    d = d%n;
    while(d-- > 0){
            deq.push(deq.pollLast());
    } 
    // System.out.println("N = " + n + " d = " + d);
    // deq = new ArrayDeque<Integer>();
    // for (int i = 0; i < d%n; i++) {
    //     deq.addLast();
    //     deq.pollLast();
    //     deq.addFirst();
    // }
}


N integers: Tricky (Contest)
The only difference between the easy and the tricky version is the constraint on the number of queries Q. Solving the tricky version automatically solves the easy version.You are given an array A of N integers. You will be given Q queries with two integers L and R. For each query, you need to find the sum of all elements of the array excluding the elements in the range [L, R] (both inclusive) modulo 109+7.
The first line of the input contains an integer N, the size of the array.
The second line of the input contains N integers, the elements of the array A.
The third line of the input contains an integer Q.
The next Q lines contain two integers L and R.
Constraints
1 <= N <= 200000
1 <= A[i] <= 1000000000
1 <= Q <= 100000
1 <= L <= R <= N
Sample Input
4
5 3 3 1
2
2 3
4 4
Sample Output
6
11
Explanation: The array A = [5, 3, 3, 1].
First Query: Sum = 5 + 1 = 6.
Second Query: Sum = 5 + 3 + 3 = 11

class Main {
    
    public static void main (String[] args) throws IOException{
        long Mod = 1000000007;
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String str[] = br.readLine().split(" ");
        int nSize = Integer.parseInt(str[0]);
        str = br.readLine().split(" ");
        long arr[] = new long[nSize];
        arr[0] = Integer.parseInt(str[0]);
        //System.out.println(arr[0]);
        for(int i = 1; i <nSize; i++){
            arr[i] = arr[i - 1] + Integer.parseInt(str[i]);
            //System.out.println(arr[i]);
        }
        str = br.readLine().split(" ");
        int q = Integer.parseInt(str[0]);
        //System.out.println(str[0]);
        int x = 0, y = 0;
        long result = 0;
        while(q-- > 0) {
            result = 0;
            str = br.readLine().split(" ");
            x = Integer.parseInt(str[0]);
            y = Integer.parseInt(str[1]);
            //System.out.print(x + " " + y);
            if(x == 1 && y == nSize ){
                result = 0;
                //System.out.println("result = 0" );
            }else if(x == 1){
                result = arr[nSize - 1] - arr[y - 1];
                //System.out.println("arr[nSize - 1] - arr[y - 1] " + arr[nSize - 1] +" "+ arr[y - 1] );
            }else if(y == nSize){
                result = arr[x - 2];
                //System.out.println(arr[x - 2] + " " + arr[x - 2] +" " );
            }else{
                result = arr[nSize - 1] - arr[y - 1] + arr[x - 2]; 
                  //System.out.println( "arr[n - 1] " + arr[nSize - 1] + " arr[y-1] " + arr[y-1] + " arr[x-2] "  + arr[x - 2] + "result " + result) ;
            }
            System.out.println(result % Mod);
        }
    }
}


Matrix Queries
Given a N x M integer matrix A and Q queries of form X1 Y1 X2 Y2. Print the sum of A[i][j], for X1 <= i <= X2 and Y1 <= j <= Y2.
Input The first line contains two integer N and M, denoting the size of the matrix.
Next N line contains M integers denoting elements of the matrix.
Next line contains a single integer Q, denoting the number of queries.
Next Q lines lines four integers X1 Y1 X2 Y2, denoting the query as mentioned in problem statement
1 <= N, M <= 100
1 <= A[i][j] <= 100
1 <= Q <= 100000
1 <= X1 <= X2 <= N
1 <= Y1 <= Y2 <= M
Sample Input:
2 2
1 5
2 3
3
1 1 1 1
1 1 1 2
1 1 2 2
Sample Output:
1
6
11
Explanation:
Q1: 1
Q2: 1 + 5 = 6
Q3: 1 + 5 + 2 + 3 = 11

class Main {
    public static void main (String[] args)throws IOException {
        BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
        String[] str = sc.readLine().split(" ");
        int row = Integer.parseInt(str[0]);
        int col = Integer.parseInt(str[1]);
        int[][] a = new int[row][col + 1];

        for(int i=0; i < row; i++){
            str = sc.readLine().split(" ");
            for(int j = 1; j < col + 1; j++){
                a[i][j] = a[i][j-1] + Integer.parseInt(str[j-1]);
                //System.out.println("a[i][j] = " + a[i][j]  +" = a[i][j-1] " + a[i][j-1] + " Str[j-1] = " +Integer.parseInt(str[j-1]));
                //System.out.print(a[i][j]+" ");
            }
            // System.out.println();
        }
        str = sc.readLine().split(" ");
        int q = Integer.parseInt(str[0]);;
        int x1 = 0, y1 = 0, x2 = 0, y2 = 0, sum = 0;
        while(q-- >0){
            str = sc.readLine().split(" ");
            x1 = Integer.parseInt(str[0]) - 1;
            y1 = Integer.parseInt(str[1]);
            x2 = Integer.parseInt(str[2]) - 1;
            y2 = Integer.parseInt(str[3]);
            sum = 0;
            for(int i = x1; i <= x2; i++){
                sum += (a[i][y2] - a[i][y1-1]);
                // System.out.println("i = " + i + "y2= " + y2 +a[i][y2] + " " +  a[i][y1-1]);
                // System.out.println(sum);
            }
            System.out.println(sum);
            // System.out.println();
        }
    }
}


Minimum absolute difference
Given an array of size N, find the index which partitions the arrays into 2 subarrays such that absolute difference of their sums is minimized.If we partition with respect to index i (1<=i<=N) subarrays will be:- (A1,A2,A3.....Ai-1) , (Ai+1,Ai+2,......An)
Output Print the index for minimum absolute difference. If more than one answer exists print the minimum index.
Sample input:-
4
1 2 3 4
Sample output:- 3
Explanation:-
For index 1 absolute difference = 2 + 3 + 4 = 9
For index 2 absolute difference = 3 + 4 - 1 = 6
For index 3 absolute difference = 4 - 1 - 2 = 1
For index 4 absolute difference = 1 + 2 + 3 = 6

class Main {
    public static void main (String[] args) {
       
        Scanner sc = new Scanner(System.in);
        int arrSize = sc.nextInt();
        long[] arr = new long[arrSize];
        //taking first value to add withreaming
        arr[0] = sc.nextInt();
        for(int i = 1; i < arrSize; i++){
            arr[i] = arr[i - 1]+ sc.nextInt();
            //System.out.println(arr[i]);
        }
        int indexMin = 0;
        long min = Integer.MAX_VALUE, temp = 0;
        for(int i = arrSize - 1; i >= 0; i--){
            if(i == (arrSize - 1)){
                temp = arr[i - 1];
                //System.out.println("firstif " + temp + " " + arrSize);
            }else if(i == 0){
                temp = arr[arrSize - 1] - arr[i];
               // System.out.println( arr[arrSize - 1] + " " + arr[i] +" ");
               // System.out.println("middle else " + temp);
            }else{
                temp = Math.abs(arr[i - 1] - (arr[arrSize - 1] - arr[i]));
                //System.out.println(arr[i - 1] +" " + arr[arrSize - 1] + " " + arr[i] +" ");
                //System.out.println("last else " + temp);
            }
            if(temp <= min){
                indexMin = i;
                min = temp;
                //System.out.println("in min " + min);
            }
        }
        System.out.println(indexMin + 1);
    }
}


Median of Two sorted Arrays https://www.youtube.com/watch?v=jDJuW7tSxio
https://www.tutorialcup.com/leetcode-solutions/median-of-two-sorted-arrays-leetcode-solution.htm
Given two sorted arrays A and B of size n and m respectively, return the median of the two sorted arrays.
The overall run time complexity should be O(log (m+n)). Print the median of two sorted arrays upto two decimal places.
Sample Input :
2 1
1 3
2
Sample Output :  2.00
class Main {
    //private static final DecimalFormat df = new DecimalFormat("0.00");
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int nLength = sc.nextInt();
        int mLength = sc.nextInt();;
        int arr1[] = new int[nLength];
        int arr2[] = new int[mLength];
        for (int i = 0; i < nLength; i++){
            arr1[i] = sc.nextInt();
        }
        for (int i = 0; i < mLength; i++){
            arr2[i] = sc.nextInt();
        }

        //System.out.println(getMedian(arr1, arr2, arr1.length, arr2.length));
        double median = findMedianSortedArrays(arr1,arr2);
        System.out.println(String.format("%.2f",median));  
    }
        public static double findMedianSortedArrays(int A[], int B[]) {
        int n = A.length, m = B.length;
        if(n>m)return findMedianSortedArrays(B,A);
        int left = 0, right = n;
        while (left <= right) {
            int partitionA = (left + right)/2;
            int partitionB = (n + m + 1)/2 - partitionA;      // partitionA + partitionB = (n+m+1)/2
            //if partitionA is 0 then take INT_MIN for maxLeftA (nothing is left in the left of partition)
            double maxLeftA = Integer.MIN_VALUE;
            if(partitionA > 0){
                maxLeftA = A[partitionA-1];
            }
                
            //if partitionA is n then take INT_MAX for minRightA (nothing is left in the right of partition)
            double minRightA = Integer.MAX_VALUE;
            if(partitionA < n){
                minRightA = A[partitionA];
            }
                
            //Similarly for maxLeftB and minrightB
            double maxLeftB = Integer.MIN_VALUE;
            if(partitionB > 0){
                maxLeftB = B[partitionB-1];
            }
                    
            double minRightB = Integer.MAX_VALUE;
            if(partitionB < m){
                minRightB = B[partitionB];
            }
            if (maxLeftA <= minRightB && maxLeftB <= minRightA) {     // check weather it's a perfect partition or not
                if ((n+m) % 2 == 0) {                                // if the sorted merged array is of even length
                    return (Math.max(maxLeftA, maxLeftB) + Math.min(minRightA, minRightB))/2.0;
                } 
                else {
                    return Math.max(maxLeftA, maxLeftB);
                }
            } 
            else if (maxLeftA > minRightB) {                          //move left side.
                right = partitionA - 1;
            }
            else {                                                   // move right side
                left = partitionA + 1;
            }
        }
        return 0.0;    // we can't find the median if input is invalid i.e., arrays are not sorted
    }
}




Sum of minimum and maximum elements of subarrays
https://www.tutorialcup.com/interview/queue/sum-of-minimum-and-maximum-elements-of-all-subarrays-of-size-k.htm
Given an array of size N, your task is to calculate the total sum of maximum and minimum elements in each subarray of size K. See example for better understanding.
Sample Input:-
5 3
1 2 3 4 5
Sample Output:-
18
Explanation:-
For subarray 1 2 3 :- 1 + 3 = 4
For subarray 2 3 4 :- 2 + 4 = 6
For subarray 3 4 5 :- 3 + 5 = 8
total sum = 4+6+8 = 18
Done Using Deque but should be using Queue
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();;
        int arr[] = new int[n];
        for (int i = 0; i < n; i++){
            arr[i] = sc.nextInt();
        }
         System.out.println(sumOfMinMax(arr, k));
    }
    private static long sumOfMinMax(int[] arr, int k) {
        int n = arr.length;
        // initialize sum as 0
        long sum = 0;
        // create 2 deques d1 and d2
        Deque<Integer> q1 = new LinkedList<>();
        Deque<Integer> q2 = new LinkedList<>();
        // first subarray
        for (int i = 0; i < k; i++) {
            // only push the elements that may contribute to maximum
            while (!q1.isEmpty() && arr[q1.peekLast()] <= arr[i])
                q1.removeLast();
            // only push the elements that may contribute to minimum
            while (!q2.isEmpty() && arr[q2.peekLast()] >= arr[i])
                q2.removeLast();
            // add the current elememt's index
            q1.addLast(i);
            q2.addLast(i);
        }
        // sum of min and max for first subarray
        sum += arr[q2.peekFirst()] + arr[q1.peekFirst()];
        // traverse the remaining subarray
        for (int i = k; i < n; i++) {
            // remove the previous element (sliding window technique)
            while (!q2.isEmpty() && q2.peekFirst() <= i - k)
                q2.removeFirst();
            while (!q1.isEmpty() && q1.peekFirst() <= i - k)
                q1.removeFirst();
            // only push the elements that may contribute to maximum
            while (!q1.isEmpty() && arr[q1.peekLast()] <= arr[i])
                q1.removeLast();
            // only push the elements that may contribute to minimum
            while (!q2.isEmpty() && arr[q2.peekLast()] >= arr[i])
                q2.removeLast();
            // add the current element's index
            q1.addLast(i);
            q2.addLast(i);
            // sum of min and max for current subarray
            sum += arr[q2.peekFirst()] + arr[q1.peekFirst()];
        }
        // return total sum
        return sum;
    }
}


operations on queue
Given a queue of integers and N queries. Your the task is to perform these operations:-
enqueue:-this operation will add an element to your current queue.
dequeue:-this operation will delete the element from the starting of the queue
displayfront:-this operation will print the element presented at front
Note:-if queue is empty than dequeue operation will do nothing, and 0 will be printed as a front element of queue if it is empty. Input User task:
Since this will be a functional problem, you don't have to take input. You just have to complete the functions:
enqueue():- that takes the queue and the integer to be added as a parameter.
dequeue:- that takes the queue as parameter.
displayfront :- that takes the queue as parameter.
Output  You don't need to print anything else other than in displayfront() in which you require to print the element at front of your queue in a new line, if the queue is empty you just need to print 0.
Sample Input:-
7
displayfront
enqueue 2
displayfront
enqueue 4
displayfront
dequeue
displayfront
Sample Output:-
0
2
2
4
Output
You don't need to print anything else other than in displayfront() in which you require to print the element at front of your queue in a new line, if the queue is empty you just need to print 0.

// enqueue():- that takes the queue
// and the integer to be added as a parameter.
public static void enqueue( Queue<Integer> qu, int x){
        //qu.add(x);
        //qu = new LinkedList<>();
        qu.add(x);
        //System.out.println(qu);
  
}
// dequeue():- that takes the queue as parameter.
public static void dequeue(Queue<Integer> qu){    
        if(qu. isEmpty()){
            return;
        }else{
            //qu.remove();
            qu.poll();
        }
        
}
// displayfront():-  that takes the queue as parameter.
public static void displayfront(Queue<Integer> qu){
    if(qu. isEmpty()){
        System.out.println("0");
    }else{
        //qu.peek();
        System.out.println(qu.peek());
    }
}



https://www.youtube.com/watch?list=TLGGgGvI8y7N4tcwMjA3MjAyMg&time_continue=123&v=wuwE7g8VvgQ&feature=emb_logo
https://www.pepcoding.com/resources/data-structures-and-algorithms-in-java-levelup/stacks/lexicographically-smallest-subsequence-official/ojquestion#
Lexo Sequence (Contest)
Given an array Arr of size N and an integer K. Todo wants you to find lexicographically minimum subsequence of the array of size K.
A subsequence is a sequence that can be derived from array by deleting some or no elements without changing the order of the remaining elements.
A sequence X is lexicographically smaller than Y if in the first position where X and Y differ, subsequence X has a number less than the corresponding number in Y. Print K integers denoting the lexicographically minimum subsequence of the array of size K.
Sample Input 1- 5 2	12 2 1 3 4
Sample Output -1 1 3
Sample Input -2   5 4	12 2 1 3 4
Sample Output -2  2 1 3 4

class Main {
    public static void main (String[] args)  {
        //BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
        //int n = Integer.parseInt(read.readLine());
        //int k = Integer.parseInt(read.readLine());
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();;
        int arr[] = new int[n];
        for (int i = 0; i < n; i++){
            arr[i] = sc.nextInt();
        }
        
        int result[] = smallestLexoSequence(arr, k);
        //System.out.println(result.length);

        for (int j : result) {
            System.out.print(j + " ");
        }
    }

    public static int[] smallestLexoSequence(int[] num, int k) {
	//we use stack beacause elemtn deletion and adding anf checking 
        //doing from the last so its easy to do this using stack.
        Stack<Integer> st =  new Stack<>();
        int n = num.length; 
        for(int i = 0; i<n ;i++){
            int val = num[i];
 //here we are cheking num with stack peek elment small hai ke nahi.
            //first we validate the number is valid to add in stack or not 
            //Second we comare the elemtn we added in stack with new elemnt if small we pop
            // the previous elemt and if grter and its valid to the add in to get sequence 
            // then we also check the size of k windows size to add subsequence which valid and smaller.
	//we also check the while we select k size elemnt if its present in the given array or not
            //means simple checking the k size subsequence banane ke liye elent hai ya nahi.
	// jab tak elemtn valid hai to get in first position if next elemnt smaller that one can put first by poping pervious elemt
            while(st.size() > 0 && num[i] < st.peek() && n-i-1 >= k-st.size()){
 // n-i-1  --this give the remaing elemnt in arr from left and right when select
                //inde from where we want reaming elemnt hai ya nhi
                // k - st.size()) this will give the requirement of k digit elemnt 
                st.pop();	
            }
//before adding check k digit hogye hai ya nhi
            if(st.size()<k){
                st.push(val);
            }
        }
        int ans[] = new int[k];
        int i = k -1;
        while (i>=0) ans[i--] = st.pop();
        return ans;
    }
}


Minimum absolute difference
Given an array of size N, find the index which partitions the arrays into 2 subarrays such that absolute difference of their sums is minimized. If we partition with respect to index i (1<=i<=N) subarrays will be:- (A1,A2,A3.....Ai-1) , (Ai+1,Ai+2,......An) .Print the index for minimum absolute difference. If more than one answer exists print the minimum index.
Sample input:-
4
1 2 3 4
Sample output:-
3
Explanation:-
For index 1 absolute difference = 2 + 3 + 4 = 9
For index 2 absolute difference = 3 + 4 - 1 = 6
For index 3 absolute difference = 4 - 1 - 2 = 1
For index 4 absolute difference = 1 + 2 + 3 = 6

class Main {
    public static void main (String[] args) {
       
        Scanner sc = new Scanner(System.in);
        int arrSize = sc.nextInt();
        long[] arr = new long[arrSize];
        //taking first value to add withreaming
        arr[0] = sc.nextInt();
        for(int i = 1; i < arrSize; i++){
            arr[i] = arr[i - 1]+ sc.nextInt();
            System.out.println(arr[i]);
        }
        int indexMin = 0;
        long min = Integer.MAX_VALUE, temp = 0;
        for(int i = arrSize - 1; i >= 0; i--){
            if(i == (arrSize - 1)){
                temp = arr[i - 1];
                System.out.println("firstif " + temp + " " + arrSize);
            }else if(i == 0){
                temp = arr[arrSize - 1] - arr[i];
               // System.out.println( arr[arrSize - 1] + " " + arr[i] +" ");
               // System.out.println("middle else " + temp);
            }else{
                temp = Math.abs(arr[i - 1] - (arr[arrSize - 1] - arr[i]));
                //System.out.println(arr[i - 1] +" " + arr[arrSize - 1] + " " + arr[i] +" ");
                //System.out.println("last else " + temp);
            }
            if(temp <= min){
                indexMin = i;
                min = temp;
                //System.out.println("in min " + min);
            }
        }
        System.out.println(indexMin + 1);
    }
}


Zero Window Sum
You are given an array arr of length "n" and a window of size "k". Your task is to find the window with zero sum. If there exists multiple windows, you need to print the first occurring window index and index start with 1 and if no such window exists print -1. Print the window number, If multiple such windows exists print the first window number with zero sum, If no window exists print -1.
Sample Input 1:
4 3
1 0 -1 1
Sample Output 1:  1
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int sizeArr= sc.nextInt();
        int queriesK = sc.nextInt();
        int[] arr = new int[sizeArr];
        for(int i = 0; i <sizeArr; i++){
            arr[i] = sc.nextInt();
            //System.out.println(arr[i] + " ");
        }
        subArraySum(arr,queriesK);
    }
    public static void subArraySum(int arr[], int k)  {
        long sum = 0;
        for(int i = 0; i < k; i++){
            sum += arr[i];
        }
        if(sum == 0){
            System.out.println(1);
            return;
        }
        for(int i = 1; i <= arr.length - k; i++){
            sum = sum - arr[i - 1] + arr[ i + k - 1];
            if(sum == 0){
                System.out.println(i + 1);
                return;
            }
        }
        System.out.println(-1);
    }
     
}


https://www.callicoder.com/maximum-sum-subarray-of-size-k/----https://www.youtube.com/watch?v=Z6GXrVGQ0zs
Max Widow Sum You are given an array of integers arr of size n, a window of size k. Your task is to find the sum of the maximum element from each window.
Sample Input 1:
5 3
1 2 3 4 5
Sample Output 1:
12
Sample Input 2:
6 2
2 3 1 7 8 3
Sample Output 2:
29

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int sizeArr= sc.nextInt();
        int queriesK = sc.nextInt();
        int[] arr = new int[sizeArr];
        for(int i = 0; i <sizeArr; i++){
            arr[i] = sc.nextInt();
           // System.out.println(arr[i] + " ");
        }
        System.out.print(findSumMaxSubarrayOfSizeK(arr,sizeArr, queriesK));
print_max(arr,sizeArr,queriesK);
    }
	public static void print_max(int a[], int n, int k){
		// max_upto array stores the index
		// upto which the maximum element is a[i]
		// i.e. max(a[i], a[i + 1], ... a[max_upto[i]]) = a[i]
		int[] max_upto = new int[n];
		// Update max_upto array similar tofinding next greater element
		Stack<Integer> s = new Stack<>();
		s.push(0);
		for (int i = 1; i < n; i++)	{
			while (!s.empty() && a[s.peek()] < a[i])
			{
				max_upto[s.peek()] = i - 1;
				s.pop();
			}
			s.push(i);
		}
		while (!s.empty()){
			max_upto[s.peek()] = n - 1;
			s.pop();
		}
		int j = 0;
		long maxSum = 0;
		for (int i = 0; i <= n - k; i++){
			// j < i is to check whether the
			// jth element is outside the window
			while (j < i || max_upto[j] < i + k - 1){
				j++;
			}
			maxSum+= a[j];
			//System.out.print(a[j] + " " + maxSum );
			//System.out.print(maxSum );
		}
		System.out.print(maxSum );
		System.out.println();
	}

    private static long findSumMaxSubarrayOfSizeK(int[] a,int n, int k) {
        int[] windowSum = new int[n];
        Stack<Integer> st = new Stack<>();
        windowSum[n - 1] = n;
        //System.out.println(windowSum[n - 1]);
        st.push(n - 1);
        for(int i = n - 2; i >= 0; i--){
            while(st.size() > 0 && a[i] > a[st.peek()]){
                //System.out.println("in whilecheck arr " + a[i] + " stackpeak " + a[st.peek()]);
                st.pop();
            }
            if(st.size() == 0){
                windowSum[i] = n;
                //System.out.println("stacksize0 winsumsize "+windowSum[n - 1]);
            }else{
                windowSum[i] = st.peek();
            }
            st.push(i);
        }

        int j = 0;
        long maxSum = 0;
        for(int i = 0; i <= n - k; i++){
            if(j < i){
                j = i;
                //System.out.println("j " +j);
            }
            while(windowSum[j] < i + k){
                //System.out.println("winj <i+k" +windowSum[j]);
                j = windowSum[j];
                //System.out.println("j " +j);
            }
            maxSum += a[j];
        }
        //System.out.println(maxSum);

        return maxSum;
    }
}
https://www.geeksforgeeks.org/sliding-window-maximum-maximum-of-all-subarrays-of-size-k-using-stack-in-on-time/?ref=rp
another approch
    // Function to print the maximum for every k size sub-array
	public static void print_max(int a[], int n, int k){
		// max_upto array stores the index
		// upto which the maximum element is a[i]
		// i.e. max(a[i], a[i + 1], ... a[max_upto[i]]) = a[i]
		int[] max_upto = new int[n];
		// Update max_upto array similar tofinding next greater element
		Stack<Integer> s = new Stack<>();
		s.push(0);
		for (int i = 1; i < n; i++)	{
			while (!s.empty() && a[s.peek()] < a[i])
			{
				max_upto[s.peek()] = i - 1;
				s.pop();
			}
			s.push(i);
		}
		while (!s.empty()){
			max_upto[s.peek()] = n - 1;
			s.pop();
		}
		int j = 0;
		long maxSum = 0;
		for (int i = 0; i <= n - k; i++){
			// j < i is to check whether the
			// jth element is outside the window
			while (j < i || max_upto[j] < i + k - 1)
			{
				j++;
			}
			maxSum+= a[j];
			//System.out.print(a[j] + " " + maxSum );
			//System.out.print(maxSum );
		}
		System.out.print(maxSum );
		System.out.println();
	}
}

array implementation of queue
Your are given an array and Q queries. Your task is to perform these operations:-
enqueue:-this operation will add an element to your current queue.
dequeue:-this operation will delete the element from the starting of the queue
displayfront:-this operation will print the element presented at front
Sample Input:-
8 2
displayfront
enqueue 2
displayfront
enqueue 4
displayfront
dequeue
displayfront
enqueue 5
Sample Output:-
Queue is empty
2
2
4
Queue is full

Explanation:-here size of given array is 2 so when last enqueue operation perfomed the array was already full so we display the msg "Queue is full". 
/*
  class Queue{ 
    static final int MAX = 10000; 
    int rear=0,front=0; 
    int a[] = new int[MAX]; 
}
   int rear=0,front=0; //pointer to rear and front
    int a[] //array that contain elements of queue
*/ 
  public static void enqueue(int x, int k)  {
      if(rear == k){
        System.out.println("Queue is full");
        return;
      }else{
        a[rear] = x;
        rear++;
      }
      return;
  }

  public static  void dequeue() {
    if(front > rear || front == rear ){
      System.out.println("Queue is empty");
      return;
    }else{
      front++;
    }
    return;
  }

  public static void displayfront() {
      if (front == rear) {
        System.out.println("Queue is empty");
        return;
      }
      for(int i = front; i < rear; i++){
        System.out.println(a[i]);
        return;
      }
      
    }
}

Stack operations
Given a stack of integers and N queries. Your task is to perform these operations:-
push:-this operation will add an element to your current stack.
pop:-remove the element that is on top
top:-print the element which is currently on top of stack Note:-if stack is already empty than pop operation will do nothing and 0 will be printed as a top element of stack if it is empty.
Input:
7
push 1
push 2
top
pop
top
pop
top
Output:
2
1
0
Need 
public static void push(Stack<Integer> st, int x)
    {
       st.push(x);
       //return;
    }

    // Function to pop element from stack
    public static void pop(Stack<Integer> st){
        if(st.empty()){
          //System.out.println("0");
            return;
        }else{st.pop();}
        
        //Integer y = (Integer) st.pop();
        //System.out.println(y);
        //return;
    }
    public static void top(Stack<Integer> st)   {
        if(st.empty()){
            System.out.println("0");
            return;
        }else{
            //Integer element = (Integer) st.peek();
            System.out.println(st.peek());
        }            
        
    }


Evaluate Expression using Stack
Given a postfix expression, your task is to evaluate given expression.
Infix expression: The expression of the form a operator b. When an operator is in-between every pair of operands.
Postfix expression: The expression of the form a b operator. When an operator is followed for every pair of operands.
Valid operators are +, -, *, /. Each operand may be an integer or another expression.
Input 1: 5
2 1 + 3 *
Output 1: 9

class Main {
	public static void main (String[] args) {
        Scanner sc= new Scanner(System.in);
		int sizeStr = sc.nextInt();
		int operandA = 0, operandB = 0, varOperator = 0, temp = 0;
		Stack st = new Stack();
		String[] strInput = new String[sizeStr];

		for(int i = 0; i < sizeStr; i++){
			strInput[i]= sc.next();
		}

		for(int i = 0; i < sizeStr; i++){
			if((strInput[i].length()) > 1){
				temp = 1;
				varOperator = 0;
				for(int j = strInput[i].length() - 1; j >= 0; j--){
					//System.out.println(j+"      "+((s[i]).charAt(j)));
					varOperator += temp * (((strInput[i]).charAt(j)) - 48);
					//System.out.println(k);
					temp *= 10;
				}
				varOperator += 48;
				//System.out.println(temp);
			}else{
				varOperator = (strInput[i]).charAt(0);
			}
			// System.out.println(i+"    "+varOperator);
			// ASCII values of operator which we will match with opetator varibale
			// then we perform operation on two operand ..
			//Addition
			if(varOperator == 43){
				operandA = (int) st.peek();
				st.pop();
				operandB = (int) st.peek();
				st.pop();
				st.push(operandA + operandB);
			//Subtration
			}else if(varOperator == 45){
				operandA = (int)st.peek();
				st.pop();
				operandB = (int)st.peek();
				st.pop();
				st.push(operandB - operandA);
			// Multiplication
			}else if(varOperator == 42){
				operandA = (int)st.peek();
				st.pop();
				operandB = (int)st.peek();
				st.pop();
				st.push(operandB * operandA);
			//Division
			}else if(varOperator == 47){
				operandA = (int)st.peek();
				st.pop();
				operandB = (int)st.peek();
				st.pop();
				st.push(operandB / operandA);

			}else{
				st.push(varOperator - 48);
			}
			// System.out.println(st.peek());
		}
		System.out.println(st.peek());
	}
}

Subarray minima ----important link for this question https://www.youtube.com/watch?v=Ulb3ixSpE4Y
You are given an array(Arr) of N Distinct integers. You have to find the sum of minimum element of all the subarrays (continous) in that array. See Sample for better understanding.
----public int m = (int)Math.pow(10,9)+7
class Main {
	static class pairElement{
		long first, second;
		public pairElement(long first, long second){
			this.first = first;
			this.second = second;
		}
	}

	// Function to return required minimum sum
	public static long sumSubarrayMins(long arr[]){
		int []left = new int[arr.length];
		int []right = new int[arr.length];

		Stack<pairElement> s1 = new Stack<pairElement>();
		Stack<pairElement> s2 = new Stack<pairElement>();
		
		// first Stack getting number of element strictly larger than A[i] on Left.
		for (int i = 0; i < arr.length; ++i){
			int count = 1;
			// get elements from stack until element  greater than A[i] found
			while (!s1.isEmpty() && (s1.peek().first) > arr[i]){
				count += s1.peek().second;
				s1.pop();
			}
			s1.push(new pairElement(arr[i], count));
			left[i] = count;
		}

		// Second Stack getting number of element larger than A[i] on Right.
		for (int i = arr.length - 1; i >= 0; --i){
			int count = 1;
			//get elements from stack until element greater or equal to A[i] found
			while (!s2.isEmpty() &&	(s2.peek().first) >= arr[i]){
				count += s2.peek().second;
				s2.pop();
			}
			s2.push(new pairElement(arr[i], count));
			right[i] = count;
		}

		long result = 0;

		// calculating required resultult
		for (int i = 0; i < arr.length; ++i)
			result = (result + arr[i] * left[i] * right[i]);

		return result;
	}


	public static void main(String[] args){
		Scanner sc = new Scanner (System.in);
		int sizeArr = sc.nextInt();
		long[] arr = new long[sizeArr];
		for(int i = 0; i<sizeArr; i++){
			arr[i] = sc.nextLong();
		}
		// function call to get required result
		System.out.println(sumSubarrayMins(arr));
	}
}



Stack implemetation using linked list .. Your task is to implement a stack using a linked list and perform given queries
Note:-if stack is already empty than pop operation will do nothing and 0 will be printed as a top element of stack if it is empty.
Input:
7
push 1
push 2
top
pop
top
pop
top
Output:
2
1
0 
/*  
class Node {
    Node next;
    int val;

    Node(int val) {
        this.val = val;
        next = null;
       
    }
}
 */
Node top = null;
public void push(int x){
    Node n = new Node(x);
        if(top == null){
            top = n;
        }
        else{
            n.next = top;
            top = n;
        }

}

public void pop(){
//enter your code here
    if(top == null){
        //System.out.println("0"); 
        return;
    }
    top = top.next;
}

public void top(){
    if(top == null){
        System.out.println("0");
        return;
    }
    System.out.println(top.val);
}


Pair Hate (Contest) Stack Proble In Class
Given a string S you have to remove all pairs of identical letters, which are consecutive. If after the removal there appear new pairs, remove them as well. Repeat this untill no adjacent letter in the string is same.
Note that deleting of the consecutive identical letters can be done in any order, as any order leads to the same result.
Sample Input - hhoowaaaareyyoouu 
Sample Output - wre
Explanation:
First we remove "hh" then "oo" then "aa" then "yy" then "oo" then "uu" and we are left with "wre".
Now we cannot remove anything.

class Main {
	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
		String str = sc.next();
		Stack stack = new Stack();
		int duplicateLetter = ' ';

		for(int i = str.length() - 1; i >= 0; i--){
			duplicateLetter = str.charAt(i) - 96;
			//System.out.println(x);
			if(stack.isEmpty()){
				stack.push(duplicateLetter);
			}else{
				if(duplicateLetter == (int) stack.peek()){
					stack.pop();
				}else{
					stack.push(duplicateLetter);
				}
			}
		}
		duplicateLetter = stack.size();
		for(int i = 1; i <= duplicateLetter; i++){
			// System.out.println(st.peek());
			System.out.print((char)((int)stack.peek() + 96));
			stack.pop();
		}
	}
}



Add two numbers
Two numbers are represented in Linked List such that each digit corresponds to a node in linked list. Your task is to add these two numbers and return the sum in a linked list.
Note:-Linked list representaion of a number is from left to right i.e if the number is 123 than in linked list it is represented as 3->2->1
Sample Input:-
1234 45643
Sample Output:- 46877

/*class Node {
    Node next;
    int data;

    Node(int data) {
        this.data = data;
        next = null;
    }
}
*/

public static Node addNumber(Node first, Node second){
    Node linkList1 = first;
    Node linkList2 = second;
    Node newNode;
    int temp = 0, digit = 0, countOfDigitInList1 = 1, 
        countOfDigitInList2 = 1, elementsList1 = 0, elementsList2 = 0;
    //traverse in list 1. To check digit in String or Input of two Linked list 
    while(linkList1.next != null){
        countOfDigitInList1 ++;
        linkList1 = linkList1.next;
    }
    while(linkList2.next != null){
        countOfDigitInList2 ++;
        linkList2 = linkList2.next;
    }
    //System.out.println("C1 value "+countOfDigitInList1 + " C2 value"+countOfDigitInList2);
    newNode = (countOfDigitInList1 > countOfDigitInList2) ? first : second;
    //System.out.println(" newnode = " + newNode.data + " First = " + first.data + " Second = " + second.data );
    Node newList = newNode;
    //System.out.println(" newnode" + newNode.data);
    linkList1 = first;
    linkList2 = second;
    
    // loops to digit of list 1 and list 2 elements to perform addition
    for(int g = 1; g <= countOfDigitInList1 || g <= countOfDigitInList2; g++){
        if(linkList1 == null){
            elementsList1 = 0;
        }else{
            elementsList1 = linkList1.data;
            linkList1 = linkList1.next;
        }
        if(linkList2 == null){
            elementsList2 = 0;
        }else{
            elementsList2 = linkList2.data;
            linkList2 = linkList2.next;
        }
        //System.out.println(" a = " + elementsList1 + " b= "+elementsList2 +" temp" + temp);
        temp = elementsList1 + elementsList2 + temp;
        //creating the single digit using mod and then create node of single digit
        digit = temp % 10;
        temp = temp / 10;
        newNode.data = digit;
        if(newNode.next != null){
            newNode = newNode.next;
        }
        //System.out.println(" new node "+newNode.data + " digits "  + digit +"temp "+temp );
    }
    if(temp > 0){
        Node n = new Node(temp);
        newNode.next = n;
        //System.out.println("newNode " + newNode.data);
    }
       
       /* Node dummy = ; 
        Node temp = dummy; 
        int carry = 0;
        while( first != null || second != null || carry == 1) {
            int sum = 0; 
            if(first != null) {
                sum += first.data; 
                first = first.next; 
            }
            
            if(second != null) {
                sum += second.data; 
                second = second.next; 
            }
            
            sum += carry; 
            carry = sum / 10; 
            Node node = new Node(sum % 10); 
            temp.next = node; 
            temp = temp.next; 
        }*/
        return newList;
}

Remove Duplicates from doubly linked list
Given a sorted doubly linked list containing n nodes. Your task is to remove duplicate nodes from the given list.
Example 1:  Input 1<->2<->2-<->3<->3<->4
Output:  1<->2<->3<->4 
hemant
public static Node deleteDuplicates(Node head) {
//complete this function
        Node curr = head;
        LinkedHashSet<Integer> a = new LinkedHashSet<Integer>();
        a.add(curr.val);
        while(curr.next != null){
            curr = curr.next;
            a.add(curr.val);
        }
        //System.out.println(a);

        curr = head;
        for(int i: a){
            curr.val = i;
            curr = curr.next;
        }
        curr.prev.next= null;
        return head;
}
Another app
public static Node deleteDuplicates(Node head) {
  //complete this function if doubly linked list is empty
    if ((head) == null)  return null;
 
    // unordered_set 'us' implemented as hash table
    HashSet<Integer> us = new HashSet<>();
 
    Node current = head, next;
    // traverse up to the end of the list
    while (current != null){
        // if current data is seen before
        if (us.contains(current.val))  {
            // store pointer to the node next to
            // 'current' node
            next = current.next;
            // delete the node pointed to by 'current'
            head = deleteNode(head, current);
            // update 'current'
            current = next;
        }
        else{
            us.add(current.val); // insert the current data in 'us'
            current = current.next; // move to the next node
        }
    }
    return head;
}

static Node deleteNode(Node head_ref, Node del){
    // base case
    if (head_ref == null || del == null)
        return null;
 
    // If node to be deleted is head node
    if (head_ref == del)
        head_ref = del.next;
 
    // Change next only if node to be deleted is NOT the last node
    if (del.next != null)
        del.next.prev = del.prev;
 
    // Change prev only if node to be deleted is NOT the first node
    if (del.prev != null)
        del.prev.next = del.next;
 
    return head_ref;
}

Reversing a double linked list
Given a double linked list with consisting of N nodes, your task is to reverse the linked list and return the head of the modified list.
Input: 6 1 2 3 4 5 6
Output: 6 5 4 3 2 1
Explanation: After reversing the list, elements are as 6 <-> 5 <-> 4 <-> 3 <-> 2 <-> 1.
 public static Node Reverse(Node head) {
      /*Node prev = null;
        Node curr = head;
 
        // traverse the list
        while (curr != null)
        {
            // swap `next` and `prev` pointers for the current node
            swap(curr);
 
            // update the previous node before moving to the next node
            prev = curr;
 
            // move to the next node in the doubly linked list (advance using
            // `prev` pointer since `next` and `prev` pointers were swapped)
            curr = curr.prev;
        }
 
        // update head pointer to the last node
        if (prev != null) {
            head = prev;
        }
 
        return head;*/

        Node temp = null;
        Node current = head;
 
        /* swap next and prev for all nodes of
         doubly linked list */
        while (current != null) {
            temp = current.prev;
            current.prev = current.next;
            current.next = temp;
            current = current.prev;
        }
 
        /* Before changing head, check for the cases like
         empty list and list with only one node */
        if (temp != null) {
            head = temp.prev;
        }
        
        /*Node curr = head;
        
        //curr is on the last node
        while(curr != null){
            System.out.print(curr.val + " ");
            curr = curr.prev;
        }System.out.println();*/
        return head;

}

another
 public static Node deleteDuplicates(Node head) {
//complete this function
        Node curr = head;
        LinkedHashSet<Integer> a = new LinkedHashSet<Integer>();
        a.add(curr.val);
        while(curr.next != null){
            curr = curr.next;
            a.add(curr.val);
        }
        //System.out.println(a);
}

insert node at the head in a doubly linked list
You are given a Doubly linked list and an integer K . Your task is to insert the integer K at the head of the given linked list
public static Node insertnew(Node head,int k) {   
        Node n = new Node(k);
        n.next = head;
        n.prev = null;
        head.prev = n;
        head = n;
        return head;     
    }

Sara's Students (Contest)
Sara has 2*N chocolate boxes with uneven chocolates in them., she wants to distribute the boxes to N of her students. For each student, Sara will pick one box from the start and one box from the end. Since the chocolates are uneven Sara wants to know the maximum number of chocolates a student received.
The boxes are represented by a singly linked list in which each node represents the number of chocolates in the current box.

public static int maxChocolates(Node head) {

    Node curr = head;
    int nBoxes = 1;
    while(curr.next != null){
        nBoxes ++;
        curr = curr.next;
    }
        
    Node firstPtr = head;
    Node lastPtr = head;
    int g = 1, h = 1, l = 1, maxChocolates = 0;
    for(g = 1; g < nBoxes; g++){
        if(g > (nBoxes / 2)){
            break;
        }
        firstPtr = head;
        lastPtr = head;
        for(l = 1; l < g; l++){
            firstPtr = firstPtr.next;
        }
        for(h = 1; h <= nBoxes - g; h++){
            lastPtr = lastPtr.next;
        }

        maxChocolates = (firstPtr.val + lastPtr.val) > maxChocolates ? (firstPtr.val + lastPtr.val) : maxChocolates;
    }

    return maxChocolates;  
}


Add 1 to a number represented as linked list ...A number (n) is represented in Linked List such that each digit corresponds to a node in linked list. Add 1 to it. Note:- Linked list representation of a number is from left to right i.e if the number is 123 than in linked list it is represented as 3->2->1
Input 1:  456 	 Output 1: 457 
/*
class Node {
    Node next;
    int data;

    Node(int data) {
        this.data = data;
        next = null;
    }
}
*/
public static Node addOne(Node head) {  
    //head = reverse(head);
      
    Node curr = head, prev = head;
  
      int sum = curr.data + 1;
      curr.data = sum % 10;
      int carry = sum / 10;
  
      curr = curr.next;  
      while(curr != null){
          sum = curr.data + carry;
          curr.data = sum % 10;
          carry = sum / 10;
          prev = curr;
          curr = curr.next;
      }
      
      if(carry != 0) {
        Node n = new Node(carry);
        prev.next = n;
      }
      
      //head = reverse(head);
      
      return head;       
}

another approach with little change
  static Node addOne(Node head){
// return the head of the modified linked list
        Node curr = head;
        int temp =0, digit=0;
        temp = curr.data +1;
        digit = temp%10;
        temp = temp/10;
        curr.data = digit;
        while(temp>0){
          //System.out.println(temp);
          if(curr.next == null){
            Node n = new Node(temp);
            curr.next = n;
            break;
          }else{
            curr = curr.next;
            temp = temp+ curr.data;
              digit = temp%10;
              temp = temp/10;
              curr.data = digit;
          }
        }
      return head;
}


Deletion in Doubly Linked List
Given a Doubly linked list consisting of N nodes and given a number K. The task is to delete the Kth node from the end of the linked list.
Input:
5 3
1 2 3 4 5

Output:
1 2 4 5

Explanation:
After deleting 3rd node from the end of the linked list, 3 will be deleted and the list will become 1, 2, 4, 5.
public static Node deleteElement(Node head,int k) {
//enter your code here
        Node curr = head;
        int count =0;
        while(curr.next != null){
            curr = curr.next;
            count++;
        }
        count++;
        if(k== count){
            curr = head;
            curr.next.prev= null;
            head = curr.next;
        }else{
            for(int i=0; i<(k-2); i++){
            curr = curr.prev;
        }
        if(k==1){
            curr.prev.next = null;
        }else{
            curr.prev = curr.prev.prev;
            curr.prev.next = curr;
        }
        }
        return head;
}


Delete even nodes from the list
Given a circular singly linked list containing N nodes, the task is to delete all the even nodes from the list.
Note:-The first digit of the list will always be an odd integer. 
Sample Input:- 
4
1 2 3 4
Sample Output:-
1 3

Explanation:
1- >2- >3- >4- >1
After deletion of nodes
1- >3- >1 

static Node deleteEven(Node head){
//Enter your code here
    Node currPtr = head;
    Node next;
//Traverse the list till the end agar if the node is even then delete it
    do{
        if(currPtr.data % 2 == 0){
            deleteNode(head, currPtr);
        }
        next = currPtr.next;
        currPtr = next;
    }
    while(currPtr != head);
    return head;
} 

static Node deleteNode(Node head, Node del){
    Node temp = head;
    // agar node to be deleted is head node hai to 
    if(head == del){
        head = del.next;
    }

    while(temp.next != del){
        temp = temp.next;
    }
    //agar if not equal then copy the deletewale ka adre to temp ptr
    temp.next = del.next;
    return head;
}
Another app
static Node deleteEven(Node head){
//Enter your code here
        Node i = head;
        while(i.next.next != head){
            if(i.next.data%2 == 0){
                i.next = i.next.next;
            }else{
                 i = i.next;
            }
        }
        if(i.next.data%2 == 0){
            i.next = head;
        }
        return head;
}

Insertion in circular linked list
Given a circular linked list consisting of N nodes and an integer K, your task is to add the integer K at the end of the list.
Note:Examples in Sample Input and Output just shows how a linked list will look like depending on the questions. Do not copy-paste as it is in custom input
Sample Input 1:- 3
1- >2- >3
4
Sample Output 1:-
1- >2- >3- >4 


Another app
public static Node Insertion(Node head, int K){
//Enter your code here      
        Node i = head;
        while(i.next != head){
            i = i.next;
        }
        Node n = new Node(K);
        i.next = n;
        i.next.next = head;
        return head;
}

Delete the Middle of the Linked List 
Given a singly linked list, delete middle node of the linked list. For example, if given linked list is 1->2->3->4->5 then linked list should be modified to 1->2->4->5.
If there are even nodes, then there would be two middle nodes, we need to delete the second middle element. For example, if given linked list is 1->2->3->4->5->6 then it should be modified to 1->2->3->5->6. 
In case of a single node return the head of a linked list containing only 1 node which has value -1

/*
class Node {
    Node next;
    int val;

    Node(int val) {
        this.val = val;
        next = null;
    }
}
*/

public static Node deleteMiddleElement(Node head) {
        int count=0; // length
        Node curr = head;
       // Node prev = head;
        while (curr != null){
            count++;
            curr = curr.next;
        }
        if(count == 1){
            head.val = -1;
            return head;
        }
    //In case of a single node return the head of a linked list
        //containing only 1 node which has value -1
        if(count == 2){
            head.next = null;
            return head;
        }
        curr = head;
        int I = 1;
        count = count/2;
        while(I != count){
            curr=curr.next;
            I++;
        }
        curr.next = curr.next.next;
        return head;

}

another approch with same logic bs thoda sa change hai
public static Node deleteMiddleElement(Node head) {
		// return the head of the modified Linked List
         int count = 0; //length
        //reference of the head.
        Node curr = head;
        Node prev = head;
        while(curr.next !=null){
            count++;
            curr = curr.next;
        }
        count++;
        //System.out.println(count);
        if(count==1){
            curr.val = -1;
        }
        count = count/2;
        curr = head;
        for(int i=0;i<count;i++){
            prev = curr;
            curr = curr.next;
        }
        //deleting curr node
        prev.next = curr.next;
        return head;}

Insertion node at kth postition in doubly linked list
Given a doubly linked list consisting of N nodes and two integers P and K. Your task is to add an element K at the Pth position from the start of the linked list
Sample Input:-
5 3 2
1 3 2 4 5
Sample Output:-
1 3 2 2 4 5

public static Node insertnew(Node head, int K, int P) {   
    Node curr = head;
            Node newNode = new Node(K);
            //At First Position
            if(P == 1){
                newNode.prev = null;
                newNode.next = head;
                //head.prev = n;
                head = newNode;
            }else{ 
                for(int i = 1; i < P; i++){
                    curr = curr.next;
                }    
                //inseting element at location
                newNode.prev = curr.prev;
                newNode.next = curr;
                newNode.prev.next = newNode;
                newNode.next.prev = newNode;
            }
            
            return head;     
}


Sort Doubly Linked List Using Merge Sort 
The head of the doubly linked list will be given to you, and you must sort it using merge sort.
Sample Input:
5
3 2 1 3 2
Output:
1 2 2 3 3

Node mergeSort(Node node, int n) {
     if (node == null || node.next == null) {
            return node;
        }
        Node second = split(node);
 
        // Recur for left and right halves
        node = mergeSort(node,n);
        second = mergeSort(second,n);
 
        // Merge the two sorted halves
        return merge(node, second); 
}
// Split a doubly linked list (DLL) into 2 DLLs of
    // half sizes
Node split(Node head) {
	Node fast = head, slow = head;
	while (fast.next != null && fast.next.next != null) {
		fast = fast.next.next;
		slow = slow.next;
	}
	Node temp = slow.next;
	slow.next = null;
	return temp;
}

 // Function to merge two linked lists
Node merge(Node first, Node second) {
	// If first linked list is empty
	if (first == null) {
		return second;
	}

	// If second linked list is empty
	if (second == null) {
		return first;
	}

	// Pick the smaller value
	if (first.data < second.data) {
		first.next = merge(first.next, second);
		first.next.prev = first;
		first.prev = null;
		return first;
	} else {
		second.next = merge(first, second.next);
		second.next.prev = second;
		second.prev = null;
		return second;
	}
}

Deletion in Doubly Linked List
Given a Doubly linked list consisting of N nodes and given a number K. The task is to delete the Kth node from the end of the linked list.
Input:
5 3
1 2 3 4 5
Output:
1 2 4 5
Explanation:
After deleting 3rd node from the end of the linked list, 3 will be deleted and the list will become 1, 2, 4, 5.
public static Node deleteElement(Node head,int k) {
//enter your code here
        Node curr = head;
        int count =0;
        while(curr.next != null){
            curr = curr.next;
            count++;
        }
        count++;
        if(k== count){
            curr = head;
            curr.next.prev= null;
            head = curr.next;
        }else{
            for(int i=0; i<(k-2); i++){
            curr = curr.prev;
        }
        if(k==1){
            curr.prev.next = null;
        }else{
            curr.prev = curr.prev.prev;
            curr.prev.next = curr;
        }
        }
        return head;
}
another
public static Node deleteElement(Node head,int k) {
//enter your code here

    Node curr = head;
    int positionCount = 0;
    while(curr.next != null){
        curr = curr.next;
        positionCount++;
    }
    positionCount++;
    //System.out.println( k + " "+positionCount);
    //if Kelement in the last position in linked list
    if(k == positionCount){
        curr = head;
        curr.next.prev = null;
        head = curr.next;
    }else{
        // from end delting the node 
        for(int i = 0; i < (k - 2); i++){
        curr = curr.prev;
    }
    if(k == 1){
        curr.prev.next = null;
    }else{
        curr.prev = curr.prev.prev;
        curr.prev.next = curr;
    }
    }
    return head;
}


Delete every Kth node
Given a linked list consisting of N nodes, your task is to delete every kth Node from the circular linked list until only one node is left. Also, print the intermediate lists
Note:Examples in Sample Input and Output just shows how a linked list will look like depending on the questions. Do not copy-paste as it is in custom input
Output Print the intermediate nodes until one node is left as shown in example.
Example Sample Input:-
4 2
1 2 3 4
Sample Output:-
1->2->3->4->1
1->2->4->1
2->4->2
2->2 


/*

 class Node 
{  
    int data;  
    Node next;  
    Node(int x)  
    {  
        data = x;  
        next = null;  
    }  
};
*/
static Node deleteK(Node head, int k){
    // If list is empty, simply return.
    if (head == null)
        return null;
    // take two pointers - current and previous
    Node curr = head, prev=null;
    while (true)  {
        // Check if Node is the only Node agar yes, we reached the goal, fir return.
        if (curr.next == head && curr == head)
            break;
        // Print intermediate list.
        printList(head);
 
        // If more than one Node present in the list,// Make previous pointer 
        //point to current  Iterate current pointer k times,    // i.e. current Node is to be deleted.
        for (int i = 0; i < k; i++)    {
            prev = curr;
            curr = curr.next;
        }
 
        // If Node to be deleted is head
        if (curr == head) {
            prev = head;
            while (prev.next != head)
                prev = prev.next;
            head = curr.next;
            prev.next = head;
            //head_ref = head;
        }
 
        // If Node to be deleted is last Node.
        else if (curr.next == head)  {
            prev.next = head;
        }
        else {
            prev.next = curr.next;
        }
    }
    return head;
} 


static void printList(Node head){
    if (head == null)   return;
    Node temp = head;
    do{
        System.out.print( temp.data + "->");
        temp = temp.next;
    }
    while (temp != head);
    System.out.println(head.data );
}

another approch litterchange

/*

 class Node 
{  
    int data;  
    Node next;  
    Node(int x)  
    {  
        data = x;  
        next = null;  
    }  
};
*/
static Node deleteK(Node head, int k){
//Enter your code here
        Node i= head;
        int n=1;
        while(i.next != head){
            n++;
            i = i.next;
        }
        // System.out.println(n);
        i = head;
        int count =0;
        count = print(head, count);
        while(count<n){
            for(int j=1; j<k; j++){
                i = i.next;
            }
            if(i.next == head){
                head = i.next.next;
            }
            i.next = i.next.next;
            count = print(head, count);
        }
        return head;
}

static int print(Node head, int count){
    Node i= head;
    while(i.next != head){
        System.out.print(i.data+"->");
        i = i.next;
    }
    System.out.print(i.data+"->");
    i= i.next;
    System.out.print(i.data);
    System.out.println();
    return ++count;
}



Find a peak element An element is called a peak element if its value is not smaller than the value of its adjacent
elements(if they exists). Given an array arr[] of size N, find the index of any one of its peak elements.

public class Main
{
	public static void main(String[] args) {
		int arr[]={2,3, 2, 5, 9, 8, 5, 9, 7, 10  };
		
		for(int i=1;i<arr.length-1;i++)
		{
		    if(arr[i-1]<arr[i] && arr[i]>arr[i+1]) System.out.print(arr[i]+" ");
		}
		if(arr[0]>arr[1]) System.out.print(arr[0]+" ");
		if(arr[arr.length-1]>arr[arr.length-1-1])  System.out.print(arr[arr.length-1]+" ");
	}
}

Simple Colours
Taro loves colours. Today she is interested in painting bricks. N bricks are arranged in a line. She needs to paint them using K colours. She does not want two adjacent bricks to be painted in same colour. Can you help her find the number of ways she can colour the given N bricks.
As the answer can be large print it modulo 1000000007.
Property: (a*b)%c = ((a%c)*(b%c))%c.
class Main {
	public static void main (String[] args) {
                      // Your code here
		Scanner sc= new Scanner(System.in);
		int n= sc.nextInt();
		int k= sc.nextInt();
		long ans = k;
		for(int i=1; i<n; i++){
			ans= (ans*(k-1))%1000000007;
		}
		System.out.println(ans);
	}
}

class Main {
	static final int modd = 1000000007;
    // Function for finding the power
    static long power(long x, long y, long p) {
        long res = 1;
        // Update x if it is more than or equal to p
        x = x % p;
        while (y > 0) {
            // If y is odd, multiply x with result
            if (y % 2 == 1)  {
                res = (res%p * x%p) % p;
            }
            // y must be even now
            y = y >> 1; // y = y/2
            x = (x%p * x%p) % p;
        }
        return res;
    }
 
    // Function to calculate the number of ways
    static int ways(int n, int m) {
        // Answer must be modulo of 10^9 + 7
        return (int) (power(m - 1, n - 1, modd)
                            * m % modd);
    }
	public static void main (String[] args) {
        Scanner sc =new Scanner(System.in);
		int n = sc.nextInt(), m = sc.nextInt();
		System.out.println(ways(n, m));
	}
}

Modular multiplicative inverse
Given two integers ‘a’ and ‘m’. The task is to find modular multiplicative inverse of ‘a’ under modulo ‘m’.
Note: Print the smallest modular multiplicative inverse.
Sample Input:-
2
3 11
10 17

Sample Output:-
4
12
class Main {
	public static int x;
  	public static int y;
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int testCases = sc.nextInt();
		for(int i = 0; i < testCases;i++){
			int a = sc.nextInt();
			int m = sc.nextInt();
			System.out.println(modInverse(a, m));
			//modInverse(a, m);
		}
		
        //System.out.println(modInverse(a, m));
	}

/*	static int gcdExtended(int a,int b){    
    // Base Case
    if (a == 0){
      x = 0;
      y = 1;
      return b;
    }
    // To store results of recursive call   
    int gcd = gcdExtended(b % a, a);
    int x1 = x;
    int y1 = y;
    // Update x and y using results of recursive
    // call
    int tmp = b/a;
    x = y1 - tmp * x1;
    y = x1;
 
    return gcd;
  } 
 
  static void modInverse(int a,int m){
    int g = gcdExtended(a, m);
    if (g != 1){
      System.out.println("-1");
    }
    else
    {
       
      // m is added to handle negative x
      int res = (x % m + m) % m;
      System.out.println(res);       
    }
  }*/
  static int modInverse(int a, int m) 
    { 
        a = a % m; 
        for (int x = 1; x < m; x++) 
           if ((a * x) % m == 1) 
              return x; 
        return -1; 
    } 
	/*static int modInverse(int a, int m)    {
      
        for (int x = 1; x < m; x++)
            if (((a % m) * (x % m)) % m == 1)
                return x;
        return 1;
    }*/
}

Travelling GCD POST Class
Given N cities in a line and your initial position, you want to visit all the cities at least once. You can go to one coordinate P to P+D or P-D where D is the number of steps which you choose initially.
 Your task is to find the maximum value of D such that you can visit all the cities at least once. Print the maximum value of D such that you can visit all the cities.
Sample Input:-
3 3
1 7 11
Sample Output:-2
Sample Input:-
3 81
33 105 57
Sample Output:-24

class Main {
	public static void main (String[] args) {
       /*Scanner sc = new Scanner (System.in);
	   int citiesN = sc.nextInt();
	   int initialPosition = sc.nextInt();
	   int[] citiesArr = new int[citiesN];
	   int[] maxValueOfD = new int[citiesN];
	   int min = 0;
	   for(int i = 0 ;i<citiesN;i++){
		   citiesArr[i]= sc.nextInt();
		   //System.out.println(citiesArr[i] + " ");
		   if(citiesArr[i] > initialPosition){

			   maxValueOfD[i] = Math.abs(citiesArr[i] - initialPosition);
		   }else{
			  maxValueOfD[i] = Math.abs(initialPosition - citiesArr[i]); 
		   }
		   //System.out.println(maxValueOfD[i] +" ");
			min = maxValueOfD[0];
			min = Math.min(min, maxValueOfD[i]);
	   	}  
		System.out.println(min+" ");*/
		Scanner sc= new Scanner(System.in);
		int n= sc.nextInt();
		int x= sc.nextInt();
		int[] a= new int[n];
		int temp=0;
		for(int i=0; i<n; i++){
			temp= sc.nextInt();
			a[i]= (x > temp) ? (x-temp) : (temp-x);
		}
		temp=a[0];
		for(int i=1; i<n; i++){
			if(a[i]!=0)	{
				temp= (temp < a[i]) ? temp : (a[i]);
			}	
		}
		System.out.println(temp);
	}
}



First two Modulo Arithmatics - In Class - First two
Given a number N your task is to print its first two digits in reverse order. For eg:- If the given number is 123 then the output will be 21.
Sample Input:- 3423 Sample Output:- 43

static int firstTwo(int N){
    int revNum = 0;
    while(N>0){
        revNum = revNum * 10 + N % 10;
        System.out.println(revNum);
        N = N / 10; 
    }
    return revNum % 100;
}



String Basics - Post Clas Infinity Stone : The Time Stone in Mystery Box
The time stone is hidden inside a sacred box which has a lock of N different rings and each ring has 0-9 serially on it. Initially, all N- rings together show an N- digit integer but there is a particular code only that can open the lock. You can rotate each ring any number of times in either direction. You have to find the minimum number of rotations done on rings of the lock to open the lock.
Sample Input:-
4
2345
5432
Sample Output:- 8
Explanation:-
1st ring is rotated thrice as 2- >3- >4- >5
2nd ring is rotated once as 3- >4
3rd ring is rotated once as 4- >3
4th ring is rotated thrice as 5- >4- >3- >2 

class Main {
	    // function for min rotation
    /*public static int infinityStoneMinRotation(int input, int unlock_code){
        int ringRotation = 0;
        int input_digit, lockCode_digit;
        // iterate till input and unlock code become 0
        while (input > 0 || unlock_code > 0) {
            // input number and unlock code last digit as reminder so we can get 
			//calculate how much rotation we need with help of diff of input/lock
            input_digit = input % 10;
            lockCode_digit = unlock_code % 10;
            //find min rotation
            System.out.println(input_digit + " "+ lockCode_digit );
            ringRotation += Math.min(Math.abs(input_digit - lockCode_digit), 
									10 - Math.abs(input_digit - lockCode_digit));
            // update lock code and input by dividing we get new digit to rotate
            input /= 10;
            unlock_code /= 10;
        }
        return ringRotation;
    }*/

	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int sizeofRingNum = sc.nextInt();
        
        String digitOnRings = sc.next();
        String digitOfUnlockCode = sc.next();
		int temp = 0;
		int rotatedResult = 0;
		int input_digit = 0, lockCode_digit = 0;

		for(int i = 0; i < sizeofRingNum; i++){
			input_digit = digitOnRings.charAt(i) - 48;
			lockCode_digit = digitOfUnlockCode.charAt(i) - 48;
	temp = (input_digit > lockCode_digit) ? (input_digit - lockCode_digit) : (lockCode_digit - input_digit);
			if(temp > 5){
				temp = 10 - temp;
			}
			rotatedResult += temp;
		}
		System.out.println(rotatedResult);
        /*for(int i = 0; i < sizeofRingNum; i++){
            digitOnRings[i] = sc.next();
            digitOfUnlockCode[i] = sc.next();
            //System.out.print(digitOnRings[i] + " "+ digitOfUnlockCode[i]);
        }*/
        
        // digitOnRings = digitOnRings.trim ();
        // String digitOfUnlockCode = sc.next();
        //System.out.println(infinityStoneMinRotation(inputCode, lockCode));
        //int digitOnRings = sc.nextInt();   
        //int digitOfUnlockCode = sc.nextInt();
        //System.out.print(infinityStoneMinRotation1(Arrays.toString(digitOnRings),Arrays.toString(digitOfUnlockCode)));
	}

    public static String infinityStoneMinRotation1(String input, String unlock_code){
        int ringRotation = 0;
        int input_digit;
        int lockCode_digit;
        int inputString = Integer.parseInt(input);
        int lockString = Integer.parseInt(unlock_code);
        
        while (inputString > 0 || lockString > 0) {
            input_digit = inputString % 10;
            lockCode_digit = lockString % 10;
            //System.out.println(input_digit + " "+ lockCode_digit );
            ringRotation += Math.min(Math.abs(input_digit - lockCode_digit), 
			10 - Math.abs(input_digit - lockCode_digit));
            //System.out.println(ringRotation );
            inputString /= 10;
            lockString /= 10;
            //break;
        }
        /*while (input > 0 || unlock_code > 0) {
            input_digit = input % 10;
            lockCode_digit = unlock_code % 10;
            System.out.println(input_digit + " "+ lockCode_digit );
            ringRotation += Math.min(Math.abs(input_digit - lockCode_digit), 
		10 - Math.abs(input_digit - lockCode_digit));
    
            input /= 10;
            unlock_code /= 10;
        }*/
        //return String.valueOf(ringRotation);
        System.out.println(Integer.toString(ringRotation));
        return Integer.toString(ringRotation);
    }
}



Insert Operator Recursion(new) - Post Class  Problem Statement
You are given a sequence of numbers of size N. You have to find if there is a way to insert + or - operator in between the numbers so that the result equals K.
Sample Input:-
4 4
1 2 3 4 
Sample Output:- YES 

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
class Main {
	public static void main (String[] args) throws IOException {
		/*Scanner sc = new Scanner(System.in);
		int k = sc.nextInt();
		int sizeN = sc.nextInt();
		int[] arrNum = new int[sizeN];
		for(int i = 0;i<sizeN;i++){
			arrNum[i] = sc.nextInt();
			//System.out.println(arrNum[i]);
		}	
		int sum = 0;
		int res = 0;
		for (int i = 0; i < sizeN; i++) {
           
            for (int j = i+1; j < sizeN; j++) {
                sum += arrNum[j];
                if (sum == k)
                    res++;
            }
        }
		//System.out.println(sum); 
        //System.out.println(res);      
		equalize(arrNum, sizeN, k);  */       
		BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));
		String[] str;
		str = sc.readLine().split(" ");
		int n = Integer.parseInt(str[0]);
		long k = Long.parseLong(str[1]);
		str = sc.readLine().split(" ");
		long[] arr = new long[n];
		for(int i=0; i<n; i++){
			arr[i] = Long.parseLong(str[i]);
		}
		long sum=0;
		
		if(check(arr, k, n, sum)){
			System.out.println("YES");
		}else{
			System.out.println("NO");
		}                                                        
	}
	public static boolean check(long[] arr, long k, int n, long sum){
		if(n == 0){
			if(sum == k){
				return true;
			}
			return false;
		}
		return check(arr, k, n-1, sum + arr[n-1]) || check(arr, k, n-1, sum - arr[n-1]);
	}
	/*public static void equalize(int arr[], int n, int k){
     // Finding the minimum element from the array
		boolean flag = true;
    	if (flag) {
               //return min_ele + k;
			   System.out.println("YES");
	    } else{
    	    //return -1;
			System.out.println("NO");
		}
	}*/

	
}


.
Recursion(new) - Post Class - Interesting Numbers
Problem Statement
Bobs love interesting numbers, According to him, a number is interesting if it follows the given conditions:  The number is positive
    The digits of the number when considered from left to right, they form an alternate odd even sequence. A sequence is an alternate odd even sequence when the numbers present on even indices in the sequence are odd, and the numbers present on the odd indices are even, where the sequence is having 1 based indexing. 
You are given the number K.Task Determine the Kth smallest interesting number. 
Sample Input 1:
1
3
Sample Output 1: 6

Explanation
The first three interesting numbers are [2, 4, 6]. So the 3rd smallest number is 6.

#include <bits/stdc++.h>
using namespace std;
#define int long long
#ifdef LOCAL
#define debug(...) cerr << "[" << #__VA_ARGS__ << "]:", debug_out(__VA_ARGS__)
#else
#define debug(...) 2351
#endif
vector<int> str;
string solve(string s) {
    if (s.length() == 8) {
        return s;
    }
    if (s.length() % 2 == 0) {
        if (s.length() > 0) {
            str.push_back(stoi(solve(s + "0")));
        }
        str.push_back(stoi(solve(s + "2")));
        str.push_back(stoi(solve(s + "4")));
        str.push_back(stoi(solve(s + "6")));
        str.push_back(stoi(solve(s + "8")));
    } else {
        str.push_back(stoi(solve(s + "1")));
        str.push_back(stoi(solve(s + "3")));
        str.push_back(stoi(solve(s + "5")));
        str.push_back(stoi(solve(s + "7")));
        str.push_back(stoi(solve(s + "9")));
    }
    return s;
}

int32_t main() {
    solve("");
    sort(str.begin(), str.end());
    debug(str.size());
    debug(str);
    int tt;
    cin >> tt;
    while (tt--) {
        int k;
        cin >> k;
        cout << str[k - 1] << "\n";
    }
    return 0;
}
/*import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
	public static void main (String[] args) throws IOException {
                      // Your code here
		BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));
		int t= Integer.parseInt(sc.readLine());
		int k=0;
		int count=0;
		String str;
		long i=2;
		while(t-- >0){
			count=0;
			i=2;
			k= Integer.parseInt(sc.readLine());
			while(count!=k){
				str= String.valueOf(i);
				if(check(str)==true){
					//System.out.println(count+ "   "+i);
					count++;
				}i++;
			}
		
			System.out.println(i-1);
		}
	}
	public static boolean check(String st){
		int n= st.length();
		int temp=0;
		for(int i=0; i<n; i++){
			temp= Character.getNumericValue(st.charAt(i));
			if(i%2==0){
				if((temp%2)!=0){return false;}
			}else{
				if((temp%2)==0){return false;}
			}
		}
		return true;
	}
}*/



Exchange Nodes https://www.geeksforgeeks.org/exchange-first-last-node-circular-linked-list/
Given a circular linked list consisting of N nodes, your task is to exchange the first and last node of the list.
Note:Examples in Sample Input and Output just shows how a linked list will look like depending on the questions. Do not copy-paste as it is in custom input
Sample Input 1:-
3
1- >2- >3
Sample Output 1:-
3- >2- >1 
/*
class Node {
    Node next;
    int val;

    Node(int val) {
        this.val = val;
        next = null;
    }
}
*/
public static Node exchangeNodes(Node head) {
    /*if (head == null || head.next == null) {
        return head;
    }
    Node tail = head;
   
    // Find pointer to the last node
    while (tail.next != head) {
        tail = tail.next;
    }
    // Exchange first and last nodes using  head and p
   
    // temporary variable to store
    // head data
    int temp = tail.val;
    tail.val = head.val;
    head.val = temp;
    return head;*/
    if (head.next.next == head) {
            head = head.next;
            return head;
        }
        // Find pointer to previous  of last node
        Node p = head;
        while (p.next.next != head)
            p = p.next;
 
        // Exchange first and last
        // nodes using head and p
        p.next.next = head.next;
        head.next = p.next;
        p.next = head;
        head = head.next;
 
        return head;
}


Insertion in circular linked list
Given a circular linked list consisting of N nodes and an integer K, your task is to add the integer K at the end of the list.
Note:Examples in Sample Input and Output just shows how a linked list will look like depending on the questions. Do not copy-paste as it is in custom input
another sir ways

public void add(int data){
        
        Node n = new Node(data);
        
        if(head == null){
            head = n;
            n.next = head;
        }
        else{
            Node curr = head;
            while(curr.next!=head){
                curr = curr.next;
            }
            curr.next = n;
            n.next = head;
        }
    }
 



Make it Circular Given a singly linked list consisting of N Nodes, your task is to convert it into a circular linked list.
Note:- For custom input you will get 1 if your code is correct else you get a 0.
Note:Examples in Sample Input and Output just shows how a linked list will look like depending on the questions. Do not copy-paste as it is in custom input

/*
class Node {
    Node next;
    int val;

    Node(int val) {
        this.val = val;
        next = null;
    }
}
*/

public static Node MakeCircular(Node head) {
    Node start = head;
    // check that while head.next not equal to null then head
    // points to next node.
    while (head.next != null)
        head = head.next;
         
    // if head.next points to null then start assign to the
    // head.next node.
    head.next = start;
    return start;
}
another simple 
public static Node MakeCircular(Node head) {
//enter your code here
        Node i = head;
        i.next = head;
        return head;
}


Circular linked list
Given a linked list consisting of N nodes, your task is to check if the given list is circular or not.
Note:Examples in Sample Input and Output just shows how a linked list will look like depending on the questions. Do not copy-paste as it is in custom input
Sample Input 1:-
3 0
1 2 3
Sample Output 1:-
0
Explanation:-
1->2->3
Sample Input 2:-
3 1
1 2 3
Sample Output 2:-
1
Explanation:-
1->2->3->1....... 

/*
class Node {
    Node next;
    int val;

    Node(int val) {
        this.val = val;
        next = null;
    }
}
*/

public static int check(Node head) {
       Node slow = head;
        Node fast = head;
 
        // slow pointer will move 1 point at a time.
        // fast pointer will move 2 point at a time.
        boolean cyclePresent = false; //Cycle is not present.
        int circular = 0;
        while(fast!= null && fast.next!=null){
            slow = slow.next;
            fast = fast.next.next; // increasing by 2 times.
            if(slow == fast){
                //System.out.println("Cycle is present");
                cyclePresent = true;
                circular = 1;
                break;
            }
        }
        if(!cyclePresent){
            circular = 0;
            //System.out.println("Cycle is not present");
        }
        return circular;
}

another app
public static int check(Node head) {
//enter your code here
        Node i = head;
        for(int j=0; j<=1000; j++){
            if(i.next == null){
                return 0;
            }
            i = i.next;
        }
        return 1;
}



Delete the Kth node from the end
Given a linked list consisting of N nodes and an integer K, your task is to delete the Kth node from the end of the linked list
Input 1:
5 3
1 2 3 4 5
Output 1:
1 2 4 5
Explanation:
After deleting 3rd node from the end of the linked list, 3 will be deleted and the list will be as 1, 2, 4, 5. 


/*
class Node {
    Node next;
    int val;

    Node(int val) {
        this.val = val;
        next = null;
    }
}
*/

public static Node deleteElement(Node head,int k) {
    //Node head = null;
    Node first = head;
 
        // Second pointer will point to the  Nth node from the beginning
        Node second = head;
        for (int i = 0; i < k; i++) {
            // If count of nodes in the given linked list is <= N
            if (second.next == null) {
                // If count = N i.e. delete the head node
                if (i == k - 1)
                    head = head.next;
                return head;
            }
            second = second.next;
        }
        // Increment both the pointers by one until  second pointer reaches the end
        while (second.next != null) {
            first = first.next;
            second = second.next;
        }
        // First must be pointing to the Nth node from the end by now So, delete the node first is pointing to
        first.next = first.next.next;
        return head;
    
}




Zeros at front of linked list
Given a linked list, the task is to move all 0’s to the front of the linked list. The order of all another element except 0 should be same after rearrangement.
Note: Avoid use of any type of Java Collection frameworks.
Note: For custom input/output, enter the list in reverse order, and the output will also be in reverse order.
Input:
2
10
0 4 0 5 0 2 1 0 1 0
7
1 1 2 3 0 0 0
Output:
0 0 0 0 0 1 1 2 5 4
0 0 0 3 2 1 1
Explanation:
Testcase 1:
Original list was 0->4->0->5->0->2->1->0->1->0->NULL.
After processing list becomes 0->0->0->0->0->4->5->2->1->1->NULL.
Testcase 2:
Original list was 1->1->2->3->0->0->0->NULL.
After processing list becomes 0->0->0->1->1->2->3->NULL.


/*
class Node{
    int data;
    Node next;
    Node(int d){
        data=d;
        next=null;
    }
}
*/
static public Node moveZeroes(Node head){
       if (head == null)
            return null;
         // Traverse the list from second node.
        Node temp = head.next, prev = head;
        while (temp != null) {
            // If current node is 0, move to beginning of linked list
            if (temp.data == 0) {
                // Disconnect node from its current position
                Node curr = temp;
                temp = temp.next;
                prev.next = temp;
                // Move to beginning
                curr.next = head;
                head = curr;
            }else {// For non-zero values
                prev = temp;
                temp = temp.next;
            }
        }
        return head;
}

https://www.geeksforgeeks.org/merge-two-sorted-linked-lists/

Merge two sorted linked list
Given two sorted linked list of size s1 and s2(sizes may or may not be same), your task is to merge them such that resultant list is also sorted.
Sample Input:
5 6
1 2 3 4 5
3 4 6 8 9 10
Sample Output:
1 2 3 3 4 4 5 6 8 9 10

/*
class Node {
    Node next;
    int val;

    Node(int val) {
        this.val = val;
        next = null;
    }
}
*/
/*
below function is used to insert nodes in the linked list
public static Node insert111(Node head, int val) {
        if(head == null) {
            return new Node(val);
        } else {
            Node cur;
            cur = insert111(head.next, val);
            head.next = cur;
            return head;
        }
    }

*/
public static Node Merge (Node head1, Node head2){
        /*if(head1 == null) return head2;
        if(head2 == null) return head1;
         
        if(head1.val < head2.val){
            System.out.println(head1.val + " " + head2.val);
            head1.next = Merge(head1.next, head2);
            System.out.println("H1 NEXT "+head1.val);
            return head1;
        }
        else{
            System.out.println("eLSE --" + head1.val + " " + head2.val);
            head2.next = Merge(head1, head2.next);
            System.out.println("H2 NEXT "+head2.val);
            return head2;
        }*/

    Node tempNode = new Node(0);
     
    /* Using TEMP node as tail points to the last result node */
    Node newResultNode = tempNode;
    while(true){
        /* if either list runs out,  use the other list */
        if(head1 == null) {
            newResultNode.next = head2;
            break;
        }
        if(head2 == null) {
            newResultNode.next = head1;
            break;
        }
         
        /* check the data of the two lists whichever lists' data is
        smaller, append it into tail and advance the head to the next Node  */
        if(head1.val <= head2.val) {
            newResultNode.next = head1;
            head1 = head1.next;
        }
        else
        {
            newResultNode.next = head2;
            head2 = head2.next;
        }
         
        /* Advance the tail */
        newResultNode = newResultNode.next;
    }
    return tempNode.next;       
    
}



Reversing the Linked List
Given a linked list of N nodes. The task is to reverse the list by changing links between nodes (i.e if the list is 1->2->3->4 then it becomes 1<-2<-3<-4) and return the head of the modified list.
Input-1:
6
1 2 3 4 5 6
Output-1:
6 5 4 3 2 1
Explanation:
After reversing the list, elements are as 6->5->4->3->2->1. 
/*
// information about the class Nodeclass Node {
    Node next;
    int val;

    Node(int val) {
        this.val = val;
        next = null;
    }
}
*/


public static Node ReverseLinkedList(Node head) {
        // return the head of the modified linked list
       int count = 0; //length
       //reference of the head.
       Node curr = head;
       Node prev = head;
      
       while(curr.next !=null){
            //System.out.println(curr.next);
            count++;
            curr = curr.next;
       }
       count++;
       //System.out.println(count);
       //we are changing the address.
       Node arr[] = new Node[count];
       curr = head;
       int i =0;
       while(curr != null){
           arr[i++] = curr;
           curr = curr.next;
       }
       head = arr[count - 1];
       curr = head;
       for(i = count - 2 ; i >= 0; i--){
            curr.next = arr[i];
            System.out.println(i);
            curr = curr.next;
       }
       curr.next = null;
       return head;
    }

Inversion count https://www.geeksforgeeks.org/java-program-for-count-inversions-in-an-array-set-1-using-merge-sort/
Calculate inversion count of array of integers.
Inversion count of an array is quantisation of how much unsorted an array is. A sorted array has inversion count 0, while an unsorted array has maximum inversion count. Formally speaking inversion count = number of pairs i, j such that i < j and a[i] > a[j].
Sample Input
5
1 1 3 2 2
Sample Output 2 
class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int arrSize = sc.nextInt();
		int[] arr = new int[arrSize];
        //long[] aux = Arrays.copyOf(arr, arr.length);
		for(int i = 0; i < arrSize; i++){
			arr[i]= sc.nextInt();
			//System.out.println(arr[i]);
		}
        //System.out.println( mergesort(arr, aux, 0, arr.length - 1));
        System.out.println(mergeSortAndCount(arr, 0, arr.length - 1));
	}
    // last me when we get sorted array tab count karenge
    //merge krne se phele inversion count krna hai ...
    private static long mergeInversionCount(int[] arr, int l,  int mid, int r) {
        // // Right subarray and Left subarray
        long inversionCount = 0;
        int n1 = mid - l + 1;
        int n2 = r - mid;
        int[] left = new int[n1];
        int[] right = new int [n2];
        
        for ( int i = 0 ; i < n1 ; i ++){
            left[i] = arr[l + i];
        }
        for ( int i = 0 ; i < n2 ; i ++){
            right[i] = arr[ mid + i + 1];
        }
        int i = 0, j = 0, k = l;
        while (i < left.length && j < right.length) {
            if (left[i] <= right[j])
                arr[k++] = left[i++];
            else {
                arr[k++] = right[j++];
                //swaps += (m + 1) - (l + i);
                //most important for inversion count
                inversionCount += n1 - i ;
            }
        }
        while (i < n1)
            arr[k++] = left[i++];
        while (j < n2)
            arr[k++] = right[j++];
        return inversionCount;
    }
  
    // Merge sort function
    private static long mergeSortAndCount(int[] arr, int l, int r)    {
        // Keeps track of the inversion count at a particular node of the recursion tree
        long inversionCount = 0;
        if (l < r) {
            int mid = (l + r) / 2;
            // Total inversion count = left subarray count + right subarray 
            // count + merge count Left subarray count / Right subarray count
            inversionCount += mergeSortAndCount(arr, l, mid);
            inversionCount += mergeSortAndCount(arr, mid + 1, r);
            inversionCount += mergeInversionCount(arr, l, mid, r);
        }
        return inversionCount;
    }
 
}


Sort by Absolute Difference
Given an array of N elements and a number K. The task is to arrange array elements according to the absolute difference with K, i. e., element having minimum difference comes first and so on.
Input:
3
5 7
10 5 3 9 2
5 6
1 2 3 4 5
4 5
2 6 8 3
Output:
5 9 10 3 2
5 4 3 2 1
6 3 2 8
Explanation:
Testcase 1: Sorting the numbers accoding to the absolute difference with 7, we have array elements as 5, 9, 10, 3, 2.
Testcase 2: Sorting the numbers according to the absolute difference with 6, we have array elements as 5 4 3 2 1.
Testcase 3: Sorting the numbers according to the absolute difference with 5, we have array elements as 6 3 2 8.
Explanation:
7 - 10 = 3(abs)
7 - 5 = 2
7 - 3 = 4 
7 - 9 = 2(abs)
7 - 2 = 5
So according to the difference with X, 
elements are arranged as 5, 9, 10, 3, 2.

class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in);
		int testCases = sc.nextInt();
	
		for(int tc = 0; tc < testCases; tc++){
			int sizeArr = sc.nextInt(),
			    diffK = sc.nextInt();
			int[] arr = new int[sizeArr];
			for(int i = 0; i < sizeArr; i++){
				arr[i] = sc.nextInt();
			}
            mergeSort(arr, 0, sizeArr - 1, diffK);
			//rearrange(arr,  arr.length, diffK);
            printArray(arr,  arr.length);
			System.out.println();
		}
	}
    // Function to print the array
    public static void printArray(int[] arr, int n) {
            for (int i = 0; i < n; i++)
                System.out.print(arr[i] + " ");
    }
    //Using mergessort
    public static void mergeSort(int arr[] , int start, int end, int k){
        //recursion breaking statement -> base case
        if(start < end){
            int mid = start + (end-start)/2; 
            mergeSort(arr, start, mid, k);
            mergeSort(arr, mid+1, end, k);
            
            merge(arr, start, mid, end, k);
            //arr[start - mid], arr[mid+1 , end]
        }
    }
    //Merge -> merge two sorted array
    public static void merge(int arr[], int start, int mid, int end, int l){
        //arr[start - mid], arr[mid+1 , end]
        int crr[] = new int[end-start+1];
        int i = start;
        int j = mid+1;
        int k = 0;
        
        // merging two sorted array.
        while(i <= mid && j<=end){
            if(Math.abs(l - arr[i]) <= Math.abs( l - arr[j])){
                crr[k++] = arr[i++];
            }
            else{
                crr[k++] = arr[j++];
            }
        }
        //remaining elements of 1 array.
        while(i<=mid){
            crr[k++] = arr[i++];
        }
        //remaining elements of 2 array.
        while(j<=end){
            crr[k++]=arr[j++];
        }
        //now we have sorted crr array. 
        //copy the crr array to arr. 
        int y = start;
        for(int z = 0;z < crr.length;z++){
            arr[y++] = crr[z];
        }
    }

    ///This is using Hashing 
	public static void rearrange(int[] arr, int n, int k)  {
            TreeMap<Integer, ArrayList<Integer>> m = new TreeMap<>();
            // Store values in a map with the difference with K as key
            
            for (int i = 0; i < n; i++) {
                int diff = Math.abs(k - arr[i]);
                if (m.containsKey(diff))  {
                    ArrayList<Integer> al = m.get(diff);
                    al.add(arr[i]);
                    m.put(diff, al);
                }
                else {
                    ArrayList<Integer> al = new ArrayList<>();
                        al.add(arr[i]);
                        m.put(diff,al);
                }
            }
            // Update the values of array
            int index = 0;
            for (Map.Entry entry : m.entrySet()) {
                ArrayList<Integer> al = m.get(entry.getKey());
                for (int i = 0; i < al.size(); i++)
                        arr[index++] = al.get(i);
            }
    }
}
Largest subarray with zero sum
Problem Statement
Given an array A[], of length N containing values in the range of negative to positive integers. You need to find the length of the largest subarray whose sum of elements is 0.
Sample Input:-
8
15 -2 2 -8 1 7 10 23
Sample Output:-5
Explanation:--2 2 -8 1 7 is the required subarray 

class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int sizeArr = sc.nextInt();
		int[] arr = new int[sizeArr];
		long sum = 0;
		for(int i=0; i < sizeArr; i++){
			arr[i]= sc.nextInt();
			sum += arr[i];
		}
		int ans = check(arr, 0);
		if(ans == 0){
			System.out.println("-1");
		}else{
			System.out.println(ans);
		}
	}

    public static int check(int[] arr, int k)    {
        // HashMap to store (sum, index) tuples
        HashMap<Integer, Integer> map = new HashMap<>();
        int sum = 0, maxLen = 0;
        // traverse the given array
        for (int i = 0; i < arr.length; i++) {
            // accumulate sum
            sum += arr[i];
            // when subarray starts from index '0'
            if (sum == k)
                maxLen = i + 1;
    // System.out.println("before  "+maxLen);
            // make an entry for 'sum' if it is not present in 'map'
            if (!map.containsKey(sum)) {
                map.put(sum, i);
            }
    //System.out.println(map);
            // check if 'sum-k' is present in 'map'  or not
            if (map.containsKey(sum - k)) { 
                // update maxLength
                if (maxLen < (i - map.get(sum - k)))
                    maxLen = i - map.get(sum - k);
                //   System.out.println(maxLen);
            }
        }
        return maxLen;            
    }
}


Group of Numbers You are given an array a that contains N integers. All the integers in the array may not be distinct. The number of repetitions of each integer in the array is represented by ri. Your task is to print the integers in the decreasing order of their occurrence in the array.
Note
1. If ri > rj, then ai must be printed before aj.
2. If ri == rj, then among ai and aj whichever has a larger value, is printed first.
Here ri and rj is the number of repetitions of integers ai and aj in the array.
Sample input: 6
1 2 3 3 2 1
Sample Output 3 2 1

class Main {
	public static void main (String[] args) {
    	Scanner sc = new Scanner(System.in);
		int sizeArr = sc.nextInt();

		Hashtable<Integer, Integer> ht = new Hashtable<>();
		int arrElements  = 0;
		int temp = 0;
		for(int i = 0; i < sizeArr; i++){
			arrElements = sc.nextInt();
			if(ht.containsKey(arrElements)){
				temp = ht.get(arrElements);
				ht.put(arrElements, (temp + 1));
				//System.out.println("if " + " ht- " + ht + " temp = " + arrElements);
			}else{
				ht.put(arrElements, 1);
				//System.out.println("else " + " ht- " + ht + " temp = " + arrElements);
			}
			//System.out.println(" ht- " + ht + " temp = " + arrElements + " free =" + free + " ");
		}
		 
		int maxElement = 0;
		for(int i: ht.values()){
			maxElement = (i > maxElement) ? i : maxElement;
		}
		//System.out.println("max "+maxElement);

		ArrayList<Integer> arrList = new ArrayList<Integer>();
		while(maxElement > 0){
			//Hashtable repeted occurance elemets adding into ArrayList
			for(int i: ht.keySet()){
				if(ht.get(i) == maxElement){
					arrList.add(i);
				}
			}
			//System.out.println(arrList);
			Collections.sort(arrList, Collections.reverseOrder());
			//System.out.println(arrList.size());
			for(int j = 0; j < arrList.size(); j++){
				System.out.print(arrList.get(j)+" ");
			}
			maxElement --;
			arrList.clear();
		}
	}
}


removing duplicates from lists
given a list say [a, b, b, b, c], remove duplicates and convert it to a list like [a, b, c], the user would enter any 5 characters which would form a part of the list.
print the list without any duplicates  hint - you might use sets for this. note- print the SORTED LIST
a
b
b
b
c
Output
['a', 'b', 'c']

WithoutSet
class Main {
	public static void main (String[] args) {
	
		Scanner sc = new Scanner(System.in);
		int[] arr = new int[26];
		int temp = 0;
		
		for(int i = 0; i < 5; i++){
			temp = (sc.next().charAt(0))- 97 ;
			arr[temp]++;
		}
		temp = 0;
		for(int i = 0; i < 26; i++){
			if(arr[i] > 0){
				temp++; 
				//System.out.print( arr[i]);
			} 
		}
		int[] bArr = new int[temp];
		temp = 0;
		for(int i = 0; i < 26; i++)	{
			if(arr[i] > 0){
				bArr[temp++] = i;
				//System.out.print( bArr[temp++]);
			}
		}
		System.out.print("['");
		for(int i = 0; i < bArr.length; i++){
			if(i == (bArr.length - 1)){
				System.out.print(((char)(bArr[i] + 97)) +"']");
			}
			else{
				System.out.print(((char)(bArr[i] + 97)) +"', '");
			}
		}
	}

}





Distinct alphabetsProblem Statement
Given a string. Find out the distinct alphabets and the number of times they occur.
Print 26 space separated numbers that denote the number of occurrences of each character from 'a' to 'z'.
Sample Input:- newton school
Sample Output:- 0 0 1 0 1 0 0 1 0 0 0 1 0 2 3 0 0 0 1 1 0 0 1 0 0 0
class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		String str = sc.nextLine();
		//char[] ch = str.toCharArray();
		//int letter = 0;
        HashMap<Character, Integer> hm = new HashMap<>();
		char tempChar =' ';

		for(int i = 0; i < str.length(); i++){
			tempChar = str.charAt(i);
			if(hm.containsKey(tempChar)){
				hm.put(tempChar, (hm.get(tempChar) + 1));
			}else{
				hm.put(tempChar, 1);
			}
		}
		//System.out.println(free);
        //Printing keys of distict alpha till 26 value with 0 and repeatation 
		for(int i = 0; i < 26; i++){
			tempChar = (char)(i + 97);
			if(hm.containsKey(tempChar)){
				System.out.print(hm.get(tempChar)+" ");
			}else{
				System.out.print( 0 +" ");
			}
		}
	}
}

Unique number of characters
Given a string s, your task is to find the total number of unique characters in a string.
Sample Input 1: newton School
Sample Output 1:  10

class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in);
		String str = sc.nextLine();
		System.out.print(countUniqueCharInString(str));
	}
	
	public static int countUniqueCharInString(String str){
		// Set to store unique characters in the given string
		HashSet<Character> s = new HashSet<Character>();
		for(int i = 0; i < str.length(); i++) {
			// Insert current character  into the set
			s.add(str.charAt(i));
		}
		return s.size();
	}
}

another solution
class Main {
	public static void main (String[] args) {
                      // Your code here
		Scanner sc= new Scanner(System.in);
		String s= sc.nextLine();
		int n= s.length();

		char temp =' ';
		int free=0;
		int count=0;

		Hashtable<Character, Integer> ht = new Hashtable<>();
		for(int i=0; i<n; i++){
			temp = s.charAt(i);
			if((!ht.containsKey(temp))){
				count++;
				ht.put(temp, 1);
			}
		}
		System.out.println(count);
	}
}
Check if array is sorted and rotated clockwise
Given an array arr[] of N distinct integers, check if this array is Sorted and Rotated clockwise.
A sorted array is not considered as sorted and rotated, i.e., there should be at least one rotation.
Note:-Array can be sorted both increasingly and decreasingly
Sample Input:
2
4
3 4 1 2
3
1 3 2
Sample Output: Yes Yes
Explanation:
Testcase 1: The array is sorted (1, 2, 3, 4) and rotated twice (3, 4, 1, 2).
Testcase 2: The array is sorted (3, 2, 1) and rotated once (1, 3, 2).

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int t = Integer.parseInt(br.readLine().trim()); //Inputting the testcases
		while(t-->0){
		    long n = Long.parseLong(br.readLine());
		    int arr[] = new int[(int)n];
		    String inputLine[] = br.readLine().trim().split("\\s+");
		    for(long i=0; i<n; i++){
		        arr[(int)i] = Integer.parseInt(inputLine[(int)i]);
		    }
		    
		    
		    
		    
		    long mini = Integer.MAX_VALUE, maxi = Integer.MIN_VALUE; 
        long max_index = 0, min_index = 0;
        for(long i=0; i<n; i++){
            if(maxi < arr[(int)i]){
                maxi = arr[(int)i];
                max_index = i;
            }
            if(mini > arr[(int)i]){
                mini = arr[(int)i];
                min_index = i;
            }
        }
        
        int flag = 0;
        if(max_index == min_index -1)
            flag = 1;
        else if(min_index == max_index - 1)
            flag = -1;
        
        if(flag == 1){
            for(long i = 1; flag==1 && i<=max_index; ++i){
                if(arr[(int)i-1] >= arr[(int)i])
                    flag = 0;
            }
            for(long i = min_index+1; flag==1 && i<n; ++i){
                if(arr[(int)i-1] >= arr[(int)i])
                    flag = 0;
            }
            if(arr[0]<=arr[(int)n-1])
                flag = 0;
        } else if(flag == -1){
            for(long i = 1; flag ==-1 && i<=min_index; ++i){
                if(arr[(int)i-1] <= arr[(int)i])
                    flag = 0;
            }
            for(long i = max_index+1; flag==-1 && i<n; ++i){
                if(arr[(int)i-1] <= arr[(int)i])
                    flag = 0;
            }
            if(arr[0]>=arr[(int)n-1])
                flag = 0;
        }
        
        if(flag == 0)
            System.out.println("No");
        else
            System.out.println("Yes");
		}
	}




Find Positions of X in array 
Given an integer array arr[] of size N and an element X. The task is to find and print the indices of the given element if it is present in array if not then print “Not found” without quotes. Note: The elements may be present more than once.
Input:
2
5 6
2 3 6 5 6
4 3
2 4 6 5
Output: 2 4 Not found

class Main {
	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
		int testCases = sc.nextInt(); 
		for(int tc = 0; tc < testCases; tc++){
			int sizeOfArr = sc.nextInt();
			int elementToSearch = sc.nextInt();
			int[] arr =new int[sizeOfArr];
			for(int i = 0; i < sizeOfArr; i++){
				arr[i] = sc.nextInt();
				//System.out.print(arr[i] + " ");
			}
			linearSearch(arr, elementToSearch);
			//System.out.println();
		}
	}

	public static void linearSearch(int arr[], int elementToSearch){
        boolean flag = true;
			for(int i=0; i<arr.length; i++)			{
				if(arr[i] == elementToSearch){
                    System.out.print(i + " ");
				    flag= false;
				}
			}
			if(flag){
				System.out.println("Not found");
			}
			else{
				System.out.println();
			}
    }

}


Count duplicates 
Given an array of N elements, your task is to find the count of repeated elements. Print the repeated elements in ascending order along with their frequency.
Have a look at the example for more understanding.
Sample Input:- 5
3 2 1 1 2
Sample Output:- 
1 2
2 2

class Main {
	public static void main (String[] args) {
        Scanner sc =new Scanner (System.in);
		int sizeArr = sc.nextInt();
		int arr[] = new int[sizeArr];
		for(int i = 0; i<arr.length;i++){
			arr[i] = sc.nextInt();
			//System.out.println(arr[i]);
		}
		

		HashMap<Integer,Integer> frequency = findDuplicateElement(arr);
    	// //System.out.println();
    	for (Map.Entry<Integer,Integer> entry : frequency.entrySet())
			if (entry.getValue() > 1)
				System.out.println(entry.getKey() +" " + entry.getValue());
	}

	public static HashMap<Integer,Integer> findDuplicateElement(int[] arr ){
		HashMap<Integer,Integer> freqOfElement = new HashMap<Integer,Integer>();
		
		// Loop to store the frequency of
		// elements of array
		for(int i = 0; i < arr.length; i++){
			if(freqOfElement.containsKey(arr[i])){
				freqOfElement.put(arr[i], freqOfElement.get(arr[i]) + 1);
			}
			else{
				freqOfElement.put(arr[i], 1);
			}
		}
		return freqOfElement;
	}
}

another solution 

class Main {
	public static void main (String[] args) {
                      // Your code here
		Scanner sc= new Scanner(System.in);
		int n= sc.nextInt();
		Hashtable<Integer, Integer> ht= new Hashtable<Integer, Integer>();

		int temp=0;
		int free=0;
		for(int i=0; i<n; i++){
			temp= sc.nextInt();
			if(ht.containsKey(temp)){
				ht.put(temp, (ht.get(temp)+1));
			}else{
				ht.put(temp, 1);
			}
		}
		//System.out.println(ht);

		ArrayList<Integer> a= new ArrayList<Integer>(ht.keySet());
		Collections.sort(a);

		for(int i: a){
			temp = ht.get(i);
			if(temp>1){
				System.out.println(i+" "+temp);
			}
		}

	}
}


Happy Number Write an algorithm to determine if a number n is happy. A happy number is a number defined by the following process:
    Starting with any positive integer, replace the number by the sum of the squares of its digits.
    Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.
    Those numbers for which this process ends in 1 are happy.  Return true if n is a happy number, and false if not.
Sample Input 19
Sample Output true
Explanation
12 + 92 = 82
8 2 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
https://www.geeksforgeeks.org/happy-number/?ref=lbp
class Main {

	

	public static int numSquareSum(int n){
		int squareSum = 0;
		while (n!= 0){
			squareSum += (n % 10) * (n % 10);
			n /= 10;
		}
		return squareSum;
	}
	
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int n = sc.nextInt();
			// if (isHappyNumber(n))
			// 	System.out.println(n + " True");
			// else
			// 	System.out.println(n + "false");
		LinkedList<Integer> l = new LinkedList<Integer>();
		l.add(n);
		boolean flag = true;
		int sum = 0;
		while( n > 1){
			sum = 0;
			while(n > 0){
				sum += ( n % 10) * ( n % 10);
				n = n / 10;
			}
			for(int j=0; j<l.size(); j++){
				if(sum == l.get(j))	{
					flag = false;
					break;
				}
			}
			if(flag == false){
				break;
			}
			n = sum;
			l.add(sum);
		}
		if(flag){
			System.out.println(flag);
		}
		else{
			System.out.println(flag);
		}
	}
}

Binary Searchable easy
Given an unsorted array of N integers, your task is to find all the elements which can be found through a traditional binary search. An element is binary searchable if it can be found for any value of pivot.
For eg:- Suppose the given array is [3, 2, 5, 4, 6, 7] and target = 6 we can find 6 because we will reach 6 at last. But for the target = 4, it will not be possible when the pivot is 5.
Input The first line of input contains a single integer N. The next line of input contains N space separated integers depicting the array.
Constraints:-
1 <= N <= 100000
1 <= Arr[i] <= 1000000
Output
Print the number of elements that can be found using the traditional binary search.
Example
Sample Input
3
3 2 1
Sample Output 0
Sample Input
6
3 2 5 4 6 7
Sample Output 2

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
   
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        System.out.println(binarySearchable1(arr));
    }
     static int binarySearchable1(int[] input) {
        int n = input.length;
        if (n == 0) {
            return 0;
        }
        
        int[] maxLeft = new int[n];
        int[] minRight = new int[n];
        
        int maxTillNow = Integer.MIN_VALUE;
        for (int i = 0; i < n; i++) {
            maxLeft[i] = maxTillNow;
            maxTillNow = Math.max(input[i], maxTillNow);
        }
        
        int minTillNow = Integer.MAX_VALUE;
        for (int i = n - 1; i >= 0; i--) {
            minRight[i] = minTillNow;
            minTillNow = Math.min(input[i], minTillNow);
        }
        
        int count = 0;
        for (int i =0 ; i < n; i++) {
            if (input[i] > maxLeft[i] && input[i] < minRight[i]) {
                count++;
            }
        }
        
        return count;
    }

    //static int binarySearchable(int[] Arr, int n) {
    //     if(n <= 1) return n;
    //     int[] leftmax = new int[n];
    //     int[] rightmin = new int[n];
    //     int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
    //     for(int i = 0; i < n; i++){
    //         min = Math.min(min, Arr[n-1-i]);
    //         rightmin[n-i-1] = min;
    //         max = Math.max(max, Arr[i]);
    //         leftmax[i] = max;
    //     }
    //     int count = 0;
    //     for(int i = 0; i < n; i++) {
    //         if(leftmax[i] <= Arr[i] && rightmin[i] >= Arr[i]) count++;
    //     }
    //     return count;
    // }
}




Smaller elements easy
Given a sorted array of N integers a[], and Q queries. For each query, you will be given a positive integer K and your task is to print the number of elements in array a[] that are smaller than or equal to K.
Input
In case of Java only
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function smallerElements() that takes te array a[], integer N and integer k as arguments.

Custom Input
The first line of input contains a single integer N.
The second line of input contains N space- separated integers depicting the values of the array.
The third line of input contains a single integer Q, the number of queries.
Each of the next Q lines of input contain a single integer, the value of K.

Constraints:-
1 <= N <= 105
1 <= K, Arr[i] <= 1012
1 <= Q <= 104
Output
Return the count of elements smaller than or equal to K.
Example
Sample Input:-
5
2 5 6 11 15
5
2
4
8
1
16
Sample Output:-
1
1
3
0
5

static int smallerElements(int a[], int n, int k){

        int count = 0;

        // for(int i = 0; i <  n ; i++){

        //         if(a[i] <= k)   count ++;

        // } 

        // return count;

        //int index = binarySearch(a, n, k);

    int left = 0;

    int right = n ;

    while (left < right) {

        int mid = left + (right - left) / 2;

        if (a[mid] <= k) {

            left = mid + 1;

            count  = mid + 1;

        } else {

            right = mid;

        }

    }

    // Return the number of elements that are smaller than or equal to K

    //return left - 1;

    return count; 

}

static int binarySearch(int arr[], int n, int k){

	int left = 0;

	int right = n - 1;

	

	while(left <= right){

		int mid = left + ((right - left ) / 2);

		if(arr [mid] == k){

			return mid;

		}else if(arr[mid] > k){

			right = mid - 1;

		}else{

			left = mid + 1;

		}

	}

	return -1;

}


Searching an element in a sorted array Given a sorted array arr[] of N integers and a number K is given. The task is to check if the element K is present in the array or not. Constraints:
1 <= T <= 10
1 <= N <= 100000
1 <= K <= 1000000000
1 <= arr[i] <= 1000000000
Sum of N over all test cases doesn't exceed 106 Note: Use binary search to solve the problem
Sample Input: 2
5 6
1 2 3 4 6
5 2
1 3 4 5 6
Sample Output:
1
-1

static int isPresent(long arr[], int n, long k){
	int start = 0;
	int end = n-1;
	while(start <= end ){
		int mid  = start + (end - start)/2;
		if( arr[mid] == k){
			return 1; // should return mid;
		}
		if(arr[mid] > k){
			end = mid - 1;
		}else{
			start = mid + 1;
		}
	}
	return -1;
}


Doraemon and big light(challenge)
Gian and Suneo want their heights to be equal so they asked Doraemon's help. Doraemon gave a big light to both of them but the both big lights have different speed of magnifying. Let's assume the big light given to Gian can increase height of a person by v1 m/s and that of Suneo's big light is v2 m/s.
At the end of each second Doraemon check if their heights are equal or not.
Given initial height of Gian and Suneo, your task is to check whether the height of Gian and Suneo will become equal at some point or not, assuming they both started at the same time. First line takes the input of integer h1(height of gian), h2(height of suneo), v1(speed of Gian's big light) and v2(speed of Suneo's big light) as parameter. Sample input:- 4 2 2 4
Sample output:-Yes  Explanation:- height of Gian goes as- 4 6 8 10. . height of Suneo goes as:- 2 6 10.. at the end of 1 second their height will become equal

static boolean EqualOrNot(int h1, int h2, int v1,int v2){
//1st way 
    // if(v1<v2) // {  //     if((h1-h2) % (v2-v1)==0)   //     {  //         return true; //     }
    //     else    //     {   //         return false;    //     }
    // }
    // return false;
//2nd Way
    return v1<v2 && (h1-h2) % (v2-v1)==0;


First non- repeating character in a String -
Given a string s, find the first non- repeating character in the string and return its index. If it does not exist, return -1.
https://www.geeksforgeeks.org/given-a-string-find-its-first-non-repeating-character/?ref=lbp
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
import java.util.Map.Entry;
// don't change the name of this class
// you can add inner classes if needed
class Main {
	public static void main (String[] args) {
        Scanner in = new Scanner (System.in);
        String s = in.nextLine();
        //char ch = firstNonRepeatedCharacter(s);
        //int result = firstNonRepeatedCharacter(s);
        //int result = firstNonRepeatedCharacter1(s);
        //System.out.println( result);
        int index = firstNonRepeating(s);
       // System.out.println( index);
        System.out.println(index == Integer.MAX_VALUE ? -1 : index);
	}

    static final int NO_OF_CHARS = 256;
    static HashMap<Character, CountIndex> hm  = new HashMap<Character, CountIndex>(NO_OF_CHARS);
    /* calculate count of characters in the passed string */
    public static void getCharCountArray(String str){
        for (int i = 0; i < str.length(); i++) {// If character already occurred,
            if (hm.containsKey(str.charAt(i))) { // updating count
                hm.get(str.charAt(i)).incCount();
            }
            // If it's first occurrence, then store the index and count = 1
            else {
                hm.put(str.charAt(i), new CountIndex(i));
            }
        }
    }
 
    /* The method returns index of first non-repeating character in a string. If all characters are repeating
       then returns -1 */
    public static int firstNonRepeating(String str) {
        getCharCountArray(str);
        int result = Integer.MAX_VALUE, i;
        for (Map.Entry<Character, CountIndex> entry : hm.entrySet()){
            int c = entry.getValue().count;
            int ind = entry.getValue().index;
            if(c == 1 && ind < result) {
                result=ind;
            }
        }
        return result;
    }
}

class CountIndex {
    int count, index;
    // constructor for first occurrence
    public CountIndex(int index) {
        this.count = 1;
        this.index = index;
    }
    // method for updating count
    public void incCount() {
        this.count++;
    }
}




Another approach  ---https://javahungry.blogspot.com/2013/12/first-non-repeated-character-in-string-java-program-code-example.html

public class FirstNonRepeatedCharSecond {
    
    public static void main(String[] args)
    {
        
        System.out.println(" Please enter the input string :" );
        Scanner in = new Scanner (System.in);
        String s = in.nextLine();
        char ch = firstNonRepeatedCharacter(s);
        System.out.println("The first non repeated character is :  " + ch);
    }
    
    public static Character firstNonRepeatedCharacter(String str)
    {
        HashMap<Character,Integer>  characterhashtable = 
                         new LinkedHashMap<Character ,Integer>();
        int length ;
        Character ch;
        length= str.length();  // Scan string and build hash table
        for (int i=0;i < length;i++)
        {
            ch = str.charAt(i);
            if(characterhashtable.containsKey(ch))
            {
                // increment count corresponding to ch
                characterhashtable.put(  ch ,  characterhashtable.get(ch) +1 );
            }
            else
            {
                characterhashtable.put( ch , 1 ) ;
            }
        }
        for(Entry<Character,Integer> entry: characterhashtable.entrySet())
        {
            if(entry.getValue() == 1)
                return entry.getKey();
        }
        return null;
    }
}    







EVM Machine Problem Statement
During the elections, Bob is in charge of conducting voting in his village, but the EVM system malfunctioned, and there was a long line of voters waiting outside to vote. The following is how the Advanced EVM Machine works.
Each time when a voter scans his VoterId Card and votes for the party of his choice, the Voter's id and Party Name are registered in the background, and if the same voter votes again, the EVM does not capture his vote, then the vote is skipped and the vote given the first time is used.
Now that you are Bob's best mate, you can't bear to see him in such a strained situation when outside voters are being very aggressive and screaming at him. Can you easily write a piece of code to save your friend's life while Bob is busy calming down the outside situation?
The number N (1 ≤ N ≤ 1e5) appears on the first line. The queries to the machine are included in the next n lines. Each request consists of two strings and is written on a non- empty line. The first string is an Voter Card Id, and the second string is the Party Name, all of which are atmost 32 characters long both upper case and lower case possible.Constraints
1 ≤ N ≤ 100000  1 ≤ Voter Id length ≤ 40  1 ≤ PartyName length ≤ 32
Sample Input 4
12678345 BJP
57891082 Congress
12678345 AAP
65489 TMC
Sample Output
BJP 1
Congress 1
TMC 1
Explanation : As Winning Parties here as BJP, Congress, TMC with 1 vote(s) each, but AAP vote is not considered because the same VoterId - 12678345 has done a vote again.


class Main {
	public static void main (String[] args) {
        Scanner sc= new Scanner(System.in);
        int n= sc.nextInt();
        // removing duplicate votes. 
		//4
		// 12678345 BJP
		// 57891082 Congress
		// 12678345 AAP
		// 65489 TMC
        HashMap<String, String> vote = new HashMap<>();
        String temp = sc.nextLine();
        // System.out.println(temp);
        while(n-->0){
            temp = sc.nextLine();
            String[] arr = temp.split(" ");
            //arr[0] voterId
            //arr[1] party
            // check if the voterId is already present or not. 
            if(!vote.containsKey(arr[0])){ //vote.get(temp) == null
                vote.put(arr[0], arr[1]);
            }
            
        }
        //duplicate code is removed. 
        // System.out.println(vote);
        
        
        //counting the votes
        HashMap<String, Integer> countVotes= new HashMap<>();
 
        Set<String> voterId = vote.keySet();
 
        Iterator<String> i = voterId.iterator();
        
        while(i.hasNext()){
            String id = i.next();   //voterId
            String party = vote.get(id);
            
            if(countVotes.get(party) == null){
                countVotes.put(party, 1);
            }
            else{
                int count = countVotes.get(party); //count
                countVotes.put(party, count+1);
            }
        }
        // respective parties and their votes.
        // BJP 1
        // TMC 1
        // System.out.println(countVotes);
 
        // --------------------------------------
 
        //max countVotes
        int max=0;
        int tmp =0;
        int maxtimes = 0; // how many times max occurs. 
        
        for(String z: countVotes.keySet()){
            tmp = countVotes.get(z);
            // max= (max>tmp)?max:tmp;//ternary operation
            if(max < tmp){
                max = tmp;
                maxtimes = 0;
            }
            else if(max == tmp){
                maxtimes++;
            }
        }
        //we know how many times the max votes is occuring. 
        String [] arr = new String[maxtimes+1];
        int y = 0;// arr index
        for(String z: countVotes.keySet()){
            tmp = countVotes.get(z);
            if(tmp == max){
                arr[y++] = z;
            }
        }
        
        //Sorted the String array
        Arrays.sort(arr);
 
        for(int j=0;j< arr.length;j++){
            System.out.println(arr[j] + " " + max);
        }
	}
}






Subarrays with equal 1s and 0s --Given an array arr[] of size N containing 0s and 1s only. The task is to count the subarrays having an equal number of 0s and 1s.
Sample Input  7 1 0 0 1 0 1 1
Sample Output 8
The index range for the 8 sub-arrays are:
(0, 1), (2, 3), (0, 3), (3, 4), (4, 5)
(2, 5), (0, 5), (1, 6)

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
	public static void main (String[] args) {
       	Scanner sc = new Scanner(System.in);
		int sizeOfArr = sc.nextInt();
		long[] arr =new long[sizeOfArr];
		for(int i = 0; i < sizeOfArr; i++){
			arr[i] = sc.nextLong();
			//System.out.print(arr[i] + " ");
		}
		System.out.println(countSubarrWithEqualZeroAndOne(arr));
	}


	public static long countSubarrWithEqualZeroAndOne(long[] arr)   {
        Map<Long, Long> myMap = new HashMap<>();
        long sum = 0;
        long count = 0;
        for (int i = 0; i < arr.length; i++) {
            // Replacing 0's in array with -1
            if (arr[i] == 0)
                arr[i] = -1;

            sum += arr[i];
            // If sum = 0, it implies number of 0's and 1'sare equal from arr[0]..arr[i]
            if (sum == 0){  count++; }
 
            if (myMap.containsKey(sum)) {count += myMap.get(sum);}
                
            if (!myMap.containsKey(sum)){
                myMap.put(sum, (long)1);
			}else{
                myMap.put(sum, myMap.get(sum) + 1);
			}
        }
        return count;
    }
}





Given a number N your task is to print its first two digits in reverse order. For eg:- If the given number is 123 then the output will be 21.

static int firstTwo(int N){
    int revNum = 0;
    while(N>0){
        revNum = revNum * 10 + N % 10;
        //System.out.println(revNum);
        N = N / 10; 
    }
    return revNum % 100;
}

Reverse digits of a number using recursion
public class ReverseNumberRecursion {
    public static void main(String[] args) {
        int number=0;
 System.out.println("Input an Integer");
 Scanner in = new Scanner(System.in);
 number = in.nextInt();
 System.out.print("Reversed Number : " + reverse(number));
    }
 
    public static int reverse(int number) {
        int lastDigit, numberOfDigits, sign = 1;
      
        if(number < 0){
            number = number * -1;
            sign = -1;
        }
        if(number < 10)
            return number*sign;
          
        lastDigit = number % 10;
        number = number / 10;
        /* log10(number) + 1 gives number of digits in number */
        numberOfDigits = (int) (Math.log10((double)number) + 1);
      
        return (int)(lastDigit*Math.pow((double)10,(doublumberOfDigits) 
         + reverse(number)) * sign;
    }
}

Camp Setup (Contest)
Given N points on 2D plane, you have to setup a camp at a point such that sum of Manhattan distance all the points from that point is minimum. If there are many such points you have to find the point with minimum X coordinate and if there are many points with same X coordinate, you have to minimize Y coordinate.
Manhattan distance between points (x1, y1) and (x2, y2) = |x1 - x2| + |y1 - y2|.
Constraints:
1 <= N <= 100000
1 <= X[i], Y[i] <= 1000000000
Note:- the camp can overlap with the given points and the given points can also overlap(you have to consider overlapping points separately).
Output
Print two space separated integers, denoting the X and Y coordinate of the camp.
Sample Input
3
3 3
1 1
3 2
Sample Output 3 2
Explanation: Sum of distances = 1 + 3 + 0 = 4
This is the minimum distance possible.
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int size = sc.nextInt();
        int arrX[] = new int[size];
        int arrY[] = new int[size];
        for (int i = 0; i < size; i++) {
            arrX[i] = sc.nextInt();
            arrY[i] = sc.nextInt();
        }
        Arrays.sort(arrX);
        Arrays.sort(arrY);
        System.out.print(findMinimumDistance(arrX, size) + " " + findMinimumDistance(arrY,size));	
	}
	static int findMinimumDistance(int arr[],int n){
        //finding the median  and minimum point
        int mIndex = (n % 2 == 0)? n/2 - 1 : (n-1) / 2;
        //System.out.print(arr[mIndex]);
        return arr[mIndex];
    }
}



Wave array Given an N size array of unique inyegers, your task is to print the array in a wave form, i. e a1 >= a2 <= a3 >= a4 <= a5.. . print the lexicographically smallest array possible.  https://www.geeksforgeeks.org/sort-array-wave-form-2/
Sample Input :- 5 2 1 3 5 4
Sample Output:-  2 1 4 3 5

class Main {

	public static void elementSwap(int arr[], int a, int b) {
        int temp = arr[a];
        arr[a] = arr[b];
        arr[b] = temp;
    }
    // arr[0] >= arr[1] <= arr[2] >= arr[3] <= arr[4]....
    // 1. Sort and then swap with indexing
	//2. in this example we do swaping with odd and even positions/index 
	//we check  If current element is smaller than previous odd element, swap previous and current. 
	//If current element is smaller than next odd element, swap next and current
	public static void sortingInWavePattern(int arr[], int n) {
        // Sort the input array
        Arrays.sort(arr);
        // Swap adjacent elements
		//in this example we do swaping with odd and even positions/index 
        for (int i = 0; i < n-1; i += 2)
            elementSwap(arr, i, i+1);

		/*for(int i = 0; i < n - 1; i += 2){
			 elementSwap(arr, i, i+1);
		}*/
    }
 
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in);
        int sizeArr = sc.nextInt();
		int[] arr = new int[sizeArr] ;
        for(int i = 0; i < sizeArr; i++){
			arr[i] = sc.nextInt();
			//System.out.print(arr[i]+ " ");
		}

        sortingInWavePattern(arr, arr.length);
        for (int i : arr)
            System.out.print(i +" ");
	}
}










Implementing Merge Sort Given an unsorted array, your task is to sort the array using merge sort.

public static int[] implementMergeSort(int arr[], int start, int end){
    if(start<end){
      int mid = start + (end - start)/2;

      implementMergeSort(arr, start, mid);
      implementMergeSort(arr, mid + 1 , end);

      implementMergeArray(arr, start, mid, end);
    }
    return arr;
}

public static void implementMergeArray(int[] arr, int start, int mid, int end){
    int[] tempArr = new int[end - start + 1];
    int i = start;
    int j = mid + 1;
    int k = 0;
    while(i <= mid && j <= end ){
        if(arr[i]<arr[j]){
          tempArr[k++] = arr[i++];
        }else{
          tempArr[k++] = arr[j++];
        }
    }

    while (i <= mid){
        tempArr[k++] = arr[i++];
    }

    while (j <= end){
        tempArr[k++] = arr[j++];
    }

    int tempStart = start;
    for(int l = 0; l < tempArr.length ; l++){
        arr[tempStart++] = tempArr[l];
    }
}




Dining Table
Sara has guests coming over to her house for dinner. She has a circular dining table of radius R and circular plates of radius r. Now she wonders if her table has enough space for all the guests, considering each guest takes one plate and the plate should lie completely inside the table.
Sample Input:-
4 10 4
Sample Output:-
Yes 
class Main {
	public static void main (String[] args) {
     	Scanner sc= new Scanner(System.in);
		int numOfGuest = sc.nextInt();
		int diningtableRadius = sc.nextInt();
		int radiusPlates = sc.nextInt();

		//System.out.println((Math.PI)/n);
		//System.out.println(Math.asin((double)r/(double)(R-r)));
		//System.out.println(n*(Math.asin((double)r/(double)(R-r))));
		double resultDT = (numOfGuest * (Math.asin((double)radiusPlates/
								(double)(diningtableRadius-radiusPlates))));
		//System.out.println(Math.PI + " "+ result);
		
		//if((Math.PI) >= (numOfGuest * (Math.asin((double)radiusPlates/(double)(diningtableRadius-radiusPlates))))){
		if((Math.PI) >= resultDT){
			System.out.println("Yes");
		}else{
			System.out.println("No");
		}
	}
}

Dining table another approach
class Main {
	public static void main (String[] args) {
      Scanner sc = new Scanner(System.in);
	  int n=sc.nextInt();
	  int R=sc.nextInt();
	   int r=sc.nextInt();

System.out.println(r>R || n>1&& (R-r)*sin(acos(-1.0)/n)+1e-8<r ?"No":"Yes");    
		
	}
}

Door problem
There is a door at Newton School which can be used only by one person at a time i. e either a person can enter from the door or exit but no two people can do it simultaneously. If two person going in the opposite direction arrived at the door at the same time then these 3 cases should be considered:-
1. If the door was not used before or it was not used in the previous second then the person who wants to exit goes first.
2. If the door has been used in the previous second for entering, then the person who wants to enter goes first.
3. If the door has been used in the previous second for exiting, then the person who wants to exist goes first.
If two people arrive at the same time and going in the same direction then the person whose name in the given list comes first will go first.
Note:- To cross the door, it will take exactly one second for each person.
Constraints:-
1 <= N <= 50000
0 <= Arrival[i] <= Arrival [i+1] <= 1000000000 Print N space- separated integers denoting the time at which the ith person will cross the door.
Sample Input:-
4
0 0 1 5
0 1 1 0
Sample Output:-
2 0 1 5
Explanation:-
At t = 0:- the first and the second person wants to enter and exit. As per case 1 2nd person will goes first.
At t=1:- the first and the 3rd person wants to enter and exit. As per case 3 the 3rd person goes first.
At t= 2:- only 1st is the only person standing so he goes.
At t = 3 and 4 no one wants to cross
At t = 5 the 4th person is the only one who wants to cross.
class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] time = new int[n];
        int[] direction = new int[n];
        List<Map<Integer, Integer>> entryList = new ArrayList();
        List<Map<Integer, Integer>> exitList = new ArrayList();
        for(int i=0; i<n; i++){
            time[i] = sc.nextInt();
        }
        for(int i=0; i<n; i++){
            direction[i] = sc.nextInt();
            Map<Integer, Integer> map = new HashMap();
            map.put(time[i], i);
            if(direction[i] == 0){
                entryList.add(map);
            }
            else{
                exitList.add(map);
            }
        }
        //System.out.println(entryList);
        //System.out.println(exitList);
        int[] res = new int[n];
        Arrays.fill(res, -1);
        int i=0, j=0, t=0, entryTime=0, exitTime=0;
        boolean prevExit = true;
        while(entryList.size() != i || exitList.size() != j){
            int s = 0, e = 0;
            if(entryList.size() == i){
                entryTime = Integer.MAX_VALUE;
            }
            else{
                for(Map.Entry<Integer, Integer> entry : entryList.get(i).entrySet()){
                    s = entry.getKey();
                }
                entryTime = s;
            }
            if(exitList.size() == j){
                exitTime = Integer.MAX_VALUE;
            }
            else{
                for(Map.Entry<Integer, Integer> entry : exitList.get(j).entrySet()){
                    e = entry.getKey();
                }
                exitTime = e;
            }
            if(entryTime < t) entryTime = t;
            if(exitTime < t) exitTime = t;
            if(entryTime == exitTime){
                if(entryTime == t){
                    if(prevExit){
                        res[exitList.get(j).get(e)] = exitTime;
                        j++;
                        t = exitTime + 1;
                    }
                    else{
                        res[entryList.get(i).get(s)] = entryTime;
                        i++;
                        t = entryTime + 1;
                    }
                }
                else{
                    res[exitList.get(j).get(e)] = exitTime;
                    j++;
                    t = exitTime + 1;
                    prevExit = true;
                }
            }
            else{
                if(entryTime < exitTime){
                    res[entryList.get(i).get(s)] = entryTime;
                    i++;
                    t = entryTime + 1;
                    prevExit = false;
                }
                else{
                    res[exitList.get(j).get(e)] = exitTime;
                    j++;
                    t = exitTime + 1;
                    prevExit = true;
                }
            }
        }
        for(int value : res)
            System.out.print(value + " ");
    }
}


Number of Merges .--You are given an unsorted array of length n and must sort it using merge sort while also printing the amount of merges that occur throughout the sorting process.
class Main {
    public static int count = 0;
	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); //size of array
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        
        mergeSort(arr, 0, arr.length-1);
        
        for(int i =0;i<arr.length;i++){
            System.out.print(arr[i] + " ");
        }
        System.out.print("\n" + count);
	}

    public static void mergeSort(int arr[] , int start, int end){
        //recursion breaking statement -> base case
        if(start<end){
            int mid = start + (end-start)/2;
            
            mergeSort(arr, start, mid);
            mergeSort(arr, mid+1, end);
            
            merge(arr, start, mid, end);
            //arr[start - mid], arr[mid+1 , end]
        }
    }
    //Merge -> merge two sorted array
    public static void merge(int arr[], int start, int mid, int end){
        //arr[start - mid], arr[mid+1 , end]
        //start = 3; end=5
        int crr[] = new int[end-start+1]; //5-3+1
        int i = start;
        int j = mid+1;
        int k = 0;
        
        // merging two sorted array.
        while(i <= mid && j <= end){
            if(arr[i] < arr[j]){
                crr[k++] = arr[i++];
            }
            else{
                crr[k++] = arr[j++];
            }
        }
        //remaining elements of 1 array.
        while(i<=mid){
            crr[k++] = arr[i++];
        }
        //remaining elements of 2 array.
        while(j<=end){
            crr[k++]=arr[j++];
        }
        //now we have sorted crr array. 
        //copy the crr array to arr. 
        int y = start;
        for(int z =0; z < crr.length;z++){
            arr[y++] = crr[z];
        }
        count++;
	}
}







Dalindrome Medium Problem Statement
Everyone has heard of palindromes, right! A palindrome is a string that remains the same if reversed.
Let's define a new term, Dalindrome.
A Dalindrome is a string whose atleast one of the substrings is a palindrome.
Given a string, find whether it's a Dalindrome.
Sample Input  cbabcc
Sample Output  Yes
Explanation: "bab" is one of the substrings of the string that is a palindrome. There may be other substrings that are palindrome as well like "cc", or "cbabc". The question requires atleast one.


class Main {
	
	public static boolean isPalindrome(String str) {
		int i = 0;
		int j = str.length() - 1;
		while(i <= j){
			char ch1 = str.charAt(i);
			char ch2 = str.charAt(j);
			if(ch1 != ch2){
				return false;
			}else{
				i++;
				j--;
			}
		} 
		return true;
	}
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in);
		String str = sc.next();
		String palidromeStr = "";
		for (int i = 0; i < str.length();i++ ) {
			for(int j = i + 1; j <= str.length();j++ ){
				palidromeStr = str.substring(i, j);	
				//System.out.println(str.substring(i, j+1));
			}
		}
		if (isPalindrome(palidromeStr) == true) {      
      				System.out.println("Yes");
				}else{
					System.out.println("No");
		}
	}
}

AND OR Operation You are given the following pseudocode:
code :
res = a
for i = 1 to k
if i is odd
res = res & b
else
res = res | b
You are also given the values of a, b and k. Find the value of res
<= T <= 1e5
1<= a, b, k <= 1e18
Sample Input : 1
4 5 1
Sample Output : 4

class Main {

	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int testCases = sc.nextInt();
		long a = 0, b = 0, k = 0;
		for(int tci = 0; tci <testCases; tci++){
			a = sc.nextLong();
			b = sc.nextLong();
			k = sc.nextLong();
			k = (k >= 2) ? 2 : k;
			for (int i = 1; i <= k; i++){
				if(i % 2 == 0 ){//i is odd(n % 2 == 0)
					a = (a | b);
					//res = res | b;
				}else{
					a = (a & b);
					//res = (res & b);
				}
			}
			System.out.println(a);
		}	
	
	}

}

Two Bits
Given an integer X find an integer Y such that Y has exactly two set bits in its binary representaion and abs(X- Y) is minimum.
Sample input 1
5

Sample output 1
0
Explanation: Y=5. 
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {

	/*public static void printTwoSetBitNums(long n) {
        // Initialize higher of two sets bits
        long x = 1;
        long numBits = 0; 
        // Keep reducing n for every number with two set bits
        while (n > 0) {
            // Consider all lower set bits forcurrent higher set bit
            long y = 0;
            while (y < x){  // If we have found n numbers
                //min = Math.abs(x-y);
                //System.out.println(y + " " + x);
                numBits = ((1l << x) + (1l << y) );
                n--;
                if (n == 0) return;
                y++;
            }
            x++;
            //System.out.print(Math.abs(n-y));
            System.out.println(numBits);
        }
        
          
    }*/
	public static void main (String[] args)throws IOException {
                      // Your code here
		BufferedReader sc= new BufferedReader(new InputStreamReader(System.in));
		long n= Long.parseLong(sc.readLine());
		// System.out.println(bits(n));
		if(check(n)){
			System.out.println("0");
			return;
		}
		if(n<=3){
			System.out.println(3-n);
			return;
		}
		if(n==4){
			System.out.println("1");
			return;
		}
		long[] a = big(n);
		// for(int i=0; i<3; i++){
		// 	System.out.print(a[i]+" ");
		// }
		a[0] +=1;
		int k=1; long temp=0;
		for(int i=1; i<a[2]; i++){
			temp = (long)Math.pow(2,k++);
			if(n>a[0] && n<(a[0]+temp)){
				a[1] = a[0]+temp;
				break;
			}else{
				a[0] = a[0]+temp;
			}
		}
		long x = Math.abs(a[0]-n);
		long y = Math.abs(a[1]-n);
		temp = (x<y)?x:y;
		System.out.println(temp);
	}
	public static long[] big(long n){
		long[] a = new long[3];
		a[0] = 3;
		a[1] = 5;
		int k= 2;
		while(true){
			if(n<a[1] && n>a[0]){
				return a;
			}else{
				a[2] = k-1;
				a[0] = a[1];
				a[1] += (long)Math.pow(2, k++);
			}
		}
	}
	/*static long bits(long n){
		long x=-10, y=0;
		boolean flag = false;
		//long[] a = new long[n];
		for(long i=1; i<(10*n); i++){
			flag =false;
			flag = check(i);
			// System.out.println(i+"   "+a[i]);
			if(flag){
				if((i<=n)){
					x= i;
				}
				if((i>n)){
					y= i;
					break;
				}
			}
		}
			if(x==n){
				return 0;
			}
			x = ((n-x)<(y-n))?(n-x):(y-n);
			return x;
	}*/

	static boolean check(long n){
		int count=0;
		while(n>0){
			n = n-(n&(-n));
			count++;
			if(count>2){
				return false;
			}
		}
		if(count==2){
			return true;
		}
		return false;
	}
}

/*public static long findNthNum(long N){
        // Initialize variables
        long a = 0, b, left;
        long right, mid;
        long t;
    
        // Initialize the range in which
        // the value of 'a' is present
        left = 1;
        right = N;
    
        // Perform Binary Search
        while (left <= right) {
    
            // Find the mid value
            mid = left + (right - left) / 2;
    
            t = (mid * (mid + 1)) / 2;
    
            // Update the range using the
            // mid value t
            if (t < N) {
                left = mid + 1;
            }
            else if (t == N) {
                a = mid;
                break;
            }
            else {
                a = mid;
                right = mid - 1;
            }
        }
        // Find b value using a and N
        t = a - 1;
        b = N - (t * (t + 1)) / 2 - 1;
        // Print the value 2^a + 2^b
        //System.out.print((1 << a) + (1 << b));
        long result = Math.abs(N - ((1 << a) + (1 << b)));
        return result;*/


Bit difference Problem Statement 
Given an array of N integers, your task is to calculate the sum of bit difference in all pairs which can be formed. Print the sum of bit difference of all possible pairs. Note:- Since the answer can be quite large print your answer modulo 109 + 7
Sample Input:-
2
1 3
Sample Output:-2
Explanation:-
(1, 1) = 0
(1, 3) = 1
(3, 1) = 1
(3, 3) = 0 


class Main {

	/*public static long sumOfBitDifferences(long arr[]){
        long result = 0; // Initialize result traverse over all bits
	
        for (int i = 0; i < 32; i++) { 
            long countBitOn = 0;
            for (long nums : arr){
                if ((nums & (1 << i)) != 0 ){
					countBitOn++;
				}
		   	}
			long countBitOff = arr.length - countBitOn;
			long bitDiff = (countBitOn * countBitOff * 2 );
            result += bitDiff;
        }
        return result ;
    }*/
	
	public static long mod = (long) 1e9+7;
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int arrSize = sc.nextInt();
		long[] bitDiff = new long[arrSize];
		for(int i = 0; i < bitDiff.length;i++){
			bitDiff[i] = sc.nextInt();
		} 
		//System.out.print(sumOfBitDifferences(bitDiff) );
		//System.out.println(solution(bitDiff));
		long result = 0;
		for(int i = 0; i < 64; i++){
			long count = 0; //how many ones in that column bit
			long bitshift = (1l << i); //000.....10
			for(int j = 0; j < arrSize; j++){
				if((bitDiff[j] & bitshift) == 0){
					count++; //counting number of 0's last bit + second last bit
				}
			}
			result += (count*(arrSize - count)*2);
			result %= mod;
		}
		System.out.println(result);
	}

}




https://gist.github.com/Ram-1234/beb5a1f6cbe190cafdac157753bd9320
Description:Array Rotation

Before Rotation
1 2 3 
4 5 6 
7 8 9 
after rotation
7 4 1 
8 5 2 
9 6 3 
class Ideone
{
	public static void main (String[] args) throws java.lang.Exception
	{
	  Scanner sc=new Scanner(System.in);
	  int s=sc.nextInt();
	  int [][] arr=new int[s][s];
	  for(int i=0;i<s;i++){
	  	for(int j=0;j<s;j++){
	  		arr[i][j]=sc.nextInt();
	  	}
	  }
	  
	  System.out.println("Before Rotation");
	  for(int i=0;i<s;i++){
	  	for(int j=0;j<s;j++){
	  		System.out.print(arr[i][j]+" ");
	  	}
	  	System.out.println("");
	  }
	  
	  System.out.println("after rotation");
	  for(int i=0;i<s;i++){
	  	for(int j=s-1;j>=0;j--){
	  		System.out.print(arr[j][i]+" ");
	  	}
	  	System.out.println("");
	  }
	  
	}
}





Test DSA Proctored TEst
BuildingsEasy
There are N buildings in a row with different heights H[i] (1 <= i <= N).
You are viewing the buildings from the left and you can see the roof of a building i if no building to the left of the ith building has a height greater than the ith building.
You are asked to find the number of buildings whose roofs you can see.
Sample input:
5
1 2 2 4 3
Sample output:
3
Explanation:-
the building at index 3 will hide before building at index 2 and building at index 5 will hide before building at index 4
class Main {
	public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
	   int numberOfBuilding = sc.nextInt();
	   int[] heightofBuldings = new int[numberOfBuilding];
	   for(int i = 0; i<numberOfBuilding;i++){
		   heightofBuldings[i] = sc.nextInt();
		   //System.out.println(heightofBuldings[i]); 
	   }

	   int countBuildings = 1;
	   int maxHeight = heightofBuldings[0];
	   for(int j = 1; j< numberOfBuilding; j++){
		   if(maxHeight < heightofBuldings[j]){
			   countBuildings++;
			   maxHeight = heightofBuldings[j];
		   }
	   }
	   System.out.println(countBuildings); 
	}
}

Problem Statement
Given an integer N print the last digit of the given integer.
Input
User Task:
Since this will be a functional problem, you don't have to take input. You just have to complete the function LastDigit() that takes integer N as argument. 
static int LastDigit(int N){
    int _lastDigit = N % 10;
    //System.out.println(_lastDigit);
    return _lastDigit;
}


The Dice Problem Easy
You are given a cubic dice with 6 faces. All the individual faces have a numbers printed on them. The numbers are in the range of 1 to 6, like any ordinary dice. You will be provided with a face of this cube, your task is to find the number on the opposite face of the cube.
class Main {
	public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
	   byte testCases = sc.nextByte();
	   for(byte i = 0 ; i<testCases;i++){
		   byte numberDice = sc.nextByte();
		   System.out.println( 7 - numberDice);
		   
		}  
	}
}


Door problem easy
There is a door at Newton School which can be used only by one person at a time i. e either a person can enter from the door or exit but no two people can do it simultaneously. If two person going in the opposite direction arrived at the door at the same time then these 3 cases should be considered:-
1. If the door was not used before or it was not used in the previous second then the person who wants to exit goes first.
2. If the door has been used in the previous second for entering, then the person who wants to enter goes first.
3. If the door has been used in the previous second for exiting, then the person who wants to exist goes first.

If two people arrive at the same time and going in the same direction then the person whose name in the given list comes first will go first.

Note:- To cross the door, it will take exactly one second for each person.
Input
The first line of input contains a single integer N containing the number of people The second line of input contains N space- separated integers depicting the arrival time of the ith person. The last line of input containing N space- separated integers which are either 0 or 1. 0 indicates that the person wants to enter and 1 indicates he wants to exit.
Constraints:-
1 <= N <= 50000
0 <= Arrival[i] <= Arrival [i+1] <= 1000000000
Output Print N space- separated integers denoting the time at which the ith person will cross the door.
Sample Input:-
4
0 0 1 5
0 1 1 0
Sample Output:-
2 0 1 5
Explanation:-
At t = 0:- the first and the second person wants to enter and exit. As per case 1 2nd person will goes first.
At t=1:- the first and the 3rd person wants to enter and exit. As per case 3 the 3rd person goes first.
At t= 2:- only 1st is the only person standing so he goes.
At t = 3 and 4 no one wants to cross
At t = 5 the 4th person is the only one who wants to cross.
Sample Input:-
5
0 1 1 3 3
0 1 0 0 1
Sample Output:-
0 2 1 4 3

import java.io.*; 
import java.util.*;

class Main {
    public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
        int n = sc.nextInt();
        int[] time = new int[n];
        int[] direction = new int[n];

        List<Map<Integer, Integer>> entryList = new ArrayList();
        List<Map<Integer,Integer>> exitList = new ArrayList();

        for(int i = 0; i < n; i++){
            time[i] = sc.nextInt();
        }

        for(int  i = 0; i < n ; i++){
            direction[i] = sc.nextInt();
            Map<Integer,Integer> map = new HashMap();

            map.put(time[i], i );
            if(direction[i] == 0){
                entryList.add(map);
            }else{
                exitList.add(map);
            }
        }

        int[] res = new int[n];
        Arrays.fill(res, -1);

        int i = 0 , j = 0, t = 0, entryTime = 0, exitTime =0;
        boolean prevExit = true;
        
        while(entryList.size() != i || exitList.size() != j){
            int s = 0, e = 0;

            if(entryList.size() == i){
                entryTime = Integer.MAX_VALUE;
            }else{
                for(Map.Entry<Integer, Integer> entry : entryList.get(i).entrySet()){
                    s =entry.getKey();
                }
                entryTime  = s;
            }

            if(exitList.size() == j ){
                exitTime = Integer.MAX_VALUE;
            }else{
                for(Map.Entry<Integer,Integer> entry : exitList.get(j).entrySet()){
                    e = entry.getKey();
                }
                exitTime = e;
            }

            if(entryTime < t) entryTime = t;
            if(exitTime < t) exitTime = t;

            if(entryTime == exitTime){
                if(entryTime == t){
                    if(prevExit){
                        res[exitList.get(j).get(e)] =exitTime;
                        j ++;
                        t = exitTime + 1;

                    }else{
                        res[entryList.get(i).get(s)] = entryTime;
                        i++;
                        t = entryTime + 1;
                    }
                }else{
                    res[exitList.get(j).get(e)] = exitTime;
                    j ++;
                    t = exitTime + 1;
                    prevExit = true;
                }
            }else{
                if(entryTime < exitTime){
                    res[entryList.get(i).get(s)] = entryTime;
                    i++;
                    t = entryTime + 1;
                    prevExit = false;
                }else{
                    res[exitList.get(j).get(e)] = exitTime;
                    j ++;
                    t = exitTime + 1;
                    prevExit = true;
                }
            }
        }
        for(int val : res){
            System.out.print(val + " ");
        }
    }
}



Quick Sort
class HelloWorld {
    
    public static int partition(int arr[], int start, int end){
        int pivotElement = arr[end]; //4 arr[9]
        
        int i = (start -1);//-1 //i is the index
        //i will identify the last element which is less than pivotElement
        
        // int arr[] = {1,3,2,5,8,7,6,11,10,4};
        for(int j = start; j<= end-1;j++ ){ //j is the index
        //j = 8            4
        //i = 3
            if(arr[j] < pivotElement){
                i++;
                int temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
        // int arr[] = {1,3,2,     5,8,7,6,11,10,4};
        
        i++;
        int temp = arr[i];
        arr[i] = arr[end];//pivot
        arr[end] = temp;
        // int arr[] = {1,3,2,     4,     8,7,6,11,10,5};
        return i;
        // 1 3 2   4  8 7 6 5 11 10 
    }
    public static void quickSort(int arr[], int start, int end){
        if(start<end){ //base case
            int pivot = partition(arr, start, end); // index of the right position of the taken pivot element
            quickSort(arr, start, pivot-1); //{1,3,2}
            quickSort(arr, pivot+1,end);// {8,7,6,11,10,5}
        }
    }
    public static void main(String[] args) {
        int arr[] = {8,7,6,5,1,3,2,11,10,4};
        
        quickSort(arr, 0, arr.length-1);
        
        for(int i=0;i<arr.length;i++){
            System.out.print(arr[i] + " ");
        }
    }
}





Insertion sort
class Main {
   public static void InsertionSort(int[] arr){
       for(int i=1;i<arr.length;i++){
           int temp = arr[i];
           int j = -1;
           for(j = i-1;j>=0;j--){
               // if(arr[j] < temp){ //decreasing
               if(arr[j] > temp){ //increasing
                   arr[j+1] = arr[j];
               }
               else{
                   break;
               }
           }
           arr[j+1] = temp;
       }
   }
   public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
       int t = sc.nextInt();
       while(t-- > 0){ // js t--
           int n = sc.nextInt();
           int arr[] = new int[n];
           for(int i = 0;i<n;i++){
               arr[i] = sc.nextInt();
           }
           InsertionSort(arr);
           for(int i = 0;i<n;i++){
               System.out.print(arr[i] + " ");
           }
           System.out.println();
       }
   }
}



Merge Sort
import java.util.*;
class HelloWorld {
    //find the mid and dividing the array.
    //Divide
    public static void mergeSort(int arr[] , int start, int end){
        //recursion breaking statement -> base case
        if(start<end){
            int mid = start + (end-start)/2;
            
            mergeSort(arr, start, mid);
            mergeSort(arr, mid+1, end);
            
            merge(arr, start, mid, end);
            //arr[start - mid], arr[mid+1 , end]
        }
    }
    //Merge -> merge two sorted array
    public static void merge(int arr[], int start, int mid, int end){
        //arr[start - mid], arr[mid+1 , end]
        //start = 3; end=5
        int crr[] = new int[end-start+1]; //5-3+1
        int i = start;
        int j = mid+1;
        int k = 0;
        
        // merging two sorted array.
        while(i<=mid && j<=end){
            if(arr[i] < arr[j]){
                crr[k++] = arr[i++];
            }
            else{
                crr[k++] = arr[j++];
            }
        }
        
        //remaining elements of 1 array.
        while(i<=mid){
            crr[k++] = arr[i++];
        }
        //remaining elements of 2 array.
        while(j<=end){
            crr[k++]=arr[j++];
        }
        //now we have sorted crr array. 
        //copy the crr array to arr. 
        int y = start;
        for(int z =0;z<crr.length;z++){
            arr[y++]=crr[z];
        }
    }
    public static void main(String[] args) {
        // int arr[] = {7, 9, 0 , -5,1};
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(); //size of array
        int arr[] = new int[n];
        for(int i=0;i<n;i++){
            arr[i] = sc.nextInt();
        }
        
        mergeSort(arr, 0, arr.length-1);
        
        for(int i =0;i<arr.length;i++){
            System.out.print(arr[i] + " ");
        }
    }
}


Sum Subarray
You are given an array Arr of N integers. A subarray is good if the sum of elements of that subarray is greater than or equal to K. Print the length of good subarray of minimum length.
Sample input
5 12
2 3 2 5 5
Sample output
3 Explanation :
Subarray from index 3 to 5 has sum 12 and is therefore good and its length(3) is minimum among all possible good subarray.


class Main {
   /* public static long findMinimumSubarrayLen(int[] A, long k){
        int subArrSum = 0; // stores the result
        long len = Long.MAX_VALUE;
        int left = 0; // stores the subarray starting index

        for (int right = 0; right < A.length; right++) {
            subArrSum += A[right];
            //System.out.println(subArrSum);
            while (subArrSum >= k && left <= right)  {
                //System.out.println(subArrSum + " " + right +" " +left);
                len = Long.min(len, right - left + 1);
                // remove elements from the subarray left side till the window becomes stable again
                subArrSum -= A[left];
                //System.out.println(subArrSum +" "+ A[left]);
                left++;
            }
        } 
        if (len == Integer.MAX_VALUE) { return 0; }
        // return result
        return len;
    }*/

    public static long smallestSubWithSum(int arr[], int n, long k){
        long curr_sum = 0;
        int min_len = n + 1; // Initialize current sum and minimum length
        int start = 0, end = 0;      // Initialize starting and ending indexes
        while (end < n) {
            // Keep adding array elements while current sum
            // is smaller than or equal to x
            while (curr_sum <= k && end < n)
                curr_sum += arr[end++];
            // If current sum becomes greater than x.
            while (curr_sum >= k && start < n) {
                // Update minimum length if needed
                if (end - start < min_len)
                    min_len = end - start;
                // remove starting elements
                curr_sum -= arr[start++];
            }
        }
        return min_len;
    }


	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int nElement = sc.nextInt();  
        long sumKEle = sc.nextLong(); 
        //int sumKEle = sc.nextInt();  
		int[] arr = new int[nElement];
		
		for(int i = 0; i < nElement; i++){
			arr[i] = sc.nextInt(); 
		}

        //long miniLength = findMinimumSubarrayLen(arr,sumKEle);
        long res1 = smallestSubWithSum(arr, nElement, sumKEle);
        //System.out.println(miniLength );
        System.out.println(res1 );
	}
}




Weird chapo! (Public Contest: Jan 2021)
Rick wants to give Morty a chapo (a super awesome treat :P).
The only condition for Morty to get a chapo is that he should be able to reach Rick's place. Both Rick and Morty live on the number line at integer points A and B respectively. There are N types of moves M1, M2,. , MN. Morty can only take steps of size Mi (1 <= i <= N) in either of the two directions on the number line (any number of times), while Rick prefers to stay at his place. Please let Morty know if he can ever reach Rick's place and get a chapo.
Sample Input
3 19 2
3 5 4
Saple Output
Yes
Explanation: Morty lives at position 2, while Rick lives at position 19. Morty can take the following path to reach Rick's place (there are several other ways as well):
Move M2 = 5 to the right.
Move M1 = 4 to the right.
Move M1 = 4 to the right.
Move M1 = 4 to the right. 


class Main {

	public static int gcd(int a,int b){
        if(b==0)
            return a;
        return gcd(b,a%b);
    }

	public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        int ricky=sc.nextInt();
        int morty=sc.nextInt();
        int a[]=new int[n];
        for(int i=0;i<n;i++){
            a[i]=sc.nextInt();
        }    
        int diff=Math.abs(ricky-morty);

        int hcf=a[0];
        for(int i=1;i<n;i++){
            hcf=gcd(hcf,a[i]);
        }
        
        if(diff%hcf==0){
            System.out.print("Yes");
        }else{
            System.out.print("No");
        }
	}
}


Geometry Exam
Sara has an exam of geometry in which the following question is asked:-
Given three points A, B, and C. Check if there exists a point and an angle such that if we rotate the page around the point by the angle, the new position of A is the same as the old position of B, and the new position of B is the same as the old position of C.
Input

class Main {

	public static void possibleOrNot(long a1,long a2,long b1,long b2,
                              long c1,long c2){
         
        // Calculating distance b/w points
        long dis1 = (long)Math.pow(b1 - a1, 2) +
                    (long) Math.pow(b2 - a2, 2);
                     
        long dis2 = (long)Math.pow(c1 - b1, 2) +
                     (long)Math.pow(c2 - b2, 2);
     
        // If distance is not equal
        if(dis1 != dis2)
            System.out.print("No");
             
        // If the points are in same line
        else if (b1 == ((a1 + c1) / 2.0) && b2 == ((a2 + c2) / 2.0))
            System.out.print("No");
        else
            System.out.print("Yes");
    }
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in);
		long a1 = sc.nextLong(),
			 a2 = sc.nextLong(), 
			 b1 = sc.nextLong(),
             b2 = sc.nextLong(), 
			 c1 = sc.nextLong(), 
			 c2 = sc.nextLong();
                 
        possibleOrNot(a1, a2, b1, b2, c1, c2);
	}
}

In C++
#include<iostream>
using namespace std;
int main(){
	long long a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f;
cout<<(
	a=a-c,
	b=b-d,
	c=c-e,
	d=d-f,
	a*a+b*b-c*c-d*d||!(a*d-b*c)?"No":"Yes")<<endl;
	return 0;
}


Too many rectangles? (Group Contest: April '21)
Why Geometry?? ?
You are given 4*N+1 distinct points on the cartesian plane. Out of these points, 4*N points represent the end points of N rectangles (with axis parallel to co-ordinate axis), while one point does not belong to any of the rectangles. Report the coordinates of the point that does not belong to any of the N rectangles.Output space separated X and Y coordinates of the extra point.
Samle Input
1
1 3
1 1
3 1
1 4
3 3
Sample Output
1 4 

class Main {
	public static void main (String[] args) {
		try(Scanner in = new Scanner(System.in)) {
	            int N = 4*in.nextInt() + 1;
		int[] A = new int[N];
		int[] B = new int[N];
	            for(int t = 0; t < N; t++) {
		A[t] = in.nextInt();
		B[t] = in.nextInt();				
	}
		int xA = 0, xB = 0;
		for (int i = 0; i < N; i++) {xA ^= A[i]; xB ^= B[i];
			}
		System.out.println(xA + " " + xB);
		}

	ANOTHER APPROCH kumarraveet52

	BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
           	 int n=Integer.parseInt(br.readLine());
			Set<Integer> x=new HashSet<Integer>();
			Set<Integer> y=new HashSet<Integer>();
			
			for(int i=0;i<4*n+1;i++) {
				StringTokenizer st=new StringTokenizer(br.readLine());
				int xc=Integer.parseInt(st.nextToken());
				int yc=Integer.parseInt(st.nextToken());
				if(x.contains(xc)) {
					x.remove(xc);
				}else {
					x.add(xc);
				}
				
				if(y.contains(yc)) {
					y.remove(yc);
				}else {
					y.add(yc);
				}
			}
			
			ArrayList<Integer> a=new ArrayList<>();
			a.addAll(x);
			ArrayList<Integer> b=new ArrayList<>();
			b.addAll(y);
			
			System.out.println(a.get(0)+" "+b.get(0));
	
	}
}



ABBA (Public Contest: December 2021)
You are given a string S of length N consisting of lowercase characters 'a' and 'b'. In one operation, you can select a character and make it equal to one of its adjacent characters. For example, if S = "aab", in one operation you can convert it to any of the following:
1. "aab": By changing the 1st character to the 2nd character.
2. "aab": By changing the 2nd character to the 1st character.
3. "abb": By changing the 2nd character to the 3rd character.
4. "aaa": By changing the 3rd character to the 2nd character.
Find the minimum number of operations to make all the characters in the string equal.

class Main {
	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
		int strLen = sc.nextInt();
		System.out.println(strLen);
		String str = sc.next();
		int countPosition = 0;
		for(int i = 0; i < str.length(); i++){
			if(str.charAt(i) =='a') {
				++countPosition;
			}
			System.out.println(countPosition);
		}
		if(countPosition > (strLen / 2)){
			System.out.print(strLen - countPosition);
		}else{ 
			System.out.print(countPosition);
		}
	}
}






Sorting Bubble Sort (descending order) Given an array, sort the array in reverse order by simply swapping its adjacent element
class Main {
	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
        int arrSize = sc.nextInt();
        int arr[] = new int[arrSize];
        for(int i = 0; i < arrSize;i++){
            arr[i] = sc.nextInt();
        }
        bubbleSort(arr);
        //System.out.println();
	}
    public static void bubbleSort(int[] arr){
		for(int i=0;i<arr.length-1;i++){ //1 ->n-1
            for(int j=1;j<arr.length - i;j++){
                // if(arr[j-1] < arr[j]){ //bubble descending
                if(arr[j-1] < arr[j]){ //ascending
                    //switch / swap it.
                    int temp = arr[j-1];
                    arr[j-1] = arr[j];
                    arr[j] = temp;
                }
            }
        }
        for(int i=0;i<arr.length;i++){
            System.out.print(arr[i] + " ");
        }
	}
}



Compress String:
Groot wants to send a message to Rocket. To make his message look interesting he thought he would compress his message. He decides to do so by replacing consecutive duplicate occurrences with the count of repetitions. Help Groot by writing a program to automatically convert his message.
We are given a string. Your task is to compress the consecutive letters of the string
For example: given string is "AAACCCBBD", thus here
A's occurrence 3 times
C's occurrence 3 times
B's occurrence 2 times
D's occurrence 1 time
So after compressing string becomes "A3C3B2D1".

class Main {

	public static void getCompressedString(String s) {
        for (int i = 0; i < s.length(); i++) {
            // Counting occurrences of s[i]
            int count = 1;
            while (i + 1 < s.length() && s.charAt(i) == s.charAt(i + 1)) {
                i++;
                count++;
            }
            System.out.print(s.charAt(i) + "" + count + "");
        }
        System.out.println();
    }
 
	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
		int testCases = sc.nextInt();
	
		for(int i = 0; i < testCases; i++){
			String str =  sc.next();
			//String[] strArray = null;  
			str = str.trim ();
			//System.out.println( i +" " +str);
			getCompressedString(str);

		}
	}
}



Sum(Large) Given two integers a and b your task is to print the summation of these two numbers
https://kalkicode.com/sum-two-string-numbers


class Main {

	public static void summationOfString(String str1, String str2){
		//Loop control variables Get the last location
		int positionA = str1.length() - 1;
		int positionB = str2.length() - 1;
		//Use to store the result
		String result = "";
		int index = 0;
		int num1 = 0;
		int num2 = 0;
		int carry = 0;
		//Execute loop to get both string number 
		while (positionA >= 0 || positionB >= 0 || carry > 0){
			num1 = 0;
			num2 = 0;
			if (positionA >= 0){
				num1 = str1.charAt(positionA) - '0';
			}
			if (positionB >= 0)	{
				num2 = str2.charAt(positionB) - '0';
			}
			//System.out.print(positionA + " " + positionB);
			carry = carry + num1 + num2;
			//add sum into the result 
			result = carry % 10 + result;
			carry /= 10;
			//get next location of both
			index++;
			//modified string text location/position
			positionA --;
			positionB --;
		}
		//System.out.print( str1 + "+" + str2 +" = " + result);
		System.out.print( result);
	}
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in);
		String x = sc.next();
		String y = sc.next();
		summationOfString(x,y);
		//System.out.println(sum);


	}
}

Generator - Super Prime For a given integer N, super primes are those integers from 1 to N whose multiples (other than themselves) do no exist in the range [1, N].
Your task is to generate all super primes <= N in sorted order.

Note: Super primes are not related to primes in any way.

def SuperPrimes(N):
  #Enter your code here
    for i in range (int(N/2)+1,N+1):
        yield (i);
    return();


Find the logic
Easy
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Find the logic of transformation that converts the following i/p to o/p and program it.

Abbreviation meaning:
i/p - Input
o/p - Output


i/p: But, why?
o/p: But,? yhw

i/p: My Rhythms fly
o/p: My smhtyhR fly

i/p: Hi, my name is ted. I am fine
o/p: Hi, ym name si ted. I am enif

i/p: peace out
o/p: peace tuo
Sample Input:-
newton school

Sample Output:-
newton loohcs 

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
	
	public static void main (String[] args) {
        // Scanner sc = new Scanner (System.in);
		// String str = sc.nextLine();
		// //System.out.println(str.length());

		// String[] toRevString = str.split(" ");
		// if(toRevString.length == 1){ 
		// 	return;
		// 	//System.out.println("length 2");
		// }
		// //System.out.println(toRevString.length);
		// for (int i = 1; i < toRevString.length; i += 2){
		// 	//System.out.println(i + " " + new StringBuilder(toRevString[i]).reverse().toString());
		// 	//System.out.println(toRevString[i]);
		// 	toRevString[i] = new StringBuilder(toRevString[i]).reverse().toString();
		// }	
		// System.out.println(String.join(" ", toRevString));

		/*StringBuilder result = new StringBuilder();
    	for( int i = 0; i < toRevString.length; i += 1 ){
			if( i % 2 != 0 ) {
				char[] word = toRevString[i].toCharArray();
				String reverseWord = "";
				for( int k = word.length; k > 0; k-- ) {
					reverseWord += String.valueOf( word[k-1] );
				}
				result.append( reverseWord ).append( " " );
			}
			else{
				result.append( toRevString[i] ).append( " " );
			}
   		}
    	System.out.println( result.toString() );*/

		Scanner sc = new Scanner(System.in);
		String s= sc.next();
		int i=1;
		boolean flag= true;
		while(flag){
			if(i%2 == 0){
				System.out.print(rever(s)+" ");
			}else{
				System.out.print(s+" ");
			}
			i++;
			try{
				s= sc.next();
			}
			catch(Exception e){
				flag = false;
			}
		}
	}

	public static String rever(String s){
		StringBuilder sb = new StringBuilder(s);
		int i=0;
		int j = s.length()-1;
		char a=' ', b=' ';
		while(i<=j){
			a = sb.charAt(i);
			b= sb.charAt(j);
			sb.setCharAt(i++, b);
			sb.setCharAt(j--, a);
		}
		return sb.toString();
	}
}



FLAMES ?They say friendship is greater than love. Why not play the famous game "FLAMES".
The rules are super simple. Given two strings (all lowercase), remove all the letters that are common to both the strings from both the strings. You cannot erase two characters corresponding to one character.
For example, in the case
String 1: saumya
String 2: ansh
You can remove only 1 'a' and 1 's' from both the strings.
Remaining strings are:
String 1: umya
String 2: nh

Now all you need to do is find the sum of the remaining strings length % 6.

Output:
If obtained value is 1, output "Friends"
If obtained value is 2, output "Love"
If obtained value is 3, output "Affection"
If obtained value is 4, output "Marriage"
If obtained value is 5, output "Enemy"
If obtained value is 0, output "Siblings"


class Main {
	public static void main (String[] args) {
       Scanner sc=new Scanner(System.in);
       String str1 = sc.nextLine(); //100000 str1.length()
       String str2 = sc.nextLine();
       // System.out.println(str1);
       // System.out.println(str2);
       int arr[] = new int[26];
       //All Strings are from 1st array.
	   for(int i = 0; i < str1.length();i++){
           //character is str1.charAt(i); // 97 -> 97+25
           // System.out.println(str1.charAt(i)); //a,b
           // int x = str1.charAt(i);
           // System.out.println(str1.charAt(i));
           arr[str1.charAt(i) - 97]++;
       }
	   //All Strings are from 1st array.
       for(int i =0;i<str2.length();i++){
           //character is str1.charAt(i); // 97 -> 97+25
           arr[str2.charAt(i) - 97]--;
       }
       //All +ve numbers are from 1st array.
       //All -ve numbers are form 2nd array.
       // for(int i=0;i<26;i++){
       //  System.out.print(arr[i]+" ");
       // }
       int count = 0;
       for(int i=0;i<26;i++){
           if(arr[i]< 0){
               count -= arr[i];
           }
           else{
               count +=arr[i];
           }
       }
       // System.out.println(count);
       count %= 6;
       switch(count){
           case 0: System.out.println("Siblings");
           break;
           case 1: System.out.println("Friends");
           break;
           case 2: System.out.println("Love");
           break;
           case 3: System.out.println("Affection");
           break;
           case 4: System.out.println("Marriage");
           break;
           case 5: System.out.println("Enemy");
           break;
       }

	}
}


You are given a string your task is to reverse the given string.

class Main {
	public static String reverseString(String str){
		String revString = "";
		for(int i = 0; i<str.length();i++){
			revString = str.charAt(i) + revString;
		} 
		return revString;
	}
	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
		String s = sc.nextLine();
		System.out.println(reverseString(s));

		
	}
}


Special Number (contest Given a number N, find out whether it is divisible by 3.

class Main {
	public static boolean checkDivisible(String str){
        int digitSum = 0;
		//System.out.println(str.length());
        for (int i = 0; i < str.length(); i++){
			digitSum = digitSum + str.charAt(i);
			//System.out.print(str.charAt(i)-'0' + " ");
			//System.out.print(str.charAt(i)+" " );
			System.out.println( " i =" + i + " digitSum = " +digitSum );
		}
        // Checking if sum of digits is divisible by 3.
        return (digitSum % 3 == 0);
    }
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.nextLine();
		//System.out.println(checkDivisible(s));
		if(checkDivisible(s)){
			System.out.println("Yes");
		}else{
			System.out.println("No");
		}

	}
}




Divisibility Test You are given a big number in form of a string A of characters from 0 to 9. Return 1 if it's divisible by 30 and 0 otherwise.

class Main {
	
	public static void isDivisibleBy30(String str)	{
		// A number is divisible by 30 when satisfies two conditions.
		boolean result = false;
		int n = str.length();
		if (n == 1 && str.charAt(0) == '0')	{
			// When number is zero
			result = true;
		}
		else if (n > 1)	{
			// Check condition 1
			if (str.charAt(n - 1) == '0'){
				// When number is divisible by 10
				// 2nd condition check number is divisible by 3 or not
				int digitSum = 0;
				// Calculate sum of all digit
				for (int i = 0; i < n; ++i)	{
					digitSum += (str.charAt(i) - 48);
				}
				if (digitSum % 3 == 0){
					// When number is divisible by 3
					result = true;
				}
			}
		}
		if (result == true){
			System.out.println("Yes");
		}
		else{
			System.out.println("No");
		}
	}
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in);
		String str = sc.nextLine();
		isDivisibleBy30(str);
	}
}




Odd characters Given a string(1-indexed). Print all the characters of the string at odd positions. i/p abcde o/p  a c e 
class Main {
	public static void main (String[] args) {
    	Scanner sc = new Scanner (System.in);
		String str = sc.nextLine();
		//String[] strArr = new Str 

		for (int i = 0; i < str.length(); i = i+2) {   
			System.out.print(str.charAt(i) + " ");   
		}   
	}
}

D Triplets two pointer approach 
https://www.geeksforgeeks.org/triplets-array-absolute-difference-less-k/
Given an array Arr[] of size N, your task is to count the number of triplets Arr[i], Arr[j] and Arr[k] such that:-
i < j < k and the difference between every 2 elements of triplets is less than or equal to P i. e |Arr[i] - Arr[j]| <= P, |Arr[i] - Arr[k]| <= P and |Arr[j] - Arr[k]| <= P

pending problem



Print Squared Sorted Array Easy
Given an sorted array Arr[] of size N, containing both negative and positive integers, you need to print the squared sorted output.
Note Try using two pointer approach

class Main {
	 public static void sortSquares(int[] arrSquares){
        int n = arrSquares.length;
        // First convert each array elements into its square
        for (int i = 0; i < n; i++)
            arrSquares[i] = arrSquares[i] * arrSquares[i];
        // Sort an array using "inbuild sort function" in Arrays class.
        Arrays.sort(arrSquares);
    }

	public static void sortSquares1(int arr[]){
		int n = arr.length, leftptr = 0, rightptr = n - 1;
		int result[] = new int[n];

		for(int index = n - 1; index >= 0; index--){
			if (Math.abs(arr[leftptr]) > arr[rightptr]){
				result[index] = arr[leftptr] * arr[leftptr];
				leftptr++;
			}else{
				result[index] = arr[rightptr] * arr[rightptr];
				rightptr--;
			}
		}
		for(int i = 0; i < n; i++)
			arr[i] = result[i];
	}		

	public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
		int testCases = sc.nextInt();
		int sizeArr = 0;
		
		for(int i = 0; i < testCases;i++){
			sizeArr = sc.nextInt();
			int[] arr = new int[sizeArr];
			for(int j = 0; j < sizeArr; j++){
				arr[j] = sc.nextInt();
				//System.out.print(arr[i] + " ");
			}
	
			sortSquares1(arr);
			for(int k = 0; k < sizeArr; k++)
				System.out.print(arr[k] + " ");

			System.out.println();
			
		}
	}
}

another one approch

public static void main (String[] args) {
                      // Your code here
		Scanner sc= new Scanner(System.in);
		int t= sc.nextInt();
		int n=0;
		int temp=0;
		while(t-- >0){
			n= sc.nextInt();
			int[] a= new int[n];
			for(int i=0; i<n; i++){
				temp= sc.nextInt();
				a[i]= temp*temp;
			}
			for(int i=0; i<n-1; i++){
				for(int j=i+1; j<n; j++){
					if(a[i]>a[j]){
						temp= a[i];
						a[i]= a[j];
						a[j]= temp;
			}
		}
	}
	for(int i=0; i<n; i++){
		System.out.print(a[i]+" ");
	}
	System.out.println();
}
		
Print Squared Sorted Array Given an sorted array Arr[] of size N, containing both negative and positive integers, you need to print the squared sorted output.

class Main {
	 public static void sortSquares(int[] arrSquares){
        int n = arrSquares.length;
        // First convert each array elements into its square
        for (int i = 0; i < n; i++)
            arrSquares[i] = arrSquares[i] * arrSquares[i];
        // Sort an array using "inbuild sort function" in Arrays class.
        Arrays.sort(arrSquares);
    }

	public static void sortSquares1(int arr[]){
		int n = arr.length, leftptr = 0, rightptr = n - 1;
		int result[] = new int[n];

		for(int index = n - 1; index >= 0; index--){
			if (Math.abs(arr[leftptr]) > arr[rightptr]){
				result[index] = arr[leftptr] * arr[leftptr];
				leftptr++;
			}else{
				result[index] = arr[rightptr] * arr[rightptr];
				rightptr--;
			}
		}
		for(int i = 0; i < n; i++)
			arr[i] = result[i];
	}		

	public static void main (String[] args) {
        Scanner sc = new Scanner (System.in);
		int testCases = sc.nextInt();
		int sizeArr = 0;
		
		for(int i = 0; i < testCases;i++){
			sizeArr = sc.nextInt();
			int[] arr = new int[sizeArr];
			for(int j = 0; j < sizeArr; j++){
				arr[j] = sc.nextInt();
				//System.out.print(arr[i] + " ");
			}
	
			sortSquares1(arr);
			for(int k = 0; k < sizeArr; k++)
				System.out.print(arr[k] + " ");

			System.out.println();
			
		}
	}
}



Longest Distinct characters in string Problem Statement
Given a string S, you have to find the length of the longest substring of S containing all unique characters, i.e, no character is repeating within that substring.
For example, for input string S = "abca", the output is 3 as "abc" is the longest substring with all distinct characters.

class Main {
	public static int longestDistinctCharacters(String str){
        String resultStr = "";
        // Result
        int maxLength = -1;
        if (str.isEmpty()) { return 0; }
        else if (str.length() == 1) { return 1; }
        
		for (char c : str.toCharArray()) {
            String current = String.valueOf(c);
 			//System.out.print(current + " ");
    // If string already contains the character Then substring after repeating character
	//indexof resturn the positon of occurance of character
            if (resultStr.contains(current)) {
                resultStr = resultStr.substring(resultStr.indexOf(current) + 1);
				//System.out.println(resultStr +  " "  + c);
            }
			//System.out.println(resultStr +  " "  );
			//valueOf method converts different types of values into string.
            resultStr = resultStr + String.valueOf(c);
			//System.out.println(resultStr +  " "  + String.valueOf(c));
            maxLength = Math.max(resultStr.length(), maxLength);
        }
        return maxLength;
    }

	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
		int testCases = sc.nextInt(); 
		String[] strArr = new String[testCases];
		int longestChar = 0 ;
		for(int i = 0; i < testCases; i++){
			strArr[i] = sc.next(); 
			//System.out.println(strArr[i] );
			longestChar = longestDistinctCharacters(strArr[i]);
			System.out.println(longestChar);
		}

	}
}


 Check Permutation For a given two strings, 'str1' and 'str2', check whether they are a permutation of each other or not.

import java.util.*;
public class Solution {
public static boolean isPermutation(String str1, String str2) {

        // Get lengths of both strings
        int n1 = str1.length();
        int n2 = str2.length();

        // If length of both strings is not same, then they cannot be Permutation
        if (n1 != n2){ return false; }
            
        char ch1[] = str1.toCharArray();
        char ch2[] = str2.toCharArray();

        // Sort both strings
        Arrays.sort(ch1);
        Arrays.sort(ch2);

        // Compare sorted strings
        for (int i = 0; i < n1; i++){
            if (ch1[i] != ch2[i])
                return false;
        }
        return true;
	}
}

Another Approch 2
public static String compress(String inputString) {
		String str="";
        int count=1;
        str+=inputString.charAt(0);
        int i=1;
        for(;i<inputString.length();i++){
        if(inputString.charAt(i)==inputString.charAt(i-1)){
          count++;
        } 
        else{
            if(count>1){
            str=str+count+inputString.charAt(i);
            count=1;}
            else{
                str=str+inputString.charAt(i);
            	count=1;
            }
        }        
    } 
        if(count>1){
        str+=count;
        }
    return str;
  }

Approach 3 important 
public static String arrangeString(String inputString) {
        int i,j;
		String str = "";
		    j = 97;
			while(j <= 122) {
			i = 0;
			do {
				if((int)inputString.charAt(i) == j) {
					str = str + (char)j;
				}
				i++;
			}while(i < inputString.length());
			j++;
		}
			return str;
		
}
	public static boolean isPermutation(String input1, String input2) {
	    // Write your code here
boolean result = true;;
		if(input1.length() != input2.length())
		  result = false;
		else {
			String str1 = arrangeString(input1);
			String str2 = arrangeString(input2);
			for(int i = 0;i < str1.length();i++) {
				if(str1.charAt(i) != str2.charAt(i)) {
					result = false;
					break;
				}
			}
		}
			return result;
	}





Bit count --Negi is fascinated with the binary representation of the number. Tell him the number of set bits (ones) in the binary representation of an integer N.

class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in);
		long num = sc.nextLong();
		//System.out.println(Long.bitCount(num));
	
		System.out.println(countSetBits(num));
	}
	public static long countSetBits(long n){
        int count = 0;
        while (n > 0) {
            n &= (n - 1);
            count++;
        }
        return count;
    }
	public static long countSetBitsRecur(long n){
        // base case
        if (n == 0)
            return 0;
        else
            //return (n & 1) + countSetBits(n >> 1);
			return 1 + countSetBits(n & (n - 1));
    }
}




Triangles loveEasy
Problem Statement
Sara loves triangles. Whenever she sees three points she connects them by straight lines to form a triangle. In triangles, her favorite one is a right-angled triangle. If the triangle is not right-angled but it can be converted into one by moving one of the points exactly by distance 1 so, that all the coordinates remain integer, she calls such triangles "Special".
Given three points A, B, and C your task is to check if the formed triangle is "Right", "Special" or "Simple".
Input
The first line of input contains the position of A(Ax, Ay). The second line of input contains the position of B(Bx, By). The third line of input contains the position of C(Cx, Cy).Constraints:-|X|, |Y| <= 10^9
Output
Print "Right" if the triangle is right- angled, print "Special" if the triangle can be formed into a right- angled by moving one of the points exactly by distance 1, else print "Simple".

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {

// Storing all the possible changes to make the triangle right-angled
	static int dx[] = { -1, 0, 1, 0 };
	static int dy[] = { 0, 1, 0, -1 };
// Function to check if the triangle is right-angled or not
	public static boolean checkRightAngle(int x1, int y1, int x2, int y2,
                       int x3, int y3){
		//int a = ((x1 - x2) * (x1 - x2)) + ((y1 - y2) * (y1 - y2));
		int a = (int)Math.pow((x2 - x1), 2) + (int)Math.pow((y2 - y1), 2);
		
		//int b = ((x1 - x3) * (x1 - x3)) + ((y1 - y3) * (y1 - y3));
		int b = (int)Math.pow((x3 - x2), 2) + (int)Math.pow((y3 - y2), 2);

		//int c = ((x2 - x3) * (x2 - x3)) + ((y2 - y3) * (y2 - y3));
	 	int c = (int)Math.pow((x3 - x1), 2) + (int)Math.pow((y3 - y1), 2);

		if ((a == (b + c) && a != 0 && b != 0 && c != 0) ||
			(b == (a + c) && a != 0 && b != 0 && c != 0) ||
			(c == (a + b) && a != 0 && b != 0 && c != 0)){
			return true;
		}
    	return false;
	}
// Function to check if the triangle can be transformed to right-angled
	public static void checkForValidCombination(int x1, int y1,
                               int x2, int y2,
                               int x3, int y3){
    	int x, y;
	// If it is already right-angled
    // Boolean variable to return true or false
		boolean possible = false;
	
		if (checkRightAngle(x1, y1, x2, y2, x3, y3)){
			//System.out.print("ALREADY RIGHT ANGLED");
			System.out.print("Right");
			return;
		}
		else {
			// Applying the changes on the co-ordinates
			for (int i = 0; i < 4; i++){
				// Applying on the first co-ordinate
				x = dx[i] + x1;
				y = dy[i] + y1;
	
				if (checkRightAngle(x, y, x2, y2, x3, y3)){
					System.out.print("Special");
					return;
				}
				// Applying on the secondco-ordinate
				x = dx[i] + x2;
				y = dy[i] + y2;
	
				if (checkRightAngle(x1, y1, x, y, x3, y3)){
					System.out.print("Special");
					return;
				}
				// Applying on the third// co-ordinate
				x = dx[i] + x3;
				y = dy[i] + y3;
	
				if (checkRightAngle(x1, y1, x2, y2, x, y))
				{
					System.out.print("Special");
					return;
				}
			}
		}
    	// If can't be transformed
		if (!possible)
			//System.out.println("NOT POSSIBLE");
			System.out.println("Simple");
	}
	public static void main (String[] args) {
        Scanner sc=new Scanner(System.in);
		int x1 = sc.nextInt(), y1 = sc.nextInt();
    	int x2 = sc.nextInt(), y2 = sc.nextInt();
    	int x3 = sc.nextInt(), y3 = sc.nextInt();

		checkForValidCombination(x1, y1, x2, y2, x3, y3);
	}
}


Given an array of N elements. In the array, each element is present twice except for 1 element whose frequency in the array is 1. Hence the length of the array will always be odd.
Find the unique number.

class Main {

	static int findUniqueElement(int arr[], int arr_Size)
    {
        // Do XOR of all elements and return
        int res = arr[0];
        for (int i = 1; i < arr_Size; i++)
            res = res ^ arr[i];
     
        return res;
    }
	public static void main (String[] args) {
                      // Your code here
		Scanner sc = new Scanner(System.in);
		int arrSize = sc.nextInt();
		int[] arrEle = new int[arrSize];
		for (int i = 0; i < arrSize; i++){
			arrEle[i] = sc.nextInt();
		}
		  System.out.println(findUniqueElement(arrEle,arrSize));
	}

Special Number (contest)
Problem Statement
Given a number N, find out whether it is divisible by 3.
here compiler will take numbers ascii value then check divisible

class Main {
	public static boolean checkDivisible(String str){
        int digitSum = 0;
		//System.out.println(str.length());
        for (int i = 0; i < str.length(); i++){
			digitSum = digitSum + str.charAt(i);
			//System.out.print(str.charAt(i)-'0' + " ");
			//System.out.print(str.charAt(i)+" " );
			//System.out.println( " i =" + i + " digitSum = " +digitSum );
		}
        // Checking if sum of digits is divisible by 3.
        return (digitSum % 3 == 0);
    }
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		String s = sc.nextLine();
		//System.out.println(checkDivisible(s));
		if(checkDivisible(s)){
			System.out.println("Yes");
		}else{
			System.out.println("No");
		}

	}
}


Problem Statement

You are given a string your task is to reverse the given string.

class Main {
	public static String reverseString(String str){
		String revString = "";
		for(int i = 0; i<str.length();i++){
			revString = str.charAt(i) + revString;
		} 
		return revString;
	}
	public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
		String s = sc.nextLine();
		System.out.println(reverseString(s));
	}
}

https://my.newtonschool.co/playground/code/elvme4e1dps4/
Palindrome [Recursive] Palindrome is a word, phrase, or sequence that reads the same backwards as forwards. Use recursion to check if a given string is palindrome or not.
User Task: Since this is a functional problem, you don't have to worry about the input, you just have to complete the function check_Palindrome() where you will get input string, starting index of string (which is 0) and the end index of string( which is str.length-1) as argument. 
Sample Input
2
ab
aba
Sample Output
false
true


static boolean check_Palindrome(String str,int s, int e) 
    { 

        if (s >= e) {
            return true;
        }

        if (str.charAt(s) != str.charAt(e)) {
            return false;
        }

      return check_Palindrome(str, s+ 1, e - 1);
    }


Multiplication https://my.newtonschool.co/playground/code/q91s1s78lig5/
Given two numbers m and n, multiply them using only "addition" operations.

static int  Multiply_by_recursion(int M, int N) 
    { 
        //return M*N;
        //if (M < N)
          //  return Multiply_by_recursion(N, M);
     
     // but already given M<=N

        // iteratively calculate
        // N times sum of M
        if (N != 0)
            return (M + Multiply_by_recursion(M, N - 1));
     
        // if any of the two numbers is
        // zero return zero
        else
            return 0;
    }


Tower of Hanoi https://my.newtonschool.co/playground/code/ck2qbn9hiibr/
The Tower of Hanoi is a mathematical puzzle where we have 3 rods and N disks. The puzzle starts with all the disks in ascending order of size on the first row. The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:
1. Only one disk can be moved at a time.
2. Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.
3. No larger disk may be placed on top of a smaller disk.
-----x--x--x------
Let the rods have names A, B and C. Given N number of disks, numbered 1 to N from top to bottom, display all the moves required to move the disks from rod A to C in minimum number of steps.
Print sequence of moving disks, where each move is shown in the following format-
{DiskNumber}:{FromRod}->{ToRod}
Each move in the sequence is separated by a new line
Example Input 2
Output
1:A->B
2:A->C
1:B->C

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
	  // Tower Of Hanoi
    public static void towerOfHanoi(int n, String fromTower, String toTower, String extraTower) {
        if (n == 0) {
            return;
        }
        // n - 1... 1 2
        towerOfHanoi(n - 1, fromTower, extraTower, toTower);
        System.out.println(n + ":" + fromTower + "->" + extraTower);
        towerOfHanoi(n - 1, toTower, fromTower,extraTower );
    }

    public static void main(String[] args) {
       Scanner sc = new Scanner (System.in);
      int  c=sc.nextInt();
        towerOfHanoi(c, "A", "B", "C");
    }

	
}

Subsets Solve using Recursion
Given an array of integers that might contain duplicates, return all possible subsets.
Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
The subsets must be sorted lexicographically.
Output One line per test case, every subset enclosed in () and in every set intergers should be space seperated.(See example)

Sample Input:
2
3
1 2 2
4
1 2 3 3
Sample Output:
()(1)(1 2)(1 2 2)(2)(2 2)
()(1)(1 2)(1 2 3)(1 2 3 3)(1 3)(1 3 3)(2)(2 3)(2 3 3)(3)(3 3)
Explanation:
Testcase 1: Subsets are
[
[],
[1],
[1,2],
[1,2,2],
[2],
[2, 2]
]

aPPROACH Solution without RECUSION
class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
        int tc = sc.nextInt();
        while (tc-- > 0) {
            int n = sc.nextInt();
            int arr[] = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = sc.nextInt();
            }
            Arrays.sort(arr);
            TreeSet<String> ans = new TreeSet<>();
            for (int i = 1; i < (1 << n); i++) {
                StringBuffer sb = new StringBuffer();
                for (int j = 0; j < n; j++) {
                    if ((i & (1 << j)) != 0)
                        sb.append(arr[j] + " ");
                }
                if (i != 0) {
                    sb.deleteCharAt(sb.length() - 1);
                    ans.add(sb.toString());
                }
            }
            System.out.print("()");
            for (String s : ans) {
                System.out.print("(" + s + ")");
            }
            System.out.println();
        }
        
	}
}
// Iterative function to print all distinct subsets of `S`
    /*public static void findPowerSet(int[] S) {
        int N = (int)Math.pow(2, S.length);
        Set<List<Integer>> set = new HashSet<>();
        Arrays.sort(S);
        // generate each subset one by one
        for (int i = 0; i < N; i++) {
            List<Integer> subset = new ArrayList<>();
            // check every bit of `i`
            for (int j = 0; j < S.length; j++) {
                // if j'th bit of `i` is set, append `S[j]` to the subset
                if ((i & (1 << j)) != 0) {
                    subset.add(S[j]);
                }
            }
            // insert the subset into the set
            set.add(subset);
        }
        System.out.println(set);
    }*/

/*	public static void printSubsets(int set[]){
        int n = set.length; // Run a loop for printing all 2^n subsets one by one
        int N = (int)Math.pow(2, set.length);
        for (int i = 0; i < (1<<n); i++){
        //for (int i = 0; i < N; i++){
            System.out.print("( ");

            // Print current subset
            for (int j = 0; j < n; j++){
                // (1<<j) is a number with jth bit 1 so when we 'and' them with the
            // subset number we get which numbers are present in the subset and which
            // are not
                //if ((i & (1 << j)) != 0)
                if ((i & (1 << j)) > 0)
                   // System.out.print(i & (1 << j));
                    System.out.print(set[j] + " " );
            } 
            System.out.println(")");

        }
    }*/


Black and White Hard //Count ways to place Knights moving in L shape in chessboard

How many ways are there to place a black and a white knight on an N * M chessboard such that they do not attack each other? The knights have to be placed on different squares. A knight can move two squares horizontally and one square vertically (L shaped), or two squares vertically and one square horizontally (L shaped). The knights attack each other if one can reach the other in one move.
Sample Input:
3
2 2
2 3
4 5
Sample Output:
12
26
312
Explanation:
Test Case 1: We can place a black and a white knight in 12 possible ways such that none of them attacks each other.
without recusion
class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int testCases = sc.nextInt();
		
		for(int i = 0; i < testCases;i++){
			int N = sc.nextInt(); 
			int M = sc.nextInt();
			System.out.println(knightBlackWhite(N, M));
		} 
 		//System.out.println(Solve(N, M));
	}

	public static long knightBlackWhite (int N, int M){
		// Total arrangements
		long ans = (N * M - 1) * N * M;
		if (N >= 1 && M >= 2){
			// Attacks possible in one horizontal
			// and two vertical steps
			ans -= (4 * (N - 1) * (M - 2));	
		}
		if (N >= 2 && M >= 1){
			// Attacks possible in Two horizontal and one vertical steps
			ans -= (4 * (N - 2) * (M - 1));
		}
		return ans;
	}
}




Minimum operations
Sara is learning bits manipulation today and she is stuck on a problem and asks for your help.
Problem:-
Given an integer N. Your task is to change the integer to 0 by performing the following operations:-
1. Change the rightmost digit(0th index). i. e you can change the rightmost digit to 1 if it is 0 or 0 if it is 1.
2. Change the ith bit if (i-1)th bit is 1 and all bits right to (i-1) is 0. For eg:- you can change the left most bit of these numbers:- 1100, 110, 110000.
Your task is to find the minimum operation to make the number 0.
Sample Input:-
3
Sample Output:-
2
Explanation:-
3- >11(binary representation)
01;- Change the leftmost bit using the second operation
00:- Change the rightmost bit using the first operation 
14 --- 11
Explanation:-
14 - > 1110
1111 - > using 1st operation
1101 - > using 2nd operation
1100 - > using 1st operation
0100 - > using 2nd operation
0101 - > using 1st operation
0111 - > using 2nd operation
0110 - > using 1st operation
0010 - > using 2nd operation
0011 - > using 1st operation
0001 - > using 2nd operation
0000 - > using 1st operation

class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		System.out.println(minimumOneBitOperations(num, 0));
	}

	public static int minimumOneBitOperations(int n, int res){
        if (n == 0)
            return res;
        // Store the highest power of 2
        // less than or equal to n
        int b = 1;
        while ((b << 1) <= n)
            b = b << 1;
        // Return the result
        return minimumOneBitOperations((b >> 1) ^ b ^ n, res + b);
    }
}


Gray Code
You are given a decimal number n. You need to find the gray code of the number n and convert it into decimal.
Binary to Gray conversion :
1. The Most Significant Bit (MSB) of the gray code is always equal to the MSB of the given binary code.
2. Other bits of the output gray code can be obtained by XORing binary code bit at that index and previous index.
Eg: Gray code of 01001 is 01101

class Main {

	// Right Shift the number  by 1 taking xor with original number
	public static int grayCode(int n){ 
        return n ^ (n >> 1);
    }
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int arrSize = sc.nextInt();
		int[] grayCodeArr = new int[arrSize];
		for(int i =0; i < arrSize;i++){
			grayCodeArr[i] = sc.nextInt();
			System.out.println(grayCode(grayCodeArr[i]));
		}  
	}
}



CakeXor (Contest) Problem Statement
You are given an array A, you need to create an array B such that B(i) is the Xor of all the elements of A except A(i).

class Main {
	public static void main (String[] args) {
        Scanner sc =new Scanner(System.in);
		int arrSize = sc.nextInt();
		int[] arrA = new int[arrSize];
		for(int i = 0; i< arrSize;i++){
			arrA[i] = sc.nextInt();
		}
		constructXOR(arrA,arrSize);


		for (int i = 0; i < arrSize; i++)
            System.out.print(arrA[i] + " ");
	}
	public static void constructXOR(int A[], int n)
    {
         
        // calculate xor of array
        int XOR = 0;
        for (int i = 0; i < n; i++)
            XOR ^= A[i];
     
        // update array
        for (int i = 0; i < n; i++)
            A[i] = XOR ^ A[i];
    }
}


A Boolean Matrix Problem
You are given a matrix Mat of m rows and n columns. The matrix is boolean so the elements of the matrix can only be either 0 or 1.
Now, if any row of the matrix contains a 1, then you need to fill that whole row with 1. After doing the mentioned operation, you need to print the modified matrix.

Input:
2
5 4
1 0 0 0
0 0 0 0
0 1 0 0
0 0 0 0
0 0 0 1
1 2
0 0
Output:
1 1 1 1
0 0 0 0
1 1 1 1
0 0 0 0
1 1 1 1
0 0 

class Main {
	public static void main (String[] args) throws IOException {
   		/*Scanner sc= new Scanner(System.in);
		int testCases = sc.nextInt();
		int m, n;
		for(int tci = 0; tci< testCases; tci++){
			m = sc.nextInt();
			n = sc.nextInt();
			int[][] arrMatrix = new int[m][n];
			for(int i = 0; i < m; i++){
				for(int j = 0; j<n; j++){
					arrMatrix[i][j] = sc.nextInt(); 
					//System.out.print(arrMatrix[i][j] + "\t");
				}	
			}	
		}*/

		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		byte testCases =  Byte.parseByte(br.readLine());
		short mRow = 0;
		short nCol = 0;
		byte check = 0;
		String[] str;
		for(byte i = 0; i < testCases; i++){
			str = br.readLine().split(" ");
			mRow = Short.valueOf(str[0]);
			nCol = Short.valueOf(str[1]);
			byte[][] a = new byte[mRow][nCol];

			for(short j = 0; j < mRow; j++){
				check = 0;
				str = br.readLine().split(" ");
				for(short k = 0; k < nCol; k++){
					a[j][k] = Byte.parseByte(str[k]);
					if((a[j][k] == 1)){
						check = 1;
					}
				}
				//printing Matrix
				for(short l = 0; l < nCol; l++){
					System.out.print(check+ " ");
				}
				System.out.println();
			}
			
		}
	}

	/*public static void changeRowColumn(int[][] mat, int M, int N, int x, int y)
    {
        for (int j = 0; j < N; j++)
        {
            if (mat[x][j] == 1) {
                mat[x][j] = 1;
            }
			System.out.print(mat[x][j]+" ");
        }
		
        for (int i = 0; i < M; i++)
        {
            if (mat[i][y] == 1) {
                mat[i][y] = 1;
            }
			System.out.print(mat[i][y] + " ");
        }
		
    }*/
}



sprime
Problem Statement
Sara has developed a new algorithm to find sprime for a given range starting with 2
She will start from the end mark it sprime, and mark all its factors (excluding itself) as not sprime. Then she will find the next greatest unmarked number, mark it as sprime, and mark all its factors (excluding itself) as not sprime. Your task is to calculate the the number of sprimes that are actually prime

class Main {
    public static void main(String[] args) {
        // Your code here
        boolean[] isPrime = new boolean[10000001];
        for (int i = 2; i <= 10000000; i++)
            isPrime[i] = true;
        for (int i = 2; i * i <= 10000000; i++) {
            if (isPrime[i]) {
                for (int j = i * i; j <= 10000000; j += i) {
                    isPrime[j] = false;
                }
            }
        }
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t > 0) {
            int n = sc.nextInt();
            int count = 0;
            for (int i = n; i > n / 2; i--) {
                if (isPrime[i])
                    count++;
            }
            System.out.println(count);
            t--;
        }
    }
}

Minimize XOR Problem Statement
Given an integer array A of N integers, find the pair of integers in the array which have minimum XOR value. Report the minimum XOR value.

class Main {
	public static void main (String[] args) {
    	Scanner sc = new Scanner (System.in);
		int arrSize = sc.nextInt();
		int[] arr = new int[arrSize];
		//int n = arr.length;
		for(int i = 0; i < arr.length; i++){
			arr[i] = sc.nextInt();
			//System.out.println(minXOR(int arr[], int n));
		}
			System.out.println(minXOR1(arr,arrSize));
	}

	public static int minXOR1(int arr[], int n){
        // Sort given array
        //Arrays.parallelSort(arr);
		Arrays.sort(arr);
        int minXor = Integer.MAX_VALUE;
        int val = 0;
        // calculate min xor of consecutive pairs
        for (int i = 0; i < n - 1; i++) {
            val = arr[i] ^ arr[i + 1];
            minXor = Math.min(minXor, val);
        }
 
        return minXor;
    }
	other method
public static int minXOR(int arr[], int n)
    {
        int min_xor = Integer.MAX_VALUE; 
        // Generate all pair of given array
        for (int i = 0; i < n; i++){
            for (int j = i + 1; j < n; j++){
                min_xor = Math.min(min_xor, arr[i] ^ arr[j]);
				//System.out.println( " i" + arr[i] + "j " +arr[j] +" = "+(arr[i] ^ arr[j]));
			}
		}
        return min_xor;
    }
}


GCD Pairs (Contest)
Easy
Problem Statement
Given an array Arr of N elements. Find the maximum value of GCD(Arr[i], Arr[j]) where i != j.

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner (System.in); 
		int arrSize = sc.nextInt();
		int[] arr = new int[arrSize]; 
		for(int i = 0; i<arrSize;i++){
			arr[i] = sc.nextInt();
		}
		System.out.println(findMaxGCD1(arr,arrSize));
		//System.out.println(findMaxGCD(2,2));
	}

	 public static int findMaxGCD1(int arr[], int n){
        // Computing highest element
        int high = 0;
        for (int i = 0; i < n; i++){
            high = Math.max(high, arr[i]);
		}
        // Array to store the count of divisors requird GCDs
        int divisors[] =new int[high + 1];
        // Iterating over every element
        for (int i = 0; i < n; i++){
            // Calculating all the divisors
            for (int j = 1; j <= Math.sqrt(arr[i]); j++) {
                // Divisor found
                if (arr[i] % j == 0){
                    divisors[j]++; // Incrementing count for divisor
        // Element/divisor is also a divisor Checking if both divisors are not same
                    if (j != arr[i] / j)
                        divisors[arr[i] / j]++;
                }
            }
        }
        // Checking the highest potential GCD/ If this divisor can divide at least 2 numbers, it is a GCD of at least 1 pair
        for (int i = high; i >= 1; i--){
            if (divisors[i] > 1){
                return i;
			}
		}
        return 1;
    }
}

closest Prime (Contest)
Problem Statement
Given an integer N, find the closest prime number to N. If there are multiple print the smaller one.

class Main {

    public static boolean isPrime(int n){
		if(n==0||n==1){
			return false;
		}
		for(int i=2; i<=Math.sqrt(n); i++){
			if(n%i==0){
				return false;
			}
		} return true;
	}

	public static void main (String[] args) {
       	Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();

        for(int i = 0; i <= num; i++){
			if(isPrime(num - i) == true){
				System.out.println(num - i);
				break;
			}
			if(isPrime(num + i) == true){
				System.out.println(num + i);
				break;
			}
		}

        /*int diff1 = 0, diff2 = 0;
        int num1 = 0, num2 = 0;

        for(int i = num;;i++){
            if(isPrime(i)){
                diff1 = i - num;
                num1 = i;
                break;
            }
        }
    //No end limit as when prime will be found we will break the loop.
        for(int i = num;;i--){
            if(isPrime(i)){
                diff2 = num - i;
                num2 = i;
                break;
            }
        }
        //System.out.print( "Diff 1" + diff1 + "Diff 2" + diff2);
        if(diff1 < diff2){
            System.out.println(num1);
            //System.out.println("Nearest Prime Number from "+num+" is "+num1);
        }else if(diff2 < diff1){
            System.out.println(num2);
            //System.out.println("Nearest Prime Number from "+num+" is "+num2);
        }else{
            System.out.println(num2);
            //System.out.println("Nearest Prime Number from "+num+" is "+num2+" and "+num1);
        }*
	}	
}


Mex of 2 (Public Contest: April 2022)
Problem Statement
You are given two non-negative integers, A and B. You are required to print the smallest non-negative integer such that it is not equal to both A and B.
Sample Input 1:
0 1
Sample Output 1:
2 
class Main {
	public static void main (String[] args) {
                      // Your code here
		//int[] arr = {4,5};
		Scanner sc = new Scanner(System.in);
		int a = sc.nextInt();
		int b = sc.nextInt();
		int[] arr = {a,b};
		System.out.println(findMex(arr));
	}
	
	public static int findMex(int a[]){
		int n = a.length;
	    int b[] = new int[10];
	    for(int i = 0;i < n; i++){
	        b[a[i]] = 1;
			//System.out.println(b[a[i]]);
	    }
	    int i = 0;
		//System.out.println(b[i]);
	    while(b[i] != 0){
	        i++;
	    }
	    return i;
	}
}


Cricket Fever

Medium
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Everyone is so excited about the upcoming cricket championship, so they decided to have a fun event before the start, in which they will be conducting a dummy tournament but the winner will be decided on the basis of the supporters of the team. There are 2^K teams participating in this tournament named from Team 1, Team 2, to Team 2^K, and there will be exactly 2^K -1 matches (knockout tournament).

Winning Criteria: The winner of the match will be decided by the number of supporters i.e. team having more supporters will win the match. If the number of supporters are same then the winning team will be the one that has a lower team number.

There is one more twist, the supporters of the losing team will join the supporters of the team which is going against the team who eliminated their team.

Thus matches which is going to be played in tournament will take place in below format:
Match 1: team 1 vs team 2,
   winner: team 1(if team 1 supporter is more than team 2)

Match 2: team 3 vs team 4.
   winner: team 3(if team 3 supporter is more than team 4)

Match 3: team 1 vs team 3 (team 2 supporter joins team 3 and team 4 supporters joins team 1)

Your task is to find the number of supporters of the team which wins the tournament.

class Main {
   public static int recur(int arr[], int k){//k= 3 arr -> 8
       if(k == 1){
           return arr[0]>arr[1]? arr[0] : arr[1];
       }
       int n = (int)Math.pow(2,k-1);
       int b[] = new int[n];// 4 elements
       // System.out.println(b.length);
       for(int i =0;i<arr.length;i=i+4){
           if(arr[i] > arr[i+1]){
               b[(i/2)] += arr[i];
               b[(i/2)+1] += arr[i+1];
           }
           else{
               b[(i/2)] +=arr[i+1];
               b[(i/2)+1] += arr[i];
           }
           if(arr[i+2] > arr[i+3]){
               b[(i+2)/2] += arr[i+2];
               b[((i+2)/2)-1] += arr[i+3];
           }
           else{
               b[((i+2)/2)] +=arr[i+3];
               b[((i+2)/2)-1] += arr[i+2];
           }
       }
       // for(int i=0;i<b.length;i++){
       //  System.out.print(b[i]+ " ");
       // }
       // System.out.println();
       return recur(b, k-1);
   }
   public static void main (String[] args) {
       Scanner sc = new Scanner(System.in);
       int k = sc.nextInt();
       int n = (int)Math.pow(2,k);
       // System.out.println(n);
       int arr[] = new int[n];
       for(int i =0;i<n;i++){
           arr[i] = sc.nextInt();
       }
 
       int answer = recur(arr, k);
       System.out.println(answer);
   }
}

without recurssion hemant https://my.newtonschool.co/playground/code/gdq73gmucu2s/
Scanner sc= new Scanner(System.in);
		int k= sc.nextInt();
		int n= (int)Math.pow(2,k);
		int[] a= new int[n];
		for(int g=0; g<n; g++){
			a[g]= sc.nextInt();
		}
		int temp=0;
		for(int h=0; h<n-1; h=h+2){
			if(a[h]<a[h+1]){
				temp= a[h];
				a[h]= a[h+1];
				a[h+1]= temp;
			}
		}
		for(int i=1; i<n/2; i=i*2){
		for(int j=0; j<n; j= j+(4*i)){
			if((a[j]+a[j+1+(2*i)])<(a[j+1]+a[j+2*i])){
				temp= (a[j]+a[j+1+(2*i)]);
				a[j]= (a[j+1]+a[j+2*i]);
				a[j+1]= temp;
				//System.out.print(a[j]+ " "+ a[j+1]+ "   ");
			}else{
				a[j]= (a[j]+a[j+1+(2*i)]);
				a[j+1]= (a[j+1]+a[j+2*i]);
				//System.out.print(a[j]+ " "+ a[j+1]+ "   ");
			}
		}}
		
			System.out.print(a[0]);
		
	}




Given an integer array A of size N. Find the sum of GCD (Greatest Common Divisor) of all elements with their frequency.
GCD frequency
change by me soluion
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
class Main {
	public static long GCD(long m, long n){
		if(n==0){
			return m;
		}
		return GCD(n, m%n);
	}
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int nElement = sc.nextInt();
		int[] arr = new int[nElement];
		//int n = arr.length;
		for(int i = 0; i < nElement; i++){
			arr[i] = sc.nextInt();
		}
		int[] printFreq= new int[nElement];
		int gcdAns = 0;
		for(int k = 0; k < nElement; k++){
			printFreq[k]= CheckFrequency(arr, k);
			gcdAns = gcdAns + GCD(arr[k], printFreq[k]);
			//System.out.println(f[g]);
		}
		
		System.out.println(gcdAns);
	}  	

	public static int CheckFrequency(int a[], int j){
		int count = 0;
		for (int i = 0; i < a.length; i++){
			if (a[j] == a[i]){
				//System.out.print(a[i] + " " + a[j]);
				count++;
			}
		}
		return count;
	}
	public static int GCD(int m, int n){
		if(m == n){
			return m;
		}
		int a = (m < n) ? m:n;
		int b = (m > n) ? m:n;
		int count = 0;
		for(int i = 1; i <= a; i++){
			if(a % i == 0){
				if((b % (a/i)) == 0){
					count = a / i;
					break;
				}
			}
		}
		return count;
	}
}


other soution
class Main {
	public static void main (String[] args) {
                      // Your code here
		Scanner sc= new Scanner(System.in);
		int n= sc.nextInt();
		int[] a= new int[n];
		for(int k=0; k<n; k++){
			a[k]= sc.nextInt();
		}
		int[] f= new int[n];
		int sum=0;
		for(int g=0; g<n; g++){
			f[g]= fre(a, g);
			sum = sum+ gcd(a[g], f[g]);
			//System.out.println(f[g]);
		}
		
			System.out.println(sum);
	}

	public static int gcd(int m, int n){
		if(m==n){return m;}
		int a= (m<n)?m:n;
		int b= (m>n)?m:n;
		int count=0;
		for(int i=1;i<=a; i++){
			if(a%i==0){
				if((b%(a/i))==0){
					count= a/i;
					break;
				}
			}
		}
		return count;
	}

	public static int fre(int[] a,int i){
		int count=0;
		for(int k=0; k<a.length; k++){
			if(a[i]==a[k]){count++;}
		}
		return count;
	}
}



Identical Groups
Problem Statement
Myra has x red colour balls and y blue colour balls. She wants to distribute these balls into identical groups without any balls left. What is the largest number of groups she can make?
Identical groups mean there are equal number of same coloured balls in each group.

class Main {
	public static int GCD (int x,int y){
       if (y==0){
		   return x;
	   }   
		   return GCD(y, x%y);		
	}
	
	public static void main(String[]args)
	{ 
		Scanner sc = new Scanner(System.in);
	   	int x = sc.nextInt();
	   	int y = sc.nextInt();
	   	int gcd = GCD(x,y);
	   	System.out.println(gcd);
	}
}


Subsets ---to be check for recursive https://www.geeksforgeeks.org/recursive-program-to-generate-power-set/
this problem should do in recurrsion
Given an array of integers that might contain duplicates, return all possible subsets.
2
3
1 2 2
4
1 2 3 3
Sample Output:
()(1)(1 2)(1 2 2)(2)(2 2)
()(1)(1 2)(1 2 3)(1 2 3 3)(1 3)(1 3 3)(2)(2 3)(2 3 3)(3)(3 3) 

Note:
Elements in a subset must be in non-descending order.
The solution set must not contain duplicate subsets.
The subsets must be sorted lexicographically.

one solution :-

public static void main(String[] args)
    {
        char set[] = {'1', '2', '2'};
        printSubsets(set);
    }
    
    public static void printSubsets(char set[])
    {
        int n = set.length;
        // Run a loop for printing all 2^n
        // subsets one by one
        for (int i = 0; i < (1<<n); i++)
        {
            System.out.print("{ ");
 
            // Print current subset
            for (int j = 0; j < n; j++)
                if ((i & (1 << j)) > 0)
                    System.out.print(set[j] + " ");
 
            System.out.println("}");
        }
    }


Is this prime? Hard
Let's assume some functional definitions for this problem.
We take prime(x) as the set of all prime divisors of x. For example, prime(140)={2,5,7}, prime(169)={13}.
Let f(x,p) be the maximum possible integer p**k where k is an integer such that x is divisible by p**k. (Here a**b means a raised to the power b or pow(a, b))
For example: f(99,3)=9 (99 is divisible by 3**2=9 but not divisible by 3**3=27),
f(63,7)=7 (63 is divisible by 7**1=7 but not divisible by 7**2=49).
Let g(x,y) be the product of f(y,p) for all p in prime(x).
For example:
g(30,70)=f(70,2)*f(70,3)*f(70,5)=2*1*5=10,
g(525,63)=f(63,3)*f(63,5)*f(63,7)=9*1*7=63.
You are given two integers x and n. Calculate g(x,1)*g(x,2)*…*g(x,n) mod (1000000007).
(Read modulo exponentiation before attempting this problem)
Constraints
2 ≤ x ≤ 1000000000
1 ≤ n ≤ 1000000000000000000
Sample Input 1 10 2
Sample Output 1 2
Sample Input 2 20190929 1605
Sample Output 2 363165664
Explanation In the first example, g(10,1)=f(1,2)⋅f(1,5)=1, g(10,2)=f(2,2)⋅f(2,5)=2.

#include<bits/stdc++.h>
#pragma GCC optimize "03"
using namespace std;
#define primeFunction main
#define int long long int
#define ld long double
#define pi pair<int, int>
#define pb push_back
#define fi first
#define se second
#define IOS ios::sync_with_stdio(false); cin.tie(0); cout.tie(0)
#ifndef LOCAL
#define endl '\n'
#endif
 
const int N = 2e5 + 5;
const int mod = 1e9 + 7;
const int inf = 1e9 + 9;

int power(int a, int b){
	int ans = 1;
	b %= (mod-1);
	while(b){
		if(b&1)
			ans = (ans*a) % mod;
		b >>= 1;
		a = (a*a) % mod;
	}
	return ans;
}

int f(int n, int p){
	int ans = 1;
	int cur = 1;
	while(cur <= n/p){
		cur = cur*p;
		int z = power(p, n/cur);
		ans = (ans*z) % mod;
	}
	return ans;
}

signed primeFunction() {
	IOS;
	int x, n, ans = 1;
	cin >> x >> n;
	for(int i = 2; i*i <= x; i++){
		if(x%i != 0)	continue;
		ans = (ans*f(n, i)) % mod;
		while(x%i == 0)
			x /= i;
	}	
	if(x > 1)
		ans = (ans*f(n, x)) % mod;
	cout << ans;
	return 0;
}



**Nth number made of prime digits
Medium Problem Statement
Given a number 'N'. The task is to find the Nth number whose each digit is a prime number(<10) i.e 2, 3, 5, 7. In other words you have to find nth number of this sequence : 2, 3, 5, 7, 22, 23 ,.. and so on.
In this post, a O(log n) solution is discussed which is based on below pattern in numbers. The numbers can be seen
                                  ""
      /                	|                    |                 	\
     2                 	3                    5               	7
 / |  | \           	/ | |  \             /  | | \         	 /  | |  \ 
22 23 25 27        32 33 35 37         52 53 55 57        72 73 75 77
/||\/||\/||\/||\  	        /||\/||\/||\/||\   	/||\/||\/||\/||\  	         /||\/||\/||\/||\

We can notice following :
1st. 5th, 9th. 13th, ..... numbers have 2 as last digit.
2nd. 6th, 10th. 14th, ..... numbers have 3 as last digit.
3nd. 7th, 11th. 15th, ..... numbers have 5 as last digit.
4th. 8th, 12th. 16th, ..... numbers have 7 as last digit.

Assisgemnt sir Approch

	/*static boolean is_prime(int digit){
        if(digit == 2 || digit == 3 || digit == 5 || digit == 7)
            return true;
        return false;
    }
    static boolean digitIsPrime(int num){
        while(num > 0){
            if(is_prime(num % 10) == false)
                return false;
            num = num/10;
        }
        return true;
    }
    static int primeCheck(int n){
        int i = 2;
        int cnt = 0;
        while(true){
            if(digitIsPrime(i)){
                cnt++;
                if(cnt == n){
                    return i;
                }
            }
            i++;
        }
    }*/

Another solution // Java program to find n-th number with prime digits 2, 3 and 7
import java.util.*;
class GFG{
static String nthprimedigitsnumber(int number)
{
	int rem;
	String num="";
	while (number>0) {
	// remainder for check element position
	rem = number % 4;
	switch (rem) {
		// if number is 1st position in tree
	case 1:
		num+='2';
		break;
		// if number is 2nd position in tree
	case 2:
		num+='3';
		break;
		// if number is 3rd position in tree
	case 3:
		num+='5';
		break;
		// if number is 4th position in tree
	case 0:
		num+='7';
		break;
	}
	if (number % 4 == 0)
	number--;
	number = number / 4;
}
	return new StringBuilder(num).reverse().toString();
}
// Driver code
public static void main(String[] args)
{
	int number = 21;
	System.out.println(nthprimedigitsnumber(10));
	System.out.println(nthprimedigitsnumber(21));
}
}
Another driver code with testcases
public static void main (String[] args) {
        Scanner sc = new Scanner(System.in);
		int testCases = sc.nextInt();
		int[] arr; 
		for(int tc = 0; tc < testCases; tc++){
			arr = new int[testCases];
			arr[tc] = sc.nextInt();
			//System.out.println(arr[tc] + " ");
			System.out.println(nthPrimeDigits(arr[tc]));
		}
}




class Solution {
    public static void main(String args[]) 
    {
        int x =10;
        int y = 20;
        if(x++ > 10 && ++y > 20 ){
        System.out.print("Inside if  ");
        }else{
        System.out.print("Inside else  ");
        }
        System.out.println(x +" "+y);
     }
}   check output Inside if  11 20
x++ > 10 || ++y > 20	Inside if  11 21

MAX Number 2 3 4 1D array
one approach
Scanner sc = new Scanner(System.in);
		int testcases = sc.nextInt();
		int sizeofArray = 0;
		
		for(int tci = 0; tci < testcases; tci++){
			sizeofArray = sc.nextInt();
			int arr[] = new int[sizeofArray];
			for(int i = 0; i < sizeofArray; i++){
				arr[i] = sc.nextInt() ;
				//System.out.print(arr[i] +" ");
			}
			print3largest(arr, sizeofArray);
		}
	}

	public static void print3largest(int arr[], int arr_size)
    {
        int first = arr[0];
		int second = 0;
		int third = 0;
        /*if (arr_size < 3) {System.out.print(" Invalid Input ");
            return;
        }*/
        //third = first = second = Integer.MIN_VALUE;
        for (int i = 0; i < arr_size; i++) {
            if (arr[i] > first) {
                third = second;
                second = first;
                first = arr[i];
            }
            else if (arr[i] > second) {
                third = second;
                second = arr[i];
            }
            else if (arr[i] > third)
                third = arr[i];
        }
        System.out.println(first + " " + second + " " + third);
    }

another approch

 public static void main (String[] args) {
        try { 
            BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); 
            int T = Integer.parseInt(input.readLine()); 
            while (T-->0) { 
                int N = Integer.parseInt(input.readLine()); 
                ArrayList<Integer> A = new ArrayList<>(); 
                String [] line = input.readLine().split("\\s+"); 

                for(int i=0;i<N;i++) { 
                    A.add(i,Integer.parseInt(line[i])); 
                } 
                int max = 0, Secondmax = 0, Thirdmax = 0; 
                for(int i = 0; i < N; i++) { 
                    if(A.get(i) > max) { 
                        Thirdmax = Secondmax; 
                        Secondmax = max; 
                        max = A.get(i); 
                    }else if(A.get(i) > Secondmax) { 
                        Thirdmax = Secondmax; 
                        Secondmax = A.get(i); 
                    }else if(A.get(i) > Thirdmax) { 
                        Thirdmax = A.get(i); 
                    } 
                } 
                System.out.println(max + " " + Secondmax + " " + Thirdmax); 
            }
        }catch(Exception e) { return; }
    }




Scanner usrInput = new Scanner(System.in);
		int sizeofArray = usrInput.nextInt();
		int[] arr = new int[sizeofArray];
   		for (int i = 0; i < sizeofArray; i++){
        	arr[i] = usrInput.nextInt();
    	}
		getPairsCount(arr);
	}
	public static void getPairsCount(int[] arr)
    {
        int count = 0, sum; // Initialize result
        // Consider all possible pairs and check their sums
        for (int i = 0; i < arr.length; i++){
            for (int j = i + 1; j < arr.length; j++){
				sum = arr[i] + arr[j];
                if ((arr[i] + arr[j]) <= sum){
                    //count++;
					count = sum;
  			//System.out.println(count);
  			//System.out.println(" " + count + " (" + arr[i] + ", " + arr[j] + ")");
				}
			}
		}
		System.out.println(count);
    }





int number = 987654, reverse = 0;  
while(number != 0)   
{  
int remainder = number % 10;  
reverse = reverse * 10 + remainder;  
number = number/10;  
}  




  Scanner sc = new Scanner(System.in);
 int t = sc.nextInt();
 int N=0,X=0,N1=0,N2=0,N3=0;

if(t>=1 && t<=100){

for(int i=0;i<t;i++) {

N=sc.nextInt();

X=sc.nextInt();

if(N>=0 && N<=100 && X>=0 && X<=30) {

if(X>=10) {
	System.out.println(N3);
} else {
int lastpatientTime = X*(N-1);
int totalTime = 10*(N-1);
System.out.println(totalTime - lastpatientTime);
} 
}

    int waitingTime(int N, int X){
        // code here
        if(X>=10){
            return 0;
        }
        int patient=(N-1)*X;
        int doctor=(N-1)*10;
        int wait=doctor-patient;
        return wait;
    }

Scanner ursInput = new Scanner(System.in);
		float scored = 0, total_marks = 400;
		int  percentage = 0;
		for(int i = 1; i <= 4; i++ ){
		   scored += ursInput.nextInt();
		}
		percentage = Math.round((scored / total_marks) * 100);
        System.out.println(percentage); 


 max = (n1 > n2 && n1 > n3 && n1 > n4) ?
               n1 : ((n2 > n3 && n2 > n4) ?
               n2 : (n3 > n4 ? n3 : n4));

int n;

printf("Enter a 4 digit number\n");

scanf("%d", &n);

float i;

i = (((n + 8)/3)%5)*5;
printf("%f\n", i);


while(N != 1){
        if (N % 2 == 0){
           N = N/2;
           steps++;
        }else if(N % 3 == 0){
           N = N/3;
           steps++;
        }else if(N % 5 == 0){
           N= N/5;
           steps++;
        }else if(N % 7 == 0){
            N = N/7;
            steps++;
        }else{
            N = 1;
            steps++;
        }
    }   
    return steps;


if(a <= 10 && b >= 10){ 
			System.out.println("true");
		} else{
			System.out.println("false");
		}
				
		//if(a <= 10 || b >= 10)
		if(a % 2 == 0 || b % 2 == 0){
			System.out.print(" "+"true");
			//System.out.println("true");
		} else{
			System.out.println("false"); 
		}
		
		if(a!=b)){ 
			System.out.println("true");
		} else{ 
			System.out.println("false");
		}


donation problem 

long sum = arr[0];

	for (int i = 1; i < size; i++) {
		  if (arr[i] < arr[i-1]) {
		  result[i] = arr[i-1] - arr[i];
		  arr[i] = arr[i - 1];
		  sum = sum + arr[i];
		  } else {
			  sum = sum + arr[i];
		  }
	  }
	  for (int i = 0; i < size; i++) {
		  if(i == size - 1) {
				  System.out.println(result[i]);
				  continue;
				  }
	  	System.out.print(result[i] + " ");
		  }
			  //System.out.println();
  System.out.print(sum);

public static void donation (int[] arr){
int[] diffarr = new int [arr.length];
long totalDonation = arr[0];
int max = arr[0];
for(int i= 1;int i<arr.lenth;i++){
if(arr[i]<max){
diffArri[i] = Math.abs(arr[i]-max;
totalDonationa += diffArr[i];
}else{
max = arr[i];
}
totalDonation += arr[i];
}
for(int i = 0;i<diffArr.length;i++){
sop(diffArr[i]+"");
}
sop();
sop(totalDonation);
}


cyclic guess
Scanner usrInput = new Scanner(System.in);
		int sizeofArrS = usrInput.nextInt();
		int arrS[] = new int[sizeofArrS];
		for(int i = 0; i < sizeofArrS; i++) {
			arrS[i] = usrInput.nextInt();
		}

		int sizeofArrC = usrInput.nextInt();
		int arrC[] = new int[sizeofArrC];
		int sum = 0;
		for(int i = 0; i < sizeofArrC; i++) {
			arrC[i] = usrInput.nextInt();
			sum += arrC[i];
		}
		// System.out.print(sum+" ");

		long ans = 0;
		int count = 0;
		int i,j;
		for (i = 0; i <= sizeofArrS - sizeofArrC; i++) {
 
            for (j = 0; j < sizeofArrC; j++) {
                ans += arrS[j];
			}
			if(ans == sum)
			count++;
			else
			ans = 0;
        }
		System.out.print(count);



Scanner sc = new Scanner(System.in);
        int n=sc.nextInt();
        int a[]=new int[n];
        for(int i=0;i<n;i++)
        {
            a[i]=sc.nextInt();
        }

        int[] maxArr= new int[n];
        maxArr[n-1]=a[n-1];

        for(int i=n-2; i>=0; i--){
            maxArr[i]= Math.max(a[i],maxArr[i+1]);
            //System.out.print(Arrays.toString(maxArr));
        }

        int i=0;
        int j=0;
        int max=0;

        while(i<n && j<=n-1){
           if(maxArr[j]>=a[i]){
               max=Math.max(max,j-i);
               j++;

           }

           else 
           i++;
           
        }

        if(max==0){
            max=-1;
        }
        System.out.print(max);
    }




closetprime not perfect but chnge it
Scanner sc = new Scanner(System.in);
    int num = sc.nextInt();
    int diff1=0,diff2=0;
    int num1=0,num2=0;

    for(int i=num;;i++)
        {
          if(isPrime(i))
          {
            diff1=i-num;
            num1=i;
            break;
          }
        }
    for(int i=num;;i--)
        {
          if(isPrime(i))
          {
            diff2=num-i;
            num2=i;
            break;
            }
        }
    if(diff1<diff2)
        System.out.println(num1);
      else
        System.out.println(num2);  
	}

  public static boolean isPrime(int n)
    {
      int c=0;
      int sqrt = (int)Math.sqrt(n);
      for(int i=1;i<=sqrt;i++)
      {
          if(n%i==0)
              c++;
      }
      if(c==2)
          return true;
      else
          return false;
    }



N people are standing in a queue in which A of them like apple and B of them like oranges. How many people like both apple and oranges. 

static int LikesBoth(int N, int A, int B){
      return (A + B) - N;
    }

Mohit has an array of N integers containing all elements from 1 to N, somehow he lost one element from the array.
Given N-1 elements your task is to find the missing one.

Scanner sc = new Scanner(System.in);
		int arrSize = sc.nextInt();
		int[] arr = new int[arrSize];
		for(int  i = 0; i < arrSize-1 ; i++){
			arr[i] = sc.nextInt();
			//System.out.print(arr[i] +" ");
		}
		//System.out.print(arr);
		System.out.print(getMissingNo(arr,arrSize));
	}
	/*public static int findDisappearedNumbers(int[] nums)
    {
        int n = nums.length;
	System.out.print(n);
        int sum = ((n + 1) * (n + 2))/2;
        for(int i = 0;i < n-1; i++)
        sum -= nums[i];
        return sum;
    }*/

	public static int getMissingNo(int a[], int n)
    {
        int nElements_sum = n * (n + 1) / 2;
        int sum = 0;
 
        for (int i = 0; i < n - 1; i++)
            sum += a[i];
 
        return nElements_sum - sum;
    }


Given an array of N elements where N is even. You have to pair up the elements into N/2 pairs such that each element is in exactly 1 pair. You need to find minimum possible X such that there exists a way to pair the N elements and for no pair sum of its elements is greater than X
Sample Input
4
3 1 1 4
Sample Output
5
Explanation: we can pair (1, 3) and (1, 4) so all pairs have sum less than or equal to 5.

Scanner sc =new Scanner(System.in);
		int num = sc.nextInt();
		int[] arr =new int[num];

		for(int i = 0; i<num; i++){
			arr[i] = sc.nextInt();
		}
		Arrays.sort(arr);

		int max = 0;
		for(int i = 0;i< (num/2)-1; i++){
			//System.out.println((num/2)-1);
			if(arr[i] + arr[num-1-i] > max){
				//System.out.println(arr[i] + arr[num-1-i]);
				max = arr[i] + arr[num-1-i]; 
			}
			//System.out.println(arr[i] + arr[num-1-i]);
		}
		System.out.println(max);


Divisors Of N

Problem Statement
Given an integer N, the task is to find the number of divisors of N which are divisible by 2.
Input:
2
9
8
Output
0
3

import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

// don't change the name of this class
// you can add inner classes if needed
class Main {
	public static void main (String[] args) {
                      // Your code here
		Scanner sc = new Scanner(System.in);
		byte testCases = sc.nextByte();
		for(byte i = 0; i < testCases;i++ ){
			int n = sc.nextInt();
			System.out.println(countDivisors1(n,2));
			//System.out.println(countDivisors(n));
		}

	}

	public static int countDivisors1(int n, int k){
    // integer to count the divisors
			int count = 0, i;
		// Traverse from 1 to sqrt(N)
		for (i = 1; i <= Math.sqrt(n); i++) {
			// Check if i is a factor
			if (n % i == 0) {
				// increase the count if i  is divisible by k
				if (i % k == 0){
					count++;
				}
				// (n/i) is also a factor check whether it is divisible by k
				if ((n / i) % k == 0){
					count++;
				}
			}
		}
		i--;
		// If the number is a perfect square and it is divisible by k
			if ((i * i == n) && (i % k == 0)){
				count--;
			}
			return count;
	}
	public static int countDivisors(int n)
	{
		int count = 0, i;
		for (i = 1; i <= n; i++) {
			if (n % i == 0 && i % 2 == 0) {
			//if (n % 2 == 0) {
				count++;
			//}
			}
		}
		return count;
	}
}


Problem Statement
You are given a 2X2 square matrix. You need to find the determinant of the matrix

public static void main (String[] args) {
        // Your code here
		int[][] arr = new int[2][2];
		int determinant = 0;
		Scanner sc= new Scanner(System.in);
		for(int i = 0; i < 2; i++) {
			for(int j = 0; j < 2; j++) {
				arr[i][j] = sc.nextInt();
			}		
		}
		determinant = (arr[0][0] * arr[1][1]) - (arr[0][1] * arr[1][0]);
		System.out.println(determinant );
	}


You are given a NxN matrix. You need to find the transpose of the matrix.
The matrix is of form:
Sample Input
2
1 3
2 2

Sample Output
1 2
3 2

public static void main (String[] args) {
		Scanner sc=new Scanner(System.in);   
		int nArr = sc.nextInt();
		
		//int row = sc.nextInt();     
		//int col = sc.nextInt();   
		int i,j;
		int arrayT[][] = new int[nArr][nArr];   
		for ( i = 0; i < nArr; i++){
            for ( j = 0; j < nArr; j++){
				arrayT[i][j] = sc.nextInt();   
			}//System.out.print(arrayT[i][j]+" ");  
        }
		//System.out.println(" ");
		for(i = 0; i < nArr; i++){  
            for(j = 0; j < nArr; j++){  
            	//System.out.print(arrayT[i][j]+" ");  
				System.out.print(arrayT[j][i]+" ");  
            }  
            System.out.println(" ");  
        }  
		//transpose(arrayT,nArr);         
	}
	/*public static void transpose(int A[][],int arrLen)
    {
        for (int i = 0; i < arrLen; i++){
            for (int j = i+1; j < arrLen; j++)
            {
                 int temp = A[i][j];
                 A[i][j] = A[j][i];
                 A[j][i] = temp;
            }
		}
    }*/

Boundary Traversal of Matrix
Easy
Memory Limit: 128000 kB
Problem Statement
You are given a matrix A of dimensions n x m. The task is to perform boundary traversal on the matrix in clockwise manner.

Input:
4
4 4
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
3 4
12 11 10 9 8 7 6 5 4 3 2 1
1 4
1 2 3 4
4 1
1 2 3 4

Output:
1 2 3 4 8 12 16 15 14 13 9 5
12 11 10 9 5 1 2 3 4 8
1 2 3 4 

public static void main (String[] args) {
		Scanner sc=new Scanner(System.in);   
		
		int testcases =  sc.nextInt();
		
        //System.out.print(testcases+ " " +rowArr+" "+colArr); 
		for(int tci = 1; tci <= testcases; tci++ ){
			int rowArr = sc.nextInt();
	        int colArr = sc.nextInt();
            int[][] arrayT = new int[rowArr][colArr];   
    
            for(int row = 0; row < rowArr ; row++){   
                for(int col = 0; col < colArr ; col++) {
    	        	arrayT[row][col] = sc.nextInt();
                }
            }
            /*for(int row = 0; row < rowArr ; row++){
                for(int col = 0; col < colArr ; col++) {
        	        //System.out.print(arrayT[row][col]+ "\t");
                }
		    } */
          boundaryTraversal(arrayT, rowArr, colArr); 
		}
        System.out.println();

	}

	 public static void boundaryTraversal(int arr[][], int N, int M)
    {
        // Print the first row
        for (int i = 0; i < M; i++) {
            System.out.print(arr[0][i] + " ");
        }
        // Print the last column except the first row
        for (int i = 1; i < N; i++) {
            System.out.print(arr[i][M - 1] + " ");
        }
        // Print the last row except the last column
        if (N > 1) {
            // Print the last row
            for (int i = M - 2; i >= 0; i--) {
                System.out.print(arr[N - 1][i] + " ");
            }
        }
 
        // Print the first column except the first and last row
        if (M > 1) {
            // Print the first column
            for (int i = N - 2; i > 0; i--) {
                System.out.print(arr[i][0] + " ");
            }
        }
         System.out.println();
    }
}

Problem Statement
Mohit has an array of N integers containing all elements from 1 to N, somehow he lost one element from the array.
Given N-1 elements your task is to find the missing one.

public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int arrSize = sc.nextInt();
		int[] arr = new int[arrSize];
		for(int  i = 0; i < arrSize-1 ; i++){
			arr[i] = sc.nextInt();
			//System.out.print(arr[i] +" ");
		}
		//System.out.print(arr);
		System.out.print(getMissingNo(arr,arrSize));
	}
	/*public static int findDisappearedNumbers(int[] nums)
    {
        int n = nums.length;
	System.out.print(n);
        int sum = ((n + 1) * (n + 2))/2;
        for(int i = 0;i < n-1; i++)
        sum -= nums[i];
        return sum;
    }*/

	public static int getMissingNo(int a[], int n)
    {
        int nElements_sum = n * (n + 1) / 2;
        int sum = 0;
 
        for (int i = 0; i < n - 1; i++)
            sum += a[i];
 
        return nElements_sum - sum;
    }

NoXor (Simple Contest)

We need a problem on xor again. Given an array A of N integers (1- indexed), you need to find the sum of (N- i) xor A[i] for all i from 1 to N.
Sample Input
5
1 2 3 4 5
Sample Output
17
Explanation
(5-1)xor1 = 5, (5-2)xor2 = 1, (5-3)xor3 = 1, (5-4)xor4 = 5, (5-5)xor5 = 5. 

public static void main (String[] args) {
                      // Your code here
		Scanner sc = new Scanner(System.in);
		int num = sc.nextInt();
		int[] arr = new int[num];
		long ans=0;
		for (int i = 0; i < num ; i++){
			arr[i] = sc.nextInt();
			//ans += ((num-1-i) ^ arr[i]);
			ans += (num-(i+1)) ^ arr[i];
		}
		System.out.println(ans);
		/*for (int i = 0; i < num; i++){
			ans += ((num-1-i) ^ arr[i]);
		//	sum+=(n-(i+1))^arr[i];
			//System.out.println(ans);
			//System.out.println((num-1 - i) + " " + arr[i] + " " + ((num-1-i) ^ arr[i]));
		}	*/
		//System.out.println(ans);	
		/*Scanner s = new Scanner (System.in);
        int n = s.nextInt();
        int arr[] = new int[n];
        long sum=0;
      
        for(int i=0; i<n; i++)
              {
                	arr[i]=s.nextInt();
                  sum+=(n-(i+1))^arr[i];
              }
        System.out.println(sum); */	 
	}


Pair Em Up (Contest)
Given an array of N elements where N is even. You have to pair up the elements into N/2 pairs such that each element is in exactly 1 pair. You need to find minimum possible X such that there exists a way to pair the N elements and for no pair sum of its elements is greater than X.

Sample Input
4
3 1 1 4

Sample Output
5

Explanation: we can pair (1, 3) and (1, 4) so all pairs have sum less than or equal to 5.

public static void main (String[] args) {
		Scanner sc =new Scanner(System.in);
		int num = sc.nextInt();
		int[] arr =new int[num];

		for(int i = 0; i<num; i++){
			arr[i] = sc.nextInt();
		}
		Arrays.sort(arr);

		int max = 0;
		for(int i = 0;i< (num/2)-1; i++){
			//System.out.println((num/2)-1);
			if(arr[i] + arr[num-1-i] > max){
				//System.out.println(arr[i] + arr[num-1-i]);
				max = arr[i] + arr[num-1-i]; 
			}
			System.out.println(arr[i] + arr[num-1-i]);
		}
		//System.out.println(max);

	}


Maximum difference array
Medium
Time Limit: 2 sec
Memory Limit: 128000 kB
Problem Statement
Given an array of integers of size N, your task is to find the maximum parity index of this array.
Parity Index is the maximum difference between two indices i and j (1 <= i <= j <= N) of an array A such that Ai < Aj.

Sample Input:-
5
1 2 3 4 5

Sample Output:-
4

Explanation:
The maximum difference of jth - ith index is 4:(4th - 0th), also arr[4] > arr[0]

public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
        int n=sc.nextInt();
        int a[]=new int[n];
        for(int i=0;i<n;i++)
        {
            a[i]=sc.nextInt();
        }

        int[] maxArr= new int[n];
        maxArr[n-1]=a[n-1];

        for(int i=n-2; i>=0; i--){
            maxArr[i]= Math.max(a[i],maxArr[i+1]);
            //System.out.print(Arrays.toString(maxArr));
        }

        int i=0;
        int j=0;
        int max=0;

        while(i<n && j<=n-1){
           if(maxArr[j]>=a[i]){
               max=Math.max(max,j-i);
               j++;

           }
           else 
           i++; 
        }

        if(max==0){
            max=-1;
        }
        System.out.print(max);
   // }
	}




chess board

Chess Board

Medium
Problem Statement
Tom loves Chess boards. He admires its symmetry and how the black and white colours are placed adjacently along both the axis.

More formally, a chessboard like coloring implies that no two adjacent cells have the same color and all the cells are painted either white or black.

On his birthday, Tom has been gifted a board which is in the form of a N*N grid. Every cell is painted either black or white. Since Tom loves the placement of colours in a chessboard, he will try to convert the board that has been gifted to him, identical to a chessboard. He has both black and white colours available to him. Help him find out the minimum number of the cell he will have to recolour to paint his board similar to chessboard.
Input:
3
1 1 1
1 1 1
1 1 1

Output:
4
Explanation:
Convert to
1 0 1
0 1 0
1 0 1
Thus we will have to colour 4 cells.
Input:
3
0 1 0
1 0 1
0 1 0
Output:
0
It already has a chess board like coloring.


FastReader sc = new FastReader();
        int N = sc.nextInt();
        int zero=0;
        int one=0;
        for (int i = 1; i <=N ; i++) {
                for (int j = 1; j <=N; j++) {
                    int t_ind = (i+j)%2;
                    int inp= sc.nextInt();
                    if(t_ind==inp) zero++;
                    else one++;
                }
        }
        System.out.println(Math.min(one,zero));
    }
    static class FastReader {
        BufferedReader br;
        StringTokenizer st;

        public FastReader()
        {
            br = new BufferedReader(
                    new InputStreamReader(System.in));
        }

        String next()
        {
            while (st == null || !st.hasMoreElements()) {
                try {
                    st = new StringTokenizer(br.readLine());
                }
                catch (IOException e) {
                    e.printStackTrace();
                }
            }
            return st.nextToken();
        }

        int nextInt() { return Integer.parseInt(next()); }

        long nextLong() { return Long.parseLong(next()); }

        double nextDouble()
        {
            return Double.parseDouble(next());
        }

        String nextLine()
        {
            String str = "";
            try {
                if(st.hasMoreTokens()){
                    str = st.nextToken("\n");
                }
                else{
                    str = br.readLine();
                }
            }
            catch (IOException e) {
                e.printStackTrace();
            }
            return str;
        }
    }
}

https://www.tutorialspoint.com/transform-to-chessboard-in-cplusplus

Chessboard Formation
An N x N board contains only 0s and 1s. In each move, you can swap any 2 rows with each other, or any 2 columns with each other.
What is the minimum number of moves to transform the board into a "chessboard" - a board where no 0s and no 1s are 4-directionally adjacent? If the task is impossible, return -1.
The input line contains T, denoting the number of test cases. Each test case contains two lines. First-line contains N, size of the matrix. Second-line contains N*N elements of binary matrix. 
Input:
2
4
0 1 1 0
0 1 1 0
1 0 0 1
1 0 0 1
3
0 1 0
1 0 1
1 1 0
Output:
2
-1
Explanation:
One potential sequence of moves is shown below, from left to right:
0110 1010 1010
0110 --> 1010 --> 0101
1001 0101 1010
1001 0101 0101

The first move swaps the first and second columns.
The second move swaps the second and third row.


import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework
class Main {

	public static int min_no_of_moves(int [][] arr , int n){
		for(int i = 0; i < n; i++){
			boolean flag_1 = true, flag_2 = true;
			for(int j = 0; j < n; j++){
				if(arr[i][j] == arr[0][j]) flag_1 = false; //any ele in first row matches
				if(arr[i][j] != arr[0][j]) flag_2 = false; //any else does not match in first row
			}
			if(!flag_1 && !flag_2) return -1;
		}
    	int r_s = 0 , c_s = 0, miss_r = 0, miss_c = 0;  //check board formation index
		for(int i = 0; i < n; i++){
			r_s += arr[0][i];
			c_s += arr[i][0];
			if(arr[i][0] == i % 2) miss_r++;
			if(arr[0][i] == i % 2) miss_c++;
		}
		if(r_s != n/2 && r_s != (n+1)/2) return -1;
		if(c_s != n/2 && c_s != (n+1)/2) return -1;

		if(n%2 == 1){
			if(miss_c%2==1){
				miss_c=n-miss_c;
			}
			if(miss_r%2==1){
				miss_r=n-miss_r;
			}
		}else{
			miss_r=Math.min(n-miss_r,miss_r);
			miss_c=Math.min(n-miss_c,miss_c);
		}
		return (miss_c+miss_r)/2;
	}
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
		int test_Case = sc.nextInt();
		while(test_Case-- > 0){
			int n = sc.nextInt();
			int[][] arr = new int[n][n];
			for(int i = 0; i < n; i++){
				for(int j = 0; j < n; j++){
					arr[i][j] = sc.nextInt();
				}
			}
			int result = min_no_of_moves(arr,n);
			System.out.println(result);
		}
	}
}


Given two integers N and M, your task is to print the number of primes present between N and M (both included).
Sample Input:-
1 10
Sample Output:- 4 

public static void main (String[] args) {
                      // Your code here
	Scanner sc = new Scanner(System.in);
	int startN = sc.nextInt();
	int endM = sc.nextInt();
	int primeNumbers, count = 0;
        while (startN < endM) {
			primeNumbers = check_prime(startN);
            if(primeNumbers == 1){
				count ++;
				//System.out.print(startN + " ");
			}
			++startN;
        }
		System.out.print(count);
		  //(x) 

}


Given 2 non-negative integers m and n, find gcd(m, n)
GCD of 2 integers m and n is defined as the greatest integer g such that g is a divisor of both m and n. Both m and n fit in a 32 bit signed integer. 

class Main {
	public static long GCD(long m, long n){
		if(n==0){
			return m;
		}
		return GCD(n, m%n);
	}
	public static void main (String[] args) {
                      // Your code here
		Scanner sc = new Scanner(System.in);
		long m = sc.nextLong();
		long n = sc.nextLong();
		System.out.println(GCD(m, n));
	}  		 
}

Apple and Oranges (Functional Problem)
N people are standing in a queue in which A of them like apple and B of them like oranges. How many people like both apple and oranges.
Note:- It is guaranteed that each and every person likes at least one of the given two
Sample Input:-
5 3 4
Sample Output:- 2 
static int LikesBoth(int N, int A, int B){
      return (A + B) - N;
}


Mohit and average (Functional Problem)
Mohit has three integers A, B, and C with him he wants to find the average of these three integers however he is weak in maths, so help him to find the average. You need to report the floor of the average value.
Sample Input:-
3 4 5
Sample Output:- 4 
static int Average(int A,int B, int C){
    return (A+B+C)/3;
}

Maximum difference array
Given an array of integers of size N, your task is to find the maximum parity index of this array.
Parity Index is the maximum difference between two indices i and j (1 <= i <= j <= N) of an array A such that Ai < Aj.
Sample Input:-
5
1 2 3 4 5
Sample Output:-4
Explanation:
The maximum difference of jth - ith index is 4 :(4th - 0th), also arr[4] > arr[0]
Output Print the maximum value of j- i under the given condition, if no pair satisfies the condition print -1.
import java.io.*; // for handling input/output
import java.util.*; // contains Collections framework

class Main {
	public static void main (String[] args) {
		Scanner sc = new Scanner(System.in);
        int n=sc.nextInt();
        int a[]=new int[n];
        for(int i=0;i<n;i++)
        {
            a[i]=sc.nextInt();
        }

        int[] maxArr= new int[n];
        maxArr[n-1]=a[n-1];

        for(int i=n-2; i>=0; i--){
            maxArr[i]= Math.max(a[i],maxArr[i+1]);
            //System.out.print(Arrays.toString(maxArr));
        }

        int i=0;
        int j=0;
        int max=0;

        while(i<n && j<=n-1){
           if(maxArr[j]>=a[i]){
               max=Math.max(max,j-i);
               j++;

           }
           else 
           i++; 
        }

        if(max==0){
            max=-1;
        }
        System.out.print(max);
   // }
	}
}